<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Something here</title>
  <subtitle>This world was never meant for one as beautiful as you.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://sheilacat.github.io/"/>
  <updated>2016-12-19T12:28:29.267Z</updated>
  <id>http://sheilacat.github.io/</id>
  
  <author>
    <name>SheilaCat</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>微信小程序概念及实践</title>
    <link href="http://sheilacat.github.io/weixin-tiny-program/"/>
    <id>http://sheilacat.github.io/weixin-tiny-program/</id>
    <published>2016-12-19T12:28:00.000Z</published>
    <updated>2016-12-19T12:28:29.267Z</updated>
    
    <content type="html"><![CDATA[<p>微信小程序年前即将发布，自发布以来就广受关注。在这里，介绍下微信小程序的概念，以及一些实践（笔记）。</p>
<p><img src="http://thumbsnap.com/i/GLhHVkkv.jpg?1219" alt="微信小程序"></p>
<a id="more"></a>
<h1 id="微信小程序-概念"><a href="#微信小程序-概念" class="headerlink" title="微信小程序 概念"></a>微信小程序 概念</h1><p>小程序可以借助微信联合登录，和开发者已有的APP后台的用户数据进行打通，但不会支持小程序和APP直接的跳转。</p>
<p>微信小程序提供了底层API和组件，引入了新的文件格式。</p>
<p>微信定义了新的文件格式，<code>wxml/wxss</code>，然后对这些文件做编译解析，所以微信小程序实际上是基于微信的原生应用。</p>
<p>微信小程序只能在微信中运行，并没有减少开发成本，而是多了一个开发流水线。</p>
<p>首先，抛出结论，微信小程序项目：</p>
<ol>
<li><p>不是移植H5</p>
</li>
<li><p>需要一定的学习成本</p>
</li>
<li><p>只能在微信中运行，没有减少开发成本，反而是多了一个开发流水线</p>
</li>
<li><p>微信小程序本身还不完善</p>
</li>
</ol>
<p>微信小程序与其说是拿H5来移植，不如说是需要学习一套新的前端框架，然后进行开发。这里科普几个重要的概念，以便把他们区分开来：</p>
<h2 id="H5-Hybrid："><a href="#H5-Hybrid：" class="headerlink" title="H5+Hybrid："></a>H5+Hybrid：</h2><p>Hybrid依然运行在IOS/Android的Webview容器中，JS执行环境与传统浏览器类似，Hybrid只是提供了可以用于Hybrid的Native接口，这些接口只是对于H5框架的补充。</p>
<h2 id="RN："><a href="#RN：" class="headerlink" title="RN："></a>RN：</h2><p>React Native相当于实现了一个完整的JS执行环境，完全不同于以往的浏览器环境，因而所涉及的性能、UI等核心问题必须通过Native的方式来解决，否则就无法获得类似Native的用户体验。RN的诞生就是为了使用JS来开发媲美原生应用的用户体验的产品。</p>
<h2 id="微信小程序："><a href="#微信小程序：" class="headerlink" title="微信小程序："></a>微信小程序：</h2><p>微信关于小程序里面的QA提到，页面的脚本逻辑是在JsCore中执行的，这也就是微信自己实现的一个JS执行环境，不同于浏览器环境。<br>由于window对象和document对象都是由浏览器提供的，这些在微信小程序里面都不能使用。</p>
<h2 id="H5："><a href="#H5：" class="headerlink" title="H5："></a>H5：</h2><p>HTML5的概念是W3C制定的一种标准，里面提供了一些API和新的语法特征。</p>
<hr>
<p>由上可知，Hybrid（混合模式）是在H5编写的页面的基础上，进行了一层原生的包装，使H5页面能够用原生应用的形式表达出来，或者是嵌入到原生应用中的webview里进行执行，webview就相当于提供给JS执行的浏览器环境。</p>
<p>与其用微信小程序与H5做对比，不如说它更像是RN的一种实现。为了达到原生的效果，它有自己的组件语法等等，而且它本身处于一种封闭式环境。也就是说，微信提供底层技术支持，但玩法都得按照他的规则来。</p>
<p>微信小程序有自己的wxss和wxml，在wxss方面有自己的数据绑定、事件系统、组件、路由，wxss方面相当于一个CSS的子集，并且做了一些自己在移动端的适应拓展。</p>
<p>因此，评估这部分的技术工作量，不应与“移植H5”来做横向对比，而应当是开发RN+JS来进行评估。有一定的学习成本，而且微信小程序本身还不完善，是个封闭的环境，组件的使用等等方面都受到该环境的限制。</p>
<p>题外话，可以知道微信小程序实际上是自己造了一个类似RN+JS的轮子，它引爆互联网主要是因为提出的去中心化的思想，用户可以随用即走。个人感觉这只是PWA+RN的一个融合，概念是Google的PWA，技术是RN。</p>
<p>实际上PWA在2015年中旬就已经提出，并且Chrome、Opera、Firefox都提供了支持。只是苹果的浏览器还不支持，也就是说PWA在国外的安卓市场上实现比较多，而现在国内还缺乏这样一个大环境。貌似腾讯的浏览器也做过类似的实践，但论国内的影响力，现在这个在微信里面提供这样的支持，才能引爆大环境。</p>
<p>即，微信利用自己的平台流量优势，提供封闭的技术支持，来部署它自己的生态。由此，个人感觉这并不是一项技术的创新，更多的是一种概念的实施（不过这项概念在前端工程师眼中算是期待已久，这样JS能做的事情越来越多，从web页面到hybrid，现在脱离了浏览器环境，可以媲美原生应用），甚至是一种商业部署。</p>
<p>&gt;<br>补充一下，感觉pwa这部分论述有误，可以说pwa是在微信小程序的对立面。pwa是让浏览器提供支持，主要是对发送通知，建立桌面入口这样的支持。而微信提供的支持是，按照它的规则来，然后微信进行编译，在它自己的js环境里运行，是媲美原生应用的成果。所以，微信小程序还是比pwa高端一点的，pwa没有跳出浏览器的限制，提出的是渐进式的网页应用，而微信小程序的目标就是轻量级的原生应用。现在感觉可以理解为什么有人会说微信小程序实际上是一个os，几乎可以说，java对应安卓，swift对应ios，那么js就对应微信os了…也就可以理解为什么说是前端工程师的春天…</p>
<p>以上基于本人对相关概念的理解，如有不正确的地方，还望指正。以下是相关笔记，学习微信小程序建议直接看官方API啦。</p>
<h1 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h1><p>根目录下的app,js、app.json、app.wxss<br>微信小程序会读取这些文件，生成 小程序实例</p>
<h2 id="app-js"><a href="#app-js" class="headerlink" title="app.js"></a>app.js</h2><p>可以在这个文件中监听并处理小程序的生命周期函数、声明全局变量。</p>
<h2 id="app-json"><a href="#app-json" class="headerlink" title="app.json"></a>app.json</h2><p>是对整个小程序的全局配置。可以在这个文件中配置小程序是由哪些文件组成的，小程序的窗口背景色、导航条样式、默认标题。<br>注意，该文件不可添加任何注释。</p>
<p>相关配置项：<br><a href="https://mp.weixin.qq.com/debug/wxadoc/dev/framework/config.html?t=1475052047016" target="_blank" rel="external">https://mp.weixin.qq.com/debug/wxadoc/dev/framework/config.html?t=1475052047016</a></p>
<p>在pages中，文件名不需要写后缀，因为框架会自动去寻找路径.json、.js、,wxml、.wxss的四个文件进行整合。</p>
<h2 id="Debug"><a href="#Debug" class="headerlink" title="Debug"></a>Debug</h2><p>调试信息以info的形式给出，其信息有Page的注册、页面路由、数据更新、事件触发。</p>
<h2 id="page-json"><a href="#page-json" class="headerlink" title="page.json"></a>page.json</h2><p>每一个小程序页面都可以用.json的文件来对本页面的窗口表现进行配置，页面中配置项会覆盖app.json中的全局配置。</p>
<h2 id="app-wxss"><a href="#app-wxss" class="headerlink" title="app.wxss"></a>app.wxss</h2><p>是全局样式表。</p>
<h2 id="pages"><a href="#pages" class="headerlink" title="pages/"></a>pages/</h2><p>微信小程序中的每一个页面都需要写在pages/目录下，并且配置在.json文件中。</p>
<h1 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h1><h2 id="逻辑层"><a href="#逻辑层" class="headerlink" title="逻辑层"></a>逻辑层</h2><p>小程序开发框架的逻辑层是由<code>JavaScript</code>编写。</p>
<p>在JS的基础上，由以下附加功能：</p>
<ul>
<li>增加App和Page方法，进行程序和页面的注册</li>
<li>提供微信特有的扫一扫、支付等功能的API</li>
<li>每个页面都有独立的作用域，模块化</li>
<li>开发者写的所有代码最终都会打包成一份JS，并在小程序启动的时候运行直到小程序销毁。类似于ServiceWorker，所以逻辑层也叫App Service。</li>
</ul>
<p>App方法：<a href="https://mp.weixin.qq.com/debug/wxadoc/dev/framework/app-service/app.html?t=1475052056481" target="_blank" rel="external">https://mp.weixin.qq.com/debug/wxadoc/dev/framework/app-service/app.html?t=1475052056481</a></p>
<p>Page方法：<a href="https://mp.weixin.qq.com/debug/wxadoc/dev/framework/app-service/page.html?t=1475052056377" target="_blank" rel="external">https://mp.weixin.qq.com/debug/wxadoc/dev/framework/app-service/page.html?t=1475052056377</a></p>
<h2 id="Page-prototype-setData"><a href="#Page-prototype-setData" class="headerlink" title="Page.prototype.setData()"></a>Page.prototype.setData()</h2><p><code>setData</code>函数用于将数据从逻辑层发送到视图层，同时改变对应的<code>this.data</code>的值。</p>
<p>注意</p>
<ol>
<li>直接修改this.data无效，无法改变页面的状态，还会造成数据的不一致。</li>
<li>单次设置的数据不能超过1024kB。</li>
</ol>
<h2 id="wx-if-VS-hidden"><a href="#wx-if-VS-hidden" class="headerlink" title="wx:if VS hidden"></a>wx:if VS hidden</h2><p>当wx:if的条件值切换时，框架有一个局部渲染的过程，因为它会确保条件块在切换时销毁或重新渲染。</p>
<p>如果初始时是false，那么框架什么也不做，是惰性的。</p>
<p>而hidden，组件始终都会被渲染，只是简单地控制显示与隐藏。</p>
<p>所以，需要频繁切换时用hidden，否则用wx:if。</p>
<h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h2><h3 id="dataset"><a href="#dataset" class="headerlink" title="dataset"></a>dataset</h3><p>在组件中可以定义数据，这些数据将会通过事件传递给 SERVICE。 书写方式： 以data-开头，多个单词由连字符-链接，不能有大写(大写会自动转成小写)如data-element-type，最终在 event.target.dataset 中会将连字符转成驼峰elementType。</p>
<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><h3 id="import"><a href="#import" class="headerlink" title="import"></a>import</h3><p>import可以在该文件中使用目标文件定义的template。</p>
<p>import的作用域，只会import目标文件中定义的template，而不会import目标文件import的template。</p>
<h3 id="include"><a href="#include" class="headerlink" title="include"></a>include</h3><p>include可以将目标文件除了<code>&lt;template /&gt;</code>的整个代码引入，相当于拷贝。</p>
<h2 id="WXSS"><a href="#WXSS" class="headerlink" title="WXSS"></a>WXSS</h2><p>WXSS相当于CSS的子集，并在这个基础上，进行了扩展和修改。</p>
<p>扩展：</p>
<ul>
<li><p>尺寸单位</p>
</li>
<li><p>样式导入</p>
</li>
</ul>
<h3 id="尺寸单位"><a href="#尺寸单位" class="headerlink" title="尺寸单位"></a>尺寸单位</h3><p>rpx （responsive pixel）: 规定屏幕宽度为750rpx。</p>
<p>rem （root em）:规定屏幕宽度为20rem。</p>
<h3 id="样式导入"><a href="#样式导入" class="headerlink" title="样式导入"></a>样式导入</h3><p>@import</p>
<h1 id="开发感受"><a href="#开发感受" class="headerlink" title="开发感受"></a>开发感受</h1><ol>
<li><p>官方已经给出一些固有的组件，并且在设计方面也有一定的参考</p>
</li>
<li><p>小程序本身是要小而美的，目前对应用的大小有限制。</p>
</li>
<li><p>目前还在内部测试阶段，更新版本频繁甚至会出现相互冲突的情况，致使开发者不得不在每个版本上线后，都要进行对应的修改。</p>
</li>
<li><p>更新混乱，安卓版本的微信和苹果版本更新的时间不一致，且实现的结果也与API不一致，留坑。</p>
</li>
</ol>
<h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p><a href="https://mp.weixin.qq.com/debug/wxadoc/dev/" target="_blank" rel="external">微信小程序API</a></p>
<p><a href="https://mp.weixin.qq.com/debug/wxadoc/design/" target="_blank" rel="external">微信小程序设计参考</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;微信小程序年前即将发布，自发布以来就广受关注。在这里，介绍下微信小程序的概念，以及一些实践（笔记）。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://thumbsnap.com/i/GLhHVkkv.jpg?1219&quot; alt=&quot;微信小程序&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="前端技术" scheme="http://sheilacat.github.io/categories/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>node直出与同构javascript</title>
    <link href="http://sheilacat.github.io/node-straight-out/"/>
    <id>http://sheilacat.github.io/node-straight-out/</id>
    <published>2016-09-18T03:06:10.000Z</published>
    <updated>2016-09-18T07:16:49.303Z</updated>
    
    <content type="html"><![CDATA[<h2 id="node直出简要介绍"><a href="#node直出简要介绍" class="headerlink" title="node直出简要介绍"></a>node直出简要介绍</h2><p>node直出，简单地来说，就是把数据直出和页面直出都放在服务端来做，即，在混淆构建阶段服务端完成数据与页面的拼接，最后传给前端一个拼接完成的HTML，那么用户打开页面时，前端只需要进行页面的渲染。为了更好地进行优化，还可以把首屏的CSS也放进内联的CSS里，减少HTTP请求。</p>
<a id="more"></a>
<h3 id="node直出目的"><a href="#node直出目的" class="headerlink" title="node直出目的"></a>node直出目的</h3><ol>
<li><p>为了解决页面显示要等待后台请求（CGI等）返回来才能渲染页面的问题</p>
</li>
<li><p>SEO问题</p>
<p> 随着前端的发展，现在很多都是服务端只给出一个空的页面，或者是给出部分HTML，还有很大需要进行数据交互的页面是由前端进行渲染的，那么spider就无法抓取这部分的HTML内容，从而不能进行良好的SEO。</p>
</li>
</ol>
<h3 id="node直出实现"><a href="#node直出实现" class="headerlink" title="node直出实现"></a>node直出实现</h3><p>一个重要的思想就是javascript同构，想要完成直出，必须在前后端都是用javascript，才能在后端完成页面拼接，那么这时这个负责直出的服务端（直出的服务端与CGI处理的服务端不是同一个），就要完成路由等等后端的概念。</p>
<p>这个概念与阿里提出的前后端分离还是有些相似的，因为js同构这一点，那么需要一个中间层服务端来完成直出，就像前后端分离概念中的node中间层来完成诸如路由这样的东西。</p>
<h2 id="同构javascript"><a href="#同构javascript" class="headerlink" title="同构javascript"></a>同构javascript</h2><p>node直出，通过node直出首屏内容和关键性的SEO信息。无法直出所有内容，通常因为太大，所以前端还是需要维护原有的前端代码。</p>
<p>更多情况下，同一个站点中，我们更希望的是在某些场景下使用前端渲染，另一些情况下使用后端直出（例如，希望hybridapp在没有离线包的第一次直出，后面不需要下载静态文件时使用前端拉取渲染的方式，或者在高级的浏览器下使用http2前端渲染，低端浏览器上则使用直出），结果我们不得不维护两套不同的前后台代码，尽管可能都是用js写的。所以同构希望解决的是维护前后端维护两套代码的问题。</p>
<p>同构的目的，就是希望只开发一套项目代码，既可以实现前端的渲染，也可以做后台的直出。而且可以根据我们的需要，来决定是在前端渲染还是在后台直出。</p>
<p>实现的方式都是通过数据加上模版编译的方式生成，前端渲染与后端直出模式生成DOM的区别只在于数据和渲染发生在什么时候。</p>
<h2 id="同构直出方案"><a href="#同构直出方案" class="headerlink" title="同构直出方案"></a>同构直出方案</h2><h3 id="reactjs"><a href="#reactjs" class="headerlink" title="reactjs"></a>reactjs</h3><p>对于react来说，使用<code>Rendertostring</code>这样的方法，就可以把虚拟DOM渲染成string变量传给前端。完成直出十分便捷。<br>因为virtual dom在前后端都可使用，这样就实现了直出的转换。</p>
<h3 id="mv"><a href="#mv" class="headerlink" title="mv*"></a>mv*</h3><p>自己在服务器端实现一个mvvm的核心，通过自己实现dom分析器来解析后端模版中的directives、filter、和事件绑定就可以。</p>
<p>一般的做法是完全根据现有的某个主流mvvm框架的语法来在后端实现一个功能相同的解析插件。mvc的原理也类似。</p>
<p>这种方式的实现参见：<a href="http://imweb.io/topic/560bb8eac2317a8c3e08623c" target="_blank" rel="external">Qjs直出实现过程</a></p>
<h3 id="实现的核心"><a href="#实现的核心" class="headerlink" title="实现的核心"></a>实现的核心</h3><p>实现的核心，就是保证一个数据渲染机制（react是virtual to html、mvvm是view模版）在前后端都能够正确解析。<br>使用React或mvvm只是说可以更好地做前端模块化管理。</p>
<h2 id="node直出与BigPipe"><a href="#node直出与BigPipe" class="headerlink" title="node直出与BigPipe"></a>node直出与BigPipe</h2><p>与直出并行的，还有一种方案就是BigPipe。</p>
<p>从开发模式上来说，BigPipe这种写法比较适合组件化、模块化的前端开发。</p>
<p>从网站规模上来说，这种优化效果应该比较明显，像是一些由很多模块组成的信息流很多的网站，比如微博<br>BigPipe也就是分步吐出内容。对于小型网站而言，直出会比分步速度更快。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://www.cnblogs.com/vajoy/p/5079943.html" target="_blank" rel="external">降低首屏时间，直出是什么概念</a></p>
<p><a href="http://www.alloyteam.com/2016/07/node-straight-out/" target="_blank" rel="external">简单的原理介绍:node直出理论与实践总结</a></p>
<p><a href="http://jixianqianduan.com/frontend-build/2016/04/21/koa-fis3-swig-nodejs-isomorphic.html" target="_blank" rel="external">基于koa+fis3+swig前后端isomorphic同构实现</a></p>
<p><a href="http://jixianqianduan.com/frontend-javascript/2015/09/20/isomorphic-reactjs.html" target="_blank" rel="external">isomorphic reactjs</a></p>
<p><a href="https://github.com/rendrjs/rendr" target="_blank" rel="external">rendr</a></p>
<p>rendr是一个库，而不是框架。</p>
<p>backbone.js+handlebar实现的基于backbone应用javascript同构</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;node直出简要介绍&quot;&gt;&lt;a href=&quot;#node直出简要介绍&quot; class=&quot;headerlink&quot; title=&quot;node直出简要介绍&quot;&gt;&lt;/a&gt;node直出简要介绍&lt;/h2&gt;&lt;p&gt;node直出，简单地来说，就是把数据直出和页面直出都放在服务端来做，即，在混淆构建阶段服务端完成数据与页面的拼接，最后传给前端一个拼接完成的HTML，那么用户打开页面时，前端只需要进行页面的渲染。为了更好地进行优化，还可以把首屏的CSS也放进内联的CSS里，减少HTTP请求。&lt;/p&gt;
    
    </summary>
    
      <category term="node" scheme="http://sheilacat.github.io/categories/node/"/>
    
    
  </entry>
  
  <entry>
    <title>ECMAScript6学习</title>
    <link href="http://sheilacat.github.io/learn-es6/"/>
    <id>http://sheilacat.github.io/learn-es6/</id>
    <published>2016-09-09T14:17:54.000Z</published>
    <updated>2016-10-08T12:22:23.824Z</updated>
    
    <content type="html"><![CDATA[<h1 id="let和const命令"><a href="#let和const命令" class="headerlink" title="let和const命令"></a>let和const命令</h1><h2 id="let命令"><a href="#let命令" class="headerlink" title="let命令"></a>let命令</h2><ol>
<li><p>let生命的变量仅在块级作用域内有效。</p>
</li>
<li><p>不存在变量提升</p>
</li>
<li><p>暂时性死区（temporal dead zone）</p>
</li>
</ol>
<a id="more"></a>
<p>只要块级作用域内存在<code>let</code>命令，它所声明的变量就binding这个区域，不再受外部的影响。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> tmp = <span class="number">123</span>;</div><div class="line"><span class="keyword">if</span>(<span class="literal">true</span>)&#123;</div><div class="line">    tmp = <span class="string">'abc'</span>; <span class="comment">// ReferenceError</span></div><div class="line">    <span class="keyword">let</span> tmp;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>ES6明确规定，如果区块中存在<code>let</code>和<code>const</code>命令，这个区块就对这些命令声明的变量从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。</p>
<p>ES6规定暂时性死区和<code>let</code>、<code>const</code>语句不出现变量提升，主要是为了减少运行时错误，防止在变量声明前就使用这个变量，从而导致意料之外的行为。</p>
<ol>
<li>不允许重复声明</li>
</ol>
<p>也不能在函数内部重新声明参数。</p>
<h3 id="块级作用域"><a href="#块级作用域" class="headerlink" title="块级作用域"></a>块级作用域</h3><p>ES5只有全局作用域和函数作用域，没有块级作用域，这带来很多不合理的场景。</p>
<ol>
<li>内层变量可能会覆盖外层变量</li>
<li>用来技术的循环变量泄漏为全局变量</li>
</ol>
<p><code>let</code>实际上为JavaScript新增了块级作用域。</p>
<h3 id="块级作用域与函数声明"><a href="#块级作用域与函数声明" class="headerlink" title="块级作用域与函数声明"></a>块级作用域与函数声明</h3><p>ES6规定，函数只能在顶层作用域和函数作用域之中声明，不能在块级作用域中声明。<br>但是，浏览器没有遵守这个规定。所以只会在严格模式下报错。</p>
<p>ES6引入了块级作用域，明确允许在块级作用域之中声明函数。并且规定，块级作用域之中，函数声明语句的行为类似于<code>let</code>，在块级作用域之外不可引用。</p>
<p>但与老代码兼容很有问题，所以ES6规定浏览器实现可以不遵守这样的规定，也就是在支持ES6的浏览器中依然会提前函数声明。</p>
<h2 id="const命令"><a href="#const命令" class="headerlink" title="const命令"></a>const命令</h2><p><code>const</code>声明一个只读的常量。一旦声明，常量的值就不能改变。</p>
<p><code>const</code>的作用域只能在声明的块级作用域内有效。它声明的常量也是不提升，同样存在暂时性死区。不可重复声明。</p>
<p>对于复合类型的变量，变量名不指向数据，而是指向数据所在的地址。const命令只是保证变量名指向的地址不变，并不保证该地址的数据不变，所以将一个对象声明为常量必须非常小心。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> foo = &#123;&#125;;</div><div class="line">foo.prop = <span class="number">123</span>;</div><div class="line"></div><div class="line">foo.prop</div><div class="line"><span class="comment">// 123</span></div><div class="line"></div><div class="line">foo = &#123;&#125;; <span class="comment">// TypeError: "foo" is read-only</span></div></pre></td></tr></table></figure>
<p>如果真的想将对象冻结，应该使用Object.freeze方法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> foo = <span class="built_in">Object</span>.freeze(&#123;&#125;);</div><div class="line"></div><div class="line"><span class="comment">// 常规模式时，下面一行不起作用；</span></div><div class="line"><span class="comment">// 严格模式时，该行会报错</span></div><div class="line">foo.prop = <span class="number">123</span>;</div></pre></td></tr></table></figure>
<h3 id="全局对象的属性"><a href="#全局对象的属性" class="headerlink" title="全局对象的属性"></a>全局对象的属性</h3><p>ES6规定，<code>let</code>命令、<code>const</code>命令、<code>class</code>命令声明的全局变量，不属于全局对象的属性。也就是说，从ES6开始，全局变量将逐步与全局对象的属性脱钩。</p>
<h1 id="变量的解构赋值"><a href="#变量的解构赋值" class="headerlink" title="变量的解构赋值"></a>变量的解构赋值</h1><p>ES6允许按照一定模式，从数组和对象中提取值，对变量进行赋值（Destructuring）。</p>
<p>本质上，这种写法属于“模式匹配”，只要等号两边的模式相同，左边的变量就会被赋予对应的值。</p>
<p>任何部署了Iterator接口的对象，都可以进行解构赋值。</p>
<h2 id="数组的解构赋值"><a href="#数组的解构赋值" class="headerlink" title="数组的解构赋值"></a>数组的解构赋值</h2><p>解构赋值允许指定默认值。</p>
<p>注意，ES6内部使用严格相等运算符（===），判断一个位置是否有值。所以，如果一个数组成员不严格等于undefined，默认值是不会生效的。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> [x = <span class="number">1</span>] = [<span class="literal">undefined</span>];</div><div class="line">x <span class="comment">// 1</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> [x = <span class="number">1</span>] = [<span class="literal">null</span>];</div><div class="line">x <span class="comment">// null</span></div></pre></td></tr></table></figure>
<h2 id="对象的解构赋值"><a href="#对象的解构赋值" class="headerlink" title="对象的解构赋值"></a>对象的解构赋值</h2><p>对象的解构与数组有一个重要的不同。数组的元素是按次序排列的，变量的取值由它的位置决定；而对象的属性没有次序，变量必须与属性同名，才能取到正确的值。</p>
<p>对象的解构赋值的内部机制，是先找到同名属性，然后再赋给对应的变量。真正被赋值的是后者，而不是前者。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> &#123; foo: foo, bar: bar &#125; = &#123; foo: <span class="string">'aaa'</span>, bar: <span class="string">'bbb'</span>&#125;;</div></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> &#123; foo: baz &#125; = &#123; foo: <span class="string">"aaa"</span>, bar: <span class="string">"bbb"</span> &#125;;</div><div class="line">baz <span class="comment">// "aaa"</span></div><div class="line">foo <span class="comment">// error: foo is not defined</span></div></pre></td></tr></table></figure>
<p>上面代码中，真正被赋值的是变量baz，而不是模式foo。</p>
<h2 id="圆括号问题"><a href="#圆括号问题" class="headerlink" title="圆括号问题"></a>圆括号问题</h2><p>解构赋值虽然很方便，但是解析起来并不容易。对于一个式子到底是模式，还是表达式，必须解析到（或解析不到）等号才能知道。</p>
<p>ES6的规则是，只要有可能导致解构的歧义，就不得使用圆括号。</p>
<ol>
<li><p>变量声明语句中，不能带有圆括号；</p>
</li>
<li><p>函数参数中，模式不能带有圆括号。函数参数也属于变量声明；</p>
</li>
<li><p>赋值语句中，不能将整个模式，或嵌套模式中的一层，放在圆括号之中。</p>
</li>
</ol>
<p>可以使用圆括号的情况只有一种：赋值语句的非模式部分。</p>
<h1 id="字符串的拓展"><a href="#字符串的拓展" class="headerlink" title="字符串的拓展"></a>字符串的拓展</h1><h2 id="模板字符串"><a href="#模板字符串" class="headerlink" title="模板字符串"></a>模板字符串</h2><p>模板字符串（template string）是增强版的字符串，用反引号（`）标识。它可以当作普通字符串使用，也可以用来定义多行字符串，或者在字符串中嵌入变量。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$(<span class="string">'#result'</span>).append(<span class="string">`</span></div><div class="line">  There are &lt;b&gt;<span class="subst">$&#123;basket.count&#125;</span>&lt;/b&gt; items</div><div class="line">   in your basket, &lt;em&gt;<span class="subst">$&#123;basket.onSale&#125;</span>&lt;/em&gt;</div><div class="line">  are on sale!</div><div class="line">`);</div></pre></td></tr></table></figure>
<p>如果使用模板字符串表示多行字符串，所有的空格和缩进都会被保留在输出之中。</p>
<p>如果你不想要这个换行，可以使用trim方法消除它。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">$(<span class="string">'#list'</span>).html(<span class="string">`</span></div><div class="line">&lt;ul&gt;</div><div class="line">  &lt;li&gt;first&lt;/li&gt;</div><div class="line">  &lt;li&gt;second&lt;/li&gt;</div><div class="line">&lt;/ul&gt;</div><div class="line">`.trim());</div></pre></td></tr></table></figure>
<h2 id="标签模板（tagged-template）"><a href="#标签模板（tagged-template）" class="headerlink" title="标签模板（tagged template）"></a>标签模板（tagged template）</h2><p>“标签”指的就是函数，紧跟在后面的模板字符串就是它的参数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = <span class="number">5</span>;</div><div class="line"><span class="keyword">var</span> b = <span class="number">10</span>;</div><div class="line"></div><div class="line">tag<span class="string">`Hello <span class="subst">$&#123; a + b &#125;</span> world <span class="subst">$&#123; a * b &#125;</span>`</span>;</div><div class="line"><span class="comment">// 等同于</span></div><div class="line">tag([<span class="string">'Hello '</span>, <span class="string">' world '</span>, <span class="string">''</span>], <span class="number">15</span>, <span class="number">50</span>);</div></pre></td></tr></table></figure>
<p>tag函数的第一个参数是一个数组，该数组的成员是模板字符串中<strong>那些没有变量替换的部分</strong>，也就是说，变量替换只发生在数组的第一个成员与第二个成员之间、第二个成员与第三个成员之间，以此类推。</p>
<p>标签模板的一个重要应用，就是过滤HTML字符串，防止用户输入恶意内容。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> message =</div><div class="line">  SaferHTML<span class="string">`&lt;p&gt;<span class="subst">$&#123;sender&#125;</span> has sent you a message.&lt;/p&gt;`</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">SaferHTML</span>(<span class="params">templateData</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> s = templateData[<span class="number">0</span>];</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt; <span class="built_in">arguments</span>.length; i++) &#123;</div><div class="line">    <span class="keyword">var</span> arg = <span class="built_in">String</span>(<span class="built_in">arguments</span>[i]);</div><div class="line"></div><div class="line">    <span class="comment">// Escape special characters in the substitution.</span></div><div class="line">    s += arg.replace(<span class="regexp">/&amp;/g</span>, <span class="string">"&amp;amp;"</span>)</div><div class="line">            .replace(<span class="regexp">/&lt;/g</span>, <span class="string">"&amp;lt;"</span>)</div><div class="line">            .replace(<span class="regexp">/&gt;/g</span>, <span class="string">"&amp;gt;"</span>);</div><div class="line"></div><div class="line">    <span class="comment">// Don't escape special characters in the template.</span></div><div class="line">    s += templateData[i];</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> s;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>标签模板的另一个应用，就是多语言转换（国际化处理）。</p>
<h2 id="String-raw"><a href="#String-raw" class="headerlink" title="String.raw()"></a>String.raw()</h2><p>ES6还为原生的String对象，提供了一个<code>raw</code>方法。这个方法往往用来充当模板字符串的处理函数，返回一个斜杠都被转义（即斜杠前面再加一个斜杠）的字符串，对应于替换变量后的模板字符串。</p>
<p>如果原字符串的斜杠已经转移，那么不会做任何处理。</p>
<h1 id="正则的拓展"><a href="#正则的拓展" class="headerlink" title="正则的拓展"></a>正则的拓展</h1><h2 id="y修饰符"><a href="#y修饰符" class="headerlink" title="y修饰符"></a>y修饰符</h2><p>ES6为正则表达式添加了y修饰符，叫做粘结（sticky）修饰符。</p>
<p>y修饰符的作用域g修饰符类似，也是全局匹配，后一次匹配都从上一次匹配成功的下一个位置开始。不同之处在于，y修饰符确保必须从剩余的第一个位置开始。</p>
<p>y修饰符的设计本意，就是让头部匹配的标志<code>^</code>在全局匹配中都有效。</p>
<h2 id="sticky属性"><a href="#sticky属性" class="headerlink" title="sticky属性"></a>sticky属性</h2><p>与y修饰符相匹配，ES6的正则对象多了sticky属性，表示是否设置了y修饰符。</p>
<h1 id="数值的拓展"><a href="#数值的拓展" class="headerlink" title="数值的拓展"></a>数值的拓展</h1><h2 id="Number-isFinite-Number-isNaN"><a href="#Number-isFinite-Number-isNaN" class="headerlink" title="Number.isFinite() Number.isNaN()"></a>Number.isFinite() Number.isNaN()</h2><p>这两个方法与传统的全局isFinite()和isNaN()的区别是，传统方法会先转为Number对象，然后在进行判断，所以这两个方法只对数值有效，非数值一律返回<code>false</code>。</p>
<h2 id="Number-parseInt-Number-parseFloat"><a href="#Number-parseInt-Number-parseFloat" class="headerlink" title="Number.parseInt() Number.parseFloat()"></a>Number.parseInt() Number.parseFloat()</h2><p>ES6将全局方法<code>parseInt()</code>和<code>parseFloat()</code>，移植到Number对象上，完全一致。减少全局性方法，使得语言逐步模块化。</p>
<h2 id="Number-isInteger"><a href="#Number-isInteger" class="headerlink" title="Number.isInteger()"></a>Number.isInteger()</h2><p>在JS内部，整数和浮点数都是同样的储存方法。</p>
<h2 id="Number-EPSILON"><a href="#Number-EPSILON" class="headerlink" title="Number.EPSILON"></a>Number.EPSILON</h2><p>ES6在Number对象上面，新增了一个极小的常量Number.EPSILON。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Number</span>.EPSILON</div><div class="line"><span class="comment">// 2.220446049250313e-16</span></div><div class="line"><span class="built_in">Number</span>.EPSILON.toFixed(<span class="number">20</span>)</div><div class="line"><span class="comment">// '0.00000000000000022204'</span></div></pre></td></tr></table></figure>
<p>为了浮点数的计算，设置一个误差范围。但是如果这个误差能够小于Number.EPSILON，我们就可以认为得到了正确结果。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="number">0.1</span> + <span class="number">0.2</span></div><div class="line"><span class="comment">// 0.30000000000000004</span></div><div class="line"></div><div class="line"><span class="number">0.1</span> + <span class="number">0.2</span> - <span class="number">0.3</span></div><div class="line"><span class="comment">// 5.551115123125783e-17</span></div><div class="line"></div><div class="line"><span class="number">5.551115123125783e-17</span>.toFixed(<span class="number">20</span>)</div><div class="line"><span class="comment">// '0.00000000000000005551'</span></div><div class="line"></div><div class="line"><span class="number">5.551115123125783e-17</span> &lt; <span class="built_in">Number</span>.EPSILON</div><div class="line"><span class="comment">// true</span></div></pre></td></tr></table></figure>
<p>因此，Number.EPSILON的实质是一个可以接受的误差范围。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">withinErrorMargin</span> (<span class="params">left, right</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="built_in">Math</span>.abs(left - right) &lt; <span class="built_in">Number</span>.EPSILON;</div><div class="line">&#125;</div><div class="line">withinErrorMargin(<span class="number">0.1</span> + <span class="number">0.2</span>, <span class="number">0.3</span>)</div><div class="line"><span class="comment">// true</span></div><div class="line">withinErrorMargin(<span class="number">0.2</span> + <span class="number">0.2</span>, <span class="number">0.3</span>)</div><div class="line"><span class="comment">// false</span></div></pre></td></tr></table></figure>
<h2 id="安全整数和Number-isSafeInteger"><a href="#安全整数和Number-isSafeInteger" class="headerlink" title="安全整数和Number.isSafeInteger()"></a>安全整数和Number.isSafeInteger()</h2><p>JavaScript能够准确表示的整数范围在-2^53到2^53之间（不含两个端点），超过这个范围，无法精确表示这个值。</p>
<p>ES6引入了Number.MAX_SAFE_INTEGER和Number.MIN_SAFE_INTEGER这两个常量，用来表示这个范围的上下限。</p>
<p>Number.isSafeInteger()则是用来判断一个整数是否落在这个范围之内。</p>
<h2 id="Math对象的拓展"><a href="#Math对象的拓展" class="headerlink" title="Math对象的拓展"></a>Math对象的拓展</h2><ol>
<li><p>Math.trunc() 去除一个数的小数部分，返回整数部分。</p>
</li>
<li><p>Math.sign() 用来判断一个数是正数负数还是0。</p>
</li>
<li><p>Math.cbrt() 计算一个数的立方根</p>
</li>
<li><p>Math.clz32() JavaScript的整数使用32位二进制形式表示，该方法返回一个数的32位无符号整数形式有多少个前导0。</p>
</li>
<li><p>Math.imul() 返回两个数以32位带符号整数形式相乘的结果，返回的也是一个32位的带符号整数。</p>
</li>
</ol>
<p>因为JavaScript有精度限制，超过2的53次方的值无法精确表示。对于那些很大的数的乘法，低位数值往往都是不精确的，<code>Math.imul</code>方法可以返回正确的低位数值。</p>
<ol>
<li>Math.fround() 返回一个数的单精度浮点数形式。</li>
</ol>
<p>对于整数来说，Math.fround方法返回结果不会有任何不同，区别主要是那些无法用64个二进制位精确表示的小数。这时，Math.fround方法会返回最接近这个小数的单精度浮点数。</p>
<p>…</p>
<h1 id="函数的拓展"><a href="#函数的拓展" class="headerlink" title="函数的拓展"></a>函数的拓展</h1><h2 id="参数默认值的位置"><a href="#参数默认值的位置" class="headerlink" title="参数默认值的位置"></a>参数默认值的位置</h2><p>通常情况下，定义了默认值的参数，应该是函数的尾参数。因为这样比较容易看出到底省略了哪些参数。如果非尾部的参数设置默认值，实际上这个参数是没法省略的。会报错。除非显式地输入<code>undefined</code>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 例一</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x = 1, y</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> [x, y];</div><div class="line">&#125;</div><div class="line"></div><div class="line">f() <span class="comment">// [1, undefined]</span></div><div class="line">f(<span class="number">2</span>) <span class="comment">// [2, undefined])</span></div><div class="line">f(, <span class="number">1</span>) <span class="comment">// 报错</span></div><div class="line">f(<span class="literal">undefined</span>, <span class="number">1</span>) <span class="comment">// [1, 1]</span></div><div class="line"></div><div class="line"><span class="comment">// 例二</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x, y = 5, z</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> [x, y, z];</div><div class="line">&#125;</div><div class="line"></div><div class="line">f() <span class="comment">// [undefined, 5, undefined]</span></div><div class="line">f(<span class="number">1</span>) <span class="comment">// [1, 5, undefined]</span></div><div class="line">f(<span class="number">1</span>, ,<span class="number">2</span>) <span class="comment">// 报错</span></div><div class="line">f(<span class="number">1</span>, <span class="literal">undefined</span>, <span class="number">2</span>) <span class="comment">// [1, 5, 2]</span></div></pre></td></tr></table></figure>
<h2 id="函数的length属性"><a href="#函数的length属性" class="headerlink" title="函数的length属性"></a>函数的length属性</h2><p>指定了默认值以后，函数的<code>length</code>属性，将返回没有指定默认值的参数个数。</p>
<p>如果设置了默认值的参数不是尾参数，那么<code>length</code>属性也不再计入后面的参数了。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">a = 0, b, c</span>) </span>&#123;&#125;).length <span class="comment">// 0</span></div><div class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">a, b = 1, c</span>) </span>&#123;&#125;).length <span class="comment">// 1</span></div></pre></td></tr></table></figure>
<h2 id="rest参数"><a href="#rest参数" class="headerlink" title="rest参数"></a>rest参数</h2><p>ES6引入rest参数（…变量名），用于获取函数的多余参数，这样就不需要使用arguments对象了。rest参数搭配的变量是一个数组，该变量将多余的参数放入数组中。</p>
<p>注意，rest参数之后不能再有其他参数，否则会报错。</p>
<p>函数的<code>length</code>属性，不包括rest参数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">(function(a) &#123;&#125;).length  // 1</div><div class="line">(function(...a) &#123;&#125;).length  // 0</div><div class="line">(function(a, ...b) &#123;&#125;).length  // 1</div></pre></td></tr></table></figure>
<h2 id="拓展运算符"><a href="#拓展运算符" class="headerlink" title="拓展运算符"></a>拓展运算符</h2><p>拓展运算符（spread）是三个点<code>...</code>，好比是rest参数的逆运算，将一个不数组转为用逗号分隔的参数序列。</p>
<h2 id="箭头函数的使用注意点"><a href="#箭头函数的使用注意点" class="headerlink" title="箭头函数的使用注意点"></a>箭头函数的使用注意点</h2><p>箭头函数有几个使用注意点。</p>
<p>（1）函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。</p>
<pre><code>this对象的指向是可变的，但是在箭头函数中，它是固定的。
</code></pre><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  setTimeout(() =&gt; &#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'id:'</span>, <span class="keyword">this</span>.id);</div><div class="line">  &#125;, <span class="number">100</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> id = <span class="number">21</span>;</div><div class="line"></div><div class="line">foo.call(&#123; id: <span class="number">42</span> &#125;);</div><div class="line"><span class="comment">// id: 42</span></div></pre></td></tr></table></figure>
<p><code>this</code>指向的固定化，实际上是因为箭头函数根本没有自己的<code>this</code>，导致内部的<code>this</code>就是外层代码块的<code>this</code>。正因为它没有<code>this</code>，所以也就不能用作构造函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// ES6</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  setTimeout(() =&gt; &#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'id:'</span>, <span class="keyword">this</span>.id);</div><div class="line">  &#125;, <span class="number">100</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// ES5</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> _this = <span class="keyword">this</span>;</div><div class="line"></div><div class="line">  setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'id:'</span>, _this.id);</div><div class="line">  &#125;, <span class="number">100</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>（2）不可以当作构造函数，也就是说，不可以使用new命令，否则会抛出一个错误。</p>
<p>（3）不可以使用arguments对象，该对象在函数体内不存在。如果要用，可以用Rest参数代替。</p>
<p>（4）不可以使用yield命令，因此箭头函数不能用作Generator函数。</p>
<h2 id="尾调用（Tail-Call）优化"><a href="#尾调用（Tail-Call）优化" class="headerlink" title="尾调用（Tail Call）优化"></a>尾调用（Tail Call）优化</h2><p>指的是在某个函数的最后一步是完全调用另一个函数，并且尾调用不会用到外层函数的变量。由于是函数的最后一步操作，所以不需要保留外层函数的调用帧，因为调用位置、内部变量等信息都不会再用到了，只要直接用内层函数的调用帧来取代外层函数的调用帧就行了。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">let</span> m = <span class="number">1</span>;</div><div class="line">  <span class="keyword">let</span> n = <span class="number">2</span>;</div><div class="line">  <span class="keyword">return</span> g(m + n);</div><div class="line">&#125;</div><div class="line">f();</div><div class="line"></div><div class="line"><span class="comment">// 等同于</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> g(<span class="number">3</span>);</div><div class="line">&#125;</div><div class="line">f();</div><div class="line"></div><div class="line"><span class="comment">// 等同于</span></div><div class="line">g(<span class="number">3</span>);</div></pre></td></tr></table></figure>
<h2 id="尾递归"><a href="#尾递归" class="headerlink" title="尾递归"></a>尾递归</h2><p>递归非常耗费内存，因为需要同时保存省钱上百个调用帧，很容易发生“栈溢出”错误。但对于尾递归来说，由于只存在一个调用帧，所以永远不会发生“栈溢出”的错误。</p>
<p>ES6第一次明确规定，所有ECMAScript的实现都必须部署尾递归优化。只要在ES6中使用尾递归，就不会发生栈溢出，相对节省内存。</p>
<h1 id="对象的拓展"><a href="#对象的拓展" class="headerlink" title="对象的拓展"></a>对象的拓展</h1><p>属性可以用简洁的表示法，属性名还可以用表达式。</p>
<h2 id="Object-is"><a href="#Object-is" class="headerlink" title="Object.is()"></a>Object.is()</h2><p>ES6提出<code>Same-value equality</code>同值相等算法，用来解决<code>==</code>自动转换数值类型和<code>===</code>NaN不等于自身，以及+0等于-0的缺点。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Object</span>.is(+<span class="number">0</span>, <span class="number">-0</span>) <span class="comment">// false</span></div><div class="line"><span class="built_in">Object</span>.is(<span class="literal">NaN</span>, <span class="literal">NaN</span>) <span class="comment">// true</span></div></pre></td></tr></table></figure>
<h2 id="Object-assign"><a href="#Object-assign" class="headerlink" title="Object.assign()"></a>Object.assign()</h2><p>该方法实行的是浅拷贝。只能拷贝属性的值，所以只能是拷贝简单类型。</p>
<p>对于嵌套的对象，Object.assign会直接替换掉同名属性。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> target = &#123; a: &#123; b: <span class="string">'c'</span>, d: <span class="string">'e'</span> &#125; &#125;</div><div class="line"><span class="keyword">var</span> source = &#123; a: &#123; b: <span class="string">'hello'</span> &#125; &#125;</div><div class="line"><span class="built_in">Object</span>.assign(target, source)</div><div class="line"><span class="comment">// &#123; a: &#123; b: 'hello' &#125; &#125;</span></div></pre></td></tr></table></figure>
<p>该方法可以用来处理数组，但会把数组视为对象。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Object</span>.assign([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>])</div><div class="line"><span class="comment">// [4, 5, 3]</span></div></pre></td></tr></table></figure>
<p>该方法将数组视为属性名为0、1、2的对象，因此在对应的位置上直接进行了替换。</p>
<p>该方法拷贝的属性也是有限制的，只拷贝原对象的自身属性（不拷贝继承属性），也不拷贝不可枚举的属性。</p>
<h2 id="Object-getOwnPropertyDescriptors"><a href="#Object-getOwnPropertyDescriptors" class="headerlink" title="Object.getOwnPropertyDescriptors()"></a>Object.getOwnPropertyDescriptors()</h2><p>ES7的提案，提出这个方法，返回指定对象所有的自身属性（非继承属性）的描述对象。</p>
<p>这个方法主要是为了解决<code>Object.assign</code>无法正确拷贝get和set属性的问题，也就是它本身只能浅拷贝，拷贝到相应的值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> shallowMerge = (target, source) =&gt; <span class="built_in">Object</span>.defineProperties(</div><div class="line">  target,</div><div class="line">  <span class="built_in">Object</span>.getOwnPropertyDescriptors(source)</div><div class="line">);</div></pre></td></tr></table></figure>
<h1 id="Symbol"><a href="#Symbol" class="headerlink" title="Symbol"></a>Symbol</h1><p>ES6引入了一种新的原始数据类型Symbol，表示独一无二的值。Symbol值通过<code>Symbol</code>函数生成，现在对象的属性名可以是两种类型，一种是原来就有的字符串，另一种就是新增的Symbol类型。凡是属性名属于Symbol类型都是独一无二的，不会与其他属性名发生冲突。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 没有参数的情况</span></div><div class="line"><span class="keyword">var</span> s1 = <span class="built_in">Symbol</span>();</div><div class="line"><span class="keyword">var</span> s2 = <span class="built_in">Symbol</span>();</div><div class="line"></div><div class="line">s1 === s2 <span class="comment">// false</span></div><div class="line"></div><div class="line"><span class="comment">// 有参数的情况</span></div><div class="line"><span class="keyword">var</span> s1 = <span class="built_in">Symbol</span>(<span class="string">"foo"</span>);</div><div class="line"><span class="keyword">var</span> s2 = <span class="built_in">Symbol</span>(<span class="string">"foo"</span>);</div><div class="line"></div><div class="line">s1 === s2 <span class="comment">// false</span></div></pre></td></tr></table></figure>
<p>Symbol值不能与其他类型的值进行运算，可以显式地转换为字符串，可以转换为布尔值，但是不能转换为数值。</p>
<h2 id="作为属性名的Symbol"><a href="#作为属性名的Symbol" class="headerlink" title="作为属性名的Symbol"></a>作为属性名的Symbol</h2><p>Symbol值作为对象属性名时不能用点运算符。因为点运算符后面总是字符串，所以不能读取到Symbol作为标识所指代的值，所以实际指向了那个字符串对应的属性。</p>
<p>同理，在对象内部，使用Symbol值定义属性时，也必须放在<code>[]</code>之中。</p>
<h2 id="魔术字符串"><a href="#魔术字符串" class="headerlink" title="魔术字符串"></a>魔术字符串</h2><p>魔术字符串指的是，在代码之中多次出现、与代码形成强耦合的某一个具体的字符串或者数值。风格良好的代码，应该尽量消除魔术字符串，该由含义清晰的变量代替。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> shapeType = &#123;</div><div class="line">  triangle: <span class="string">'Triangle'</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getArea</span>(<span class="params">shape, options</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> area = <span class="number">0</span>;</div><div class="line">  <span class="keyword">switch</span> (shape) &#123;</div><div class="line">    <span class="keyword">case</span> shapeType.triangle:</div><div class="line">      area = <span class="number">.5</span> * options.width * options.height;</div><div class="line">      <span class="keyword">break</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> area;</div><div class="line">&#125;</div><div class="line"></div><div class="line">getArea(shapeType.triangle, &#123; width: <span class="number">100</span>, height: <span class="number">100</span> &#125;);</div></pre></td></tr></table></figure>
<p>如果仔细分析，可以发现shapeType.triangle等于哪个值并不重要，只要确保不会跟其他shapeType属性的值冲突即可。因此，这里就很适合改用Symbol值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> shapeType = &#123;</div><div class="line">  triangle: <span class="built_in">Symbol</span>()</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>Symbol属性一般不会被遍历循环所取到，但用Object.getOwnPropertySymbols()会返回，<code>Reflect.ownKeys</code>方法也可以返回所有类型的键名。</p>
<p>由于以Symbol值作为名称的属性，不会被常规方法遍历得到，可以利用这个特性，为对象定义一些非私有的、但是又只希望用于内部的方法。</p>
<p>Symbol本身是一个公开的值。</p>
<p>Symbol.for方法会在在全局登记一个Symbol类型的key，然后会先查找对应的key，如果没有再创建一个新的，如果有则返回；Symbol.forKey则直接查找，如果没有返回undefined。</p>
<p>注意，Symbol.for为Symbol值登记的名字是全局环境的，可以在不同的iframe或者service worker中取到同一个值。</p>
<p>可以用来实现单例模式。</p>
<h1 id="Proxy和Reflect"><a href="#Proxy和Reflect" class="headerlink" title="Proxy和Reflect"></a>Proxy和Reflect</h1><h2 id="Proxy"><a href="#Proxy" class="headerlink" title="Proxy"></a>Proxy</h2><p>Proxy用于修改某些操作的默认行为，等同于在语言层面做出修改，所以属于一种“元编程”（meta programming），即对编程语言进行编程。</p>
<h1 id="二进制数组"><a href="#二进制数组" class="headerlink" title="二进制数组"></a>二进制数组</h1><p><code>ArrayBuffer</code>对象代表原始的二进制数据，<code>TypedArray</code>视图用来读写简单类型的二进制数据，<code>DataView</code>视图用来读写复杂类型的二进制数据。</p>
<p>二进制数组并不是真正的数组，而是类似数组的对象。</p>
<p>这个接口的原始设计目的，与WebGL有关，浏览器与显卡之间的通信接口，为了满足js与显卡之间大量实时的数据交换，他们之间的数据通信必须是二进制的，而不是能传统的文本格式。</p>
<p>很多浏览器的API也用到了二进制数组：</p>
<ul>
<li><p>File API</p>
</li>
<li><p>XMLHttpRequest</p>
</li>
<li><p>Fetch API</p>
</li>
<li><p>Canvas</p>
</li>
<li><p>WebSockets</p>
</li>
</ul>
<p>ArrayBuffer对象代表储存二进制数据的一段内存，不能直接读写，只能通过视图来读写。</p>
<p>视图的作用就是以指定的格式来解读二进制数据。</p>
<p>视图很像普通的数组，所有数组能用的方法都能在视图上面进行使用。</p>
<p>TypedArray视图无法正确解析大端字节序，DataView可以。</p>
<p>DataView视图提供更多操作选项，而且支持设定字节序。本来，在设计目的上，ArrayBuffer对象的各种TypedArray视图，是用来向网卡、声卡之类的本机设备传送数据，所以使用本机的字节序就可以了；而DataView视图的设计目的，是用来处理网络设备传来的数据，所以大端字节序或小端字节序是可以自行设定的。</p>
<p>如果一次读取两个或两个以上字节，就必须明确数据的存储方式，到底是小端字节序还是大端字节序。默认情况下，DataView的get方法使用大端字节序解读数据，如果需要使用小端字节序解读，必须在get方法的第二个参数指定true。</p>
<h1 id="Set和Map数据结构"><a href="#Set和Map数据结构" class="headerlink" title="Set和Map数据结构"></a>Set和Map数据结构</h1><h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><p>Set类似于数组，但是区别是Set成员的值都是唯一的，没有重复的值。</p>
<p>这就提供了一种数组去重的方法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">dedupe</span>(<span class="params">array</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="built_in">Array</span>.from(<span class="keyword">new</span> <span class="built_in">Set</span>(array));</div><div class="line">&#125;</div><div class="line"></div><div class="line">dedupe([<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]) <span class="comment">// [1, 2, 3]</span></div></pre></td></tr></table></figure>
<p>向Set加入值的时候，不会发生类型转换。Set内部判断两个值是否不同，使用的算法是<code>Same-value equality</code>。</p>
<p>在Set内部，两个NaN是相等的，两对象总是不相等的。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>();</div><div class="line"></div><div class="line">set.add(&#123;&#125;);</div><div class="line">set.size <span class="comment">// 1</span></div><div class="line"></div><div class="line">set.add(&#123;&#125;);</div><div class="line">set.size <span class="comment">// 2</span></div></pre></td></tr></table></figure></p>
<p>Set的遍历顺序就是插入顺序。</p>
<h2 id="WeakSet"><a href="#WeakSet" class="headerlink" title="WeakSet"></a>WeakSet</h2><p>WeakSet与Set的区别是，前者的成员只能是对象。其次，他的对象都是弱引用，即垃圾回收机制不考虑WeakSet对该对象的引用，也就是说如果其他对象都不再引用该对象，那么垃圾回收机制会自动回收该对象所占用的内存。这意味着无法引用WeakSet的成员，因此它是不可遍历的。</p>
<p>因为成员是弱引用，随时可能消失，所以遍历机制无法保证成员的存在，所以不可遍历。</p>
<p>WeakSet的一个用处，是储存DOM节点，而不用担心这些节点从文档中移除时，会引发内存泄漏。</p>
<h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><p>JavaScript的对象Object，本质上是键值对的集合（Hash结构），但是传统上只能用字符串当做键。这给它的使用带来了很大的限制。</p>
<p>Map的出现就是为了解决这个问题，它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当做键。也就是说，Object结构提供了字符串到值的对应，Map结构提供了值到值的对应。是一种更完善的Hash结构实现。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>([</div><div class="line">  [<span class="literal">true</span>, <span class="string">'foo'</span>],</div><div class="line">  [<span class="string">'true'</span>, <span class="string">'bar'</span>]</div><div class="line">]);</div><div class="line"></div><div class="line">m.get(<span class="literal">true</span>) <span class="comment">// 'foo'</span></div><div class="line">m.get(<span class="string">'true'</span>) <span class="comment">// 'bar'</span></div></pre></td></tr></table></figure>
<p>注意，只有对同一个对象的引用，Map结构才将其视为同一个键。这一点要非常小心。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</div><div class="line"></div><div class="line">map.set([<span class="string">'a'</span>], <span class="number">555</span>);</div><div class="line">map.get([<span class="string">'a'</span>]) <span class="comment">// undefined</span></div></pre></td></tr></table></figure>
<p>同理，同样的值的两个实例，在Map结构中被视为两个键。</p>
<p>Map的键实际上是跟内存地址绑定的，只要内存地址不一样就视为两个键。这就解决了同名属性碰撞clash的问题，我们扩展别人的库时，如果使用对象作为键名就不用担心自己的属性便于原作者的属性同名。</p>
<p>如果Map的键是一个简单类型的值（数字、字符串、布尔值），则只要两个值严格相等，Map将其视为一个键，包括0和-0。另外，虽然NaN不严格相等于自身，但Map将其视为同一个键。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</div><div class="line"></div><div class="line">map.set(<span class="literal">NaN</span>, <span class="number">123</span>);</div><div class="line">map.get(<span class="literal">NaN</span>) <span class="comment">// 123</span></div><div class="line"></div><div class="line">map.set(<span class="number">-0</span>, <span class="number">123</span>);</div><div class="line">map.get(+<span class="number">0</span>) <span class="comment">// 123</span></div></pre></td></tr></table></figure>
<p>注意，Map的遍历顺序就是插入顺序。</p>
<p>WeakMap也是只接受对象作为键名（null除外），而且键名所指向的对象，不计入垃圾回收机制。</p>
<h1 id="Iterator和for…of循环"><a href="#Iterator和for…of循环" class="headerlink" title="Iterator和for…of循环"></a>Iterator和for…of循环</h1><h2 id="Iterator遍历器"><a href="#Iterator遍历器" class="headerlink" title="Iterator遍历器"></a>Iterator遍历器</h2><p>JS中表示集合的数据结构主要是数组和对象，ES6又添加了Map和Set。这样就需要一种统一的接口机制，来处理所有不同的数据结果。</p>
<p>Iterator就是这样一种机制。它是一种接口，为各种不同的数据结构提供统一的访问机制。任何数据结构只要部署Iterator接口，就可以完成遍历操作。</p>
<p>Iterator的作用有三个：一是为各种数据结构，提供一个统一的、简便的访问接口；二是使得数据结构的成员能够按某种次序排列；三是ES6创造了一种新的遍历命令for…of循环，Iterator接口主要供for…of消费。</p>
<p>Iterator的遍历过程是这样的。</p>
<p>（1）创建一个指针对象，指向当前数据结构的起始位置。也就是说，遍历器对象本质上，就是一个指针对象。</p>
<p>（2）第一次调用指针对象的next方法，可以将指针指向数据结构的第一个成员。</p>
<p>（3）第二次调用指针对象的next方法，指针就指向数据结构的第二个成员。</p>
<p>（4）不断调用指针对象的next方法，直到它指向数据结构的结束位置。</p>
<p>每一次调用next方法，都会返回数据结构的当前成员的信息。具体来说，就是返回一个包含value和done两个属性的对象。其中，value属性是当前成员的值，done属性是一个布尔值，表示遍历是否结束。</p>
<p>当使用for…of循环遍历某种数据结构时，该循环会自动去寻找Iterator接口。</p>
<p>ES6规定，默认的Iterator接口部署在数据结构的Symbol.iterator属性，或者说，一个数据结构只要具有Symbol.iterator属性，就可以认为是可遍历的。</p>
<p>在ES6中，有三类数据结构原生具备Iterator接口：数组、某些类似数组的对象、Set和Map结构。</p>
<p>本质上，遍历器是一种线性处理，对于任何非线性的数据结构，部署遍历器接口，就等于部署一种线性转换。</p>
<p>通过遍历器实现指针结构：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Obj</span>(<span class="params">value</span>) </span>&#123;</div><div class="line">  <span class="keyword">this</span>.value = value;</div><div class="line">  <span class="keyword">this</span>.next = <span class="literal">null</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Obj.prototype[<span class="built_in">Symbol</span>.iterator] = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> iterator = &#123;</div><div class="line">    next: next</div><div class="line">  &#125;;</div><div class="line"></div><div class="line">  <span class="keyword">var</span> current = <span class="keyword">this</span>;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">next</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (current) &#123;</div><div class="line">      <span class="keyword">var</span> value = current.value;</div><div class="line">      current = current.next;</div><div class="line">      <span class="keyword">return</span> &#123;</div><div class="line">        done: <span class="literal">false</span>,</div><div class="line">        value: value</div><div class="line">      &#125;;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      <span class="keyword">return</span> &#123;</div><div class="line">        done: <span class="literal">true</span></div><div class="line">      &#125;;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> iterator;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> one = <span class="keyword">new</span> Obj(<span class="number">1</span>);</div><div class="line"><span class="keyword">var</span> two = <span class="keyword">new</span> Obj(<span class="number">2</span>);</div><div class="line"><span class="keyword">var</span> three = <span class="keyword">new</span> Obj(<span class="number">3</span>);</div><div class="line"></div><div class="line">one.next = two;</div><div class="line">two.next = three;</div><div class="line"></div><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">of</span> one)&#123;</div><div class="line">  <span class="built_in">console</span>.log(i);</div><div class="line">&#125;</div><div class="line"><span class="comment">// 1</span></div><div class="line"><span class="comment">// 2</span></div><div class="line"><span class="comment">// 3</span></div></pre></td></tr></table></figure>
<h1 id="Generator"><a href="#Generator" class="headerlink" title="Generator"></a>Generator</h1><p>Generator函数是ES6提供的一种异步编程解决方案，语法行为与传统函数完全不同。</p>
<ol>
<li><p>它是一个状态机，封装了多个内部状态。</p>
</li>
<li><p>一个遍历器对象生成函数，返回的遍历器对象，可以依次遍历Generator函数内部的每一个状态。</p>
</li>
</ol>
<p>调用Genterator函数后，该函数并不执行，返回的也不是函数运行结果，而是一个指向内部状态的指针对象，也就是一个遍历器对象。</p>
<p>下一步，必须调用遍历器对象的next方法，使得指针移向下一个状态。也就是说，每次调用next方法，内部指针就从函数头部或上一次停下来的地方开始执行，直到遇到下一个yield或者return语句。</p>
<p>也就是说，Generator函数是分段执行的，yield语句是暂停执行的标记，而next是恢复执行。</p>
<p>Genterator函数也可以不用tield语句，这时就变成了一个单纯的暂缓执行函数。</p>
<p>另外yield语句不能用在普通函数中，否则会报错。</p>
<h2 id="与Iterator接口的关系"><a href="#与Iterator接口的关系" class="headerlink" title="与Iterator接口的关系"></a>与Iterator接口的关系</h2><p>任意一个对象的<code>Symbol.iterator</code>方法，等于该对象的遍历器生成函数，调用该函数会返回该对象的一个遍历器对象。</p>
<p>把Generator函数赋值给对象的<code>Symbol.iterator</code>属性，就可以让对象具有Iterator接口。</p>
<h2 id="next方法的参数"><a href="#next方法的参数" class="headerlink" title="next方法的参数"></a>next方法的参数</h2><p>yield语句本身没有返回值，或者说总是返回undefined。next方法可以带一个参数，该参数就会被当做上一个yield语句的返回值。</p>
<h2 id="for…of循环"><a href="#for…of循环" class="headerlink" title="for…of循环"></a>for…of循环</h2><p>该循环可以自动遍历Generator函数生成的Iterator对象，且此时不再需要调用next方法。</p>
<p>需要注意的是，一旦next方法的返回对象的done属性为true，for…of循环就会终止，且不包含该返回对象，所以return语句返回的6，不会包括在for…of循环之中。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> *<span class="title">foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">yield</span> <span class="number">1</span>;</div><div class="line">  <span class="keyword">yield</span> <span class="number">2</span>;</div><div class="line">  <span class="keyword">yield</span> <span class="number">3</span>;</div><div class="line">  <span class="keyword">yield</span> <span class="number">4</span>;</div><div class="line">  <span class="keyword">yield</span> <span class="number">5</span>;</div><div class="line">  <span class="keyword">return</span> <span class="number">6</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">for</span> (<span class="keyword">let</span> v <span class="keyword">of</span> foo()) &#123;</div><div class="line">  <span class="built_in">console</span>.log(v);</div><div class="line">&#125;</div><div class="line"><span class="comment">// 1 2 3 4 5</span></div></pre></td></tr></table></figure>
<h2 id="Generator-prototype-throw"><a href="#Generator-prototype-throw" class="headerlink" title="Generator.prototype.throw"></a>Generator.prototype.throw</h2><p>Generator函数返回的遍历器对象，都有一个throw方法，可以在函数体外抛出错误，然后在函数体内捕获。需要在函数内部部署try…catch。</p>
<p>另外，throw方法被捕获以后，会附带执行下一条yield语句。也就是说，会附带执行一次next方法。</p>
<p>另外，外部的throw命令与生成器函数的throw方法是无关的，两者互不影响。也就是说，throw命令抛出的错误不会影响到遍历器的状态。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> gen = <span class="function"><span class="keyword">function</span>* <span class="title">gen</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="keyword">yield</span> <span class="built_in">console</span>.log(<span class="string">'hello'</span>);</div><div class="line">  <span class="keyword">yield</span> <span class="built_in">console</span>.log(<span class="string">'world'</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> g = gen();</div><div class="line">g.next();</div><div class="line"></div><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>();</div><div class="line">&#125; <span class="keyword">catch</span> (e) &#123;</div><div class="line">  g.next();</div><div class="line">&#125;</div><div class="line"><span class="comment">// hello</span></div><div class="line"><span class="comment">// world</span></div></pre></td></tr></table></figure>
<p>只要Generator函数内部部署了try…catch代码块，那么遍历器的throw方法抛出的错误，不影响下一次遍历。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> gen = <span class="function"><span class="keyword">function</span>* <span class="title">gen</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="keyword">try</span> &#123;</div><div class="line">    <span class="keyword">yield</span> <span class="built_in">console</span>.log(<span class="string">'a'</span>);</div><div class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</div><div class="line">    <span class="comment">// ...</span></div><div class="line">  &#125;</div><div class="line">  <span class="keyword">yield</span> <span class="built_in">console</span>.log(<span class="string">'b'</span>);</div><div class="line">  <span class="keyword">yield</span> <span class="built_in">console</span>.log(<span class="string">'c'</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> g = gen();</div><div class="line">g.next() <span class="comment">// a</span></div><div class="line">g.throw() <span class="comment">// b</span></div><div class="line">g.next() <span class="comment">// c</span></div></pre></td></tr></table></figure>
<p>Generator函数体外抛出的错误，可以在函数体内捕获；反过来，Generator函数体内抛出的错误，也可以被函数体外的catch捕获。</p>
<p>一旦Generator执行过程中抛出错误，且没有被内部捕获，就不会再执行下去了。如果此后还调用next方法，将返回一个value属性等于undefined、done属性等于true的对象，即JavaScript引擎认为这个Generator已经运行结束了。</p>
<h2 id="yield-语句"><a href="#yield-语句" class="headerlink" title="yield* 语句"></a>yield* 语句</h2><p>如果在Generator函数内部，调用另一个Generator函数，默认情况下是没有效果的。</p>
<p>yield*语句的作用，就是用来在一个Generator函数里面执行另一个Generator函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span>* <span class="title">inner</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">yield</span> <span class="string">'hello!'</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span>* <span class="title">outer1</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">yield</span> <span class="string">'open'</span>;</div><div class="line">  <span class="keyword">yield</span> inner();</div><div class="line">  <span class="keyword">yield</span> <span class="string">'close'</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> gen = outer1()</div><div class="line">gen.next().value <span class="comment">// "open"</span></div><div class="line">gen.next().value <span class="comment">// 返回一个遍历器对象</span></div><div class="line">gen.next().value <span class="comment">// "close"</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span>* <span class="title">outer2</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">yield</span> <span class="string">'open'</span></div><div class="line">  <span class="keyword">yield</span>* inner()</div><div class="line">  <span class="keyword">yield</span> <span class="string">'close'</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> gen = outer2()</div><div class="line">gen.next().value <span class="comment">// "open"</span></div><div class="line">gen.next().value <span class="comment">// "hello!"</span></div><div class="line">gen.next().value <span class="comment">// "close"</span></div></pre></td></tr></table></figure>
<p>实际上，任何数据结构只要有Iterator接口，就可以被yield*遍历。</p>
<h2 id="Generator与状态机"><a href="#Generator与状态机" class="headerlink" title="Generator与状态机"></a>Generator与状态机</h2><p>Generator是实现状态机的最佳结构。</p>
<p>Generator本身就包含了一个状态信息，即目前是否处于暂停态，所以不用外部变量保存状态。</p>
<h2 id="Generator与协程-coroutine"><a href="#Generator与协程-coroutine" class="headerlink" title="Generator与协程(coroutine)"></a>Generator与协程(coroutine)</h2><p>协程既可以用单线程实现，也可以用多线程来实现。区别是协程只有一个是运行状态，对于单线程是只有一个栈是运行状态，对于多线程是只有一个线程在执行，其他协程都处于暂停状态。</p>
<p>Generator函数被称为半协程semi-coroutine。意思是只有Generator函数的调用者，才能将函数的执行权还给他。如果是完全执行的，那么任何函数都可以让暂停的协程继续执行。</p>
<h2 id="Promise对象"><a href="#Promise对象" class="headerlink" title="Promise对象"></a>Promise对象</h2><p>Promise对象有以下两个特点。</p>
<p>（1）对象的状态不受外界影响。Promise对象代表一个异步操作，有三种状态：Pending（进行中）、Resolved（已完成，又称Fulfilled）和Rejected（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。这也是Promise这个名字的由来，它的英语意思就是“承诺”，表示其他手段无法改变。</p>
<p>（2）一旦状态改变，就不会再变，任何时候都可以得到这个结果。Promise对象的状态改变，只有两种可能：从Pending变为Resolved和从Pending变为Rejected。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果。就算改变已经发生了，你再对Promise对象添加回调函数，也会立即得到这个结果。这与事件（Event）完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的。</p>
<p>使用Promise对象实现一个AJAX：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">var getJSON = function(url) &#123;</div><div class="line">  var promise = new Promise(function(resolve, reject)&#123;</div><div class="line">    var client = new XMLHttpRequest();</div><div class="line">    client.open(&quot;GET&quot;, url);</div><div class="line">    client.onreadystatechange = handler;</div><div class="line">    client.responseType = &quot;json&quot;;</div><div class="line">    client.setRequestHeader(&quot;Accept&quot;, &quot;application/json&quot;);</div><div class="line">    client.send();</div><div class="line"></div><div class="line">    function handler() &#123;</div><div class="line">      if (this.readyState !== 4) &#123;</div><div class="line">        return;</div><div class="line">      &#125;</div><div class="line">      if (this.status === 200) &#123;</div><div class="line">        resolve(this.response);</div><div class="line">      &#125; else &#123;</div><div class="line">        reject(new Error(this.statusText));</div><div class="line">      &#125;</div><div class="line">    &#125;;</div><div class="line">  &#125;);</div><div class="line"></div><div class="line">  return promise;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">getJSON(&quot;/posts.json&quot;).then(function(json) &#123;</div><div class="line">  console.log(&apos;Contents: &apos; + json);</div><div class="line">&#125;, function(error) &#123;</div><div class="line">  console.error(&apos;出错了&apos;, error);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">promise.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</div><div class="line">  <span class="comment">// success</span></div><div class="line">&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</div><div class="line">  <span class="comment">// failure</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h2 id="Promise-prototype-then"><a href="#Promise-prototype-then" class="headerlink" title="Promise.prototype.then()"></a>Promise.prototype.then()</h2><p>then方法返回的是一个新的Promise实例（注意，不是原来那个Promise实例）。因此可以采用链式写法，即then方法后面再调用另一个then方法。</p>
<h2 id="Promise-prototype-catch"><a href="#Promise-prototype-catch" class="headerlink" title="Promise.prototype.catch()"></a>Promise.prototype.catch()</h2><p>Promise.prototype.catch方法是.then(null, rejection)的别名，用于指定发生错误时的回调函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">p.then((val) =&gt; <span class="built_in">console</span>.log(<span class="string">"fulfilled:"</span>, val))</div><div class="line">  .catch((err) =&gt; <span class="built_in">console</span>.log(<span class="string">"rejected:"</span>, err));</div><div class="line"></div><div class="line"><span class="comment">// 等同于</span></div><div class="line">p.then((val) =&gt; <span class="built_in">console</span>.log(<span class="string">"fulfilled:"</span>, val))</div><div class="line">  .then(<span class="literal">null</span>, (err) =&gt; <span class="built_in">console</span>.log(<span class="string">"rejected:"</span>, err));</div></pre></td></tr></table></figure>
<p>Promise对象的错误具有冒泡的性质，会一直向后传递，直到被捕获为止。</p>
<h2 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all()"></a>Promise.all()</h2><p>Promise.all方法的参数可以不是数组，但必须具有Iterator接口，且返回的每个成员都是Promise实例。</p>
<p>（1）只有p1、p2、p3的状态都变成fulfilled，p的状态才会变成fulfilled，此时p1、p2、p3的返回值组成一个数组，传递给p的回调函数。</p>
<p>（2）只要p1、p2、p3之中有一个被rejected，p的状态就变成rejected，此时第一个被reject的实例的返回值，会传递给p的回调函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 生成一个Promise对象的数组</span></div><div class="line"><span class="keyword">var</span> promises = [<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>].map(<span class="function"><span class="keyword">function</span> (<span class="params">id</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> getJSON(<span class="string">"/post/"</span> + id + <span class="string">".json"</span>);</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="built_in">Promise</span>.all(promises).then(<span class="function"><span class="keyword">function</span> (<span class="params">posts</span>) </span>&#123;</div><div class="line">  <span class="comment">// ...</span></div><div class="line">&#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params">reason</span>)</span>&#123;</div><div class="line">  <span class="comment">// ...</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h2 id="Promise-race"><a href="#Promise-race" class="headerlink" title="Promise.race()"></a>Promise.race()</h2><p>只要p1、p2、p3之中有一个实例率先改变状态，p的状态就跟着改变。那个率先改变的Promise实例的返回值，就传递给p的回调函数。</p>
<h1 id="异步操作和Async函数"><a href="#异步操作和Async函数" class="headerlink" title="异步操作和Async函数"></a>异步操作和Async函数</h1><p>ES6诞生以前，异步编程主要的方法：</p>
<ul>
<li><p>回调函数</p>
</li>
<li><p>事件监听</p>
</li>
<li><p>发布/订阅</p>
</li>
<li><p>Promise对象</p>
</li>
</ul>
<h2 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">fs.readFile(<span class="string">'/etc/passwd'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, data</span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span> (err) <span class="keyword">throw</span> err;</div><div class="line">  <span class="built_in">console</span>.log(data);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>一个有趣的问题是，为什么Node.js约定，回调函数的第一个参数，必须是错误对象err（如果没有错误，该参数就是null）？原因是执行分成两段，在这两段之间抛出的错误，程序无法捕捉，只能当作参数，传入第二段。</p>
<h2 id="Generator函数的自动执行"><a href="#Generator函数的自动执行" class="headerlink" title="Generator函数的自动执行"></a>Generator函数的自动执行</h2><p>Generator函数就是一个异步操作的容器，它的自动执行需要一种机制，当异步操作有了结果，能够自动交回执行权。</p>
<p>两种方法可以实现：</p>
<ol>
<li><p>回调函数。将异步操作包装成Thunk函数，在回调函数里面交回执行权。</p>
</li>
<li><p>Promise对象。将异步操作包装成Promise对象，用then方法交回执行权。</p>
</li>
</ol>
<h2 id="async函数"><a href="#async函数" class="headerlink" title="async函数"></a>async函数</h2><p>ES7提供了<code>async</code>函数，使得异步操作变得更加方便。<code>async</code>函数就是Generator函数的语法糖。</p>
<ol>
<li>内置执行器</li>
</ol>
<p>只要像普通函数一样调用了async函数，就能够自动执行。</p>
<ol>
<li><p>更好的语义</p>
</li>
<li><p>更广的适用性。 co模块约定，yield命令后面只能是Thunk函数或Promise对象，而async函数的await命令后面，可以是Promise对象和原始类型的值（数值、字符串和布尔值，但这时等同于同步操作）。</p>
</li>
<li><p>返回值是Promise。async函数的返回值是Promise对象，这比Generator函数的返回值是Iterator对象方便多了。你可以用then方法指定下一步的操作。</p>
</li>
</ol>
<h1 id="Class"><a href="#Class" class="headerlink" title="Class"></a>Class</h1><p>ES6提供了更接近传统语言的对象写法，引入了Class类的概念，作为对象的模版。</p>
<p>基本上，ES6的class可以看做只是一个语法糖。class写法只是让对象原型的写法更加清晰，更像面向对象编程的语法而已。</p>
<p>定义class的方法的时候，前面不需要加上function关键字，方法之间不需要逗号来进行分隔。</p>
<p>类的数据类型就是function，类本身就指向构造函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</div><div class="line">  <span class="comment">// ...</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">typeof</span> Point <span class="comment">// "function"</span></div><div class="line">Point === Point.prototype.constructor <span class="comment">// true</span></div></pre></td></tr></table></figure>
<p>类的所有方法都定义在类的prototype属性上面。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</div><div class="line">  <span class="keyword">constructor</span>()&#123;</div><div class="line">    <span class="comment">// ...</span></div><div class="line">  &#125;</div><div class="line"></div><div class="line">  toString()&#123;</div><div class="line">    <span class="comment">// ...</span></div><div class="line">  &#125;</div><div class="line"></div><div class="line">  toValue()&#123;</div><div class="line">    <span class="comment">// ...</span></div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 等同于</span></div><div class="line"></div><div class="line">Point.prototype = &#123;</div><div class="line">  toString()&#123;&#125;,</div><div class="line">  toValue()&#123;&#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>另外，类的内部所有定义的方法，都是不可枚举的。类的属性名，可以采用表达式。类的构造函数，不使用new是没法调用的，会报错。</p>
<p>与ES5一致，实例的属性除非显式地定义在其本身（即定义在this对象上），否则都是定义在原型上。</p>
<p>不存在变量提升。</p>
<p>类和模块的内部，默认就是严格模式，所以不需要使用<code>use strict</code>指定运行模式。只要你的代码写在类或模块之中，就只有严格模式可用。</p>
<h2 id="Class的继承"><a href="#Class的继承" class="headerlink" title="Class的继承"></a>Class的继承</h2><p>Class之间可以通过extends关键字实现继承，这比ES6通过修改原型链实现继承，要清晰和方便很多。</p>
<p>super关键字，用来表示父类的构造函数，用来新建父类的this对象。</p>
<p>子类必须在constructor方法中调用super方法，否则新建实例时会报错。这是因为子类没有自己的this对象，而是继承父类的this对象，然后对其进行加工。如果不调用super方法，子类就得不到this对象。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ColorPoint</span> <span class="keyword">extends</span> <span class="title">Point</span> </span>&#123;</div><div class="line">  <span class="keyword">constructor</span>(x, y, color) &#123;</div><div class="line">    <span class="keyword">super</span>(x, y); <span class="comment">// 调用父类的constructor(x, y)</span></div><div class="line">    <span class="keyword">this</span>.color = color;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  toString() &#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.color + <span class="string">' '</span> + <span class="keyword">super</span>.toString(); <span class="comment">// 调用父类的toString()</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>ES5的继承，实质是先创造子类的实例对象this，然后再将父类的方法添加到this上面（Parent.apply(this)）。ES6的继承机制完全不同，实质是先创造父类的实例对象this（所以必须先调用super方法），然后再用子类的构造函数修改this。</p>
<p>这意味着ES6可以自定义原生数据结构（比如Array、String等）的子类，这是ES5无法做到的。</p>
<p>如果子类没有定义constructor方法，这个方法会被默认添加，代码如下。也就是说，不管有没有显式定义，任何一个子类都有constructor方法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">constructor</span>(...args) &#123;</div><div class="line">  <span class="keyword">super</span>(...args);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h2><p>static静态方法，不会被实例继承，而是直接通过类来调用。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</div><div class="line">  <span class="keyword">static</span> classMethod() &#123;</div><div class="line">    <span class="keyword">return</span> <span class="string">'hello'</span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Foo.classMethod() <span class="comment">// 'hello'</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> foo = <span class="keyword">new</span> Foo();</div><div class="line">foo.classMethod()</div><div class="line"><span class="comment">// TypeError: foo.classMethod is not a function</span></div></pre></td></tr></table></figure>
<p>父类的静态方法，可以被子类继承。</p>
<p>ES6明确规定，Class内部只有静态方法，没有静态属性。</p>
<h1 id="Module"><a href="#Module" class="headerlink" title="Module"></a>Module</h1><p>ES6的Class只是面向对象编程的语法糖，升级了ES5的构造函数的原型链继承的写法，并没有解决模块化的问题。Module就是为了解决这个问题。</p>
<p>ES6的模块自动采用严格模式，不管你有没有在模块头部加上”use strict”;。</p>
<p>严格模式主要有以下限制。</p>
<p>变量必须声明后再使用<br>函数的参数不能有同名属性，否则报错<br>不能使用with语句<br>不能对只读属性赋值，否则报错<br>不能使用前缀0表示八进制数，否则报错<br>不能删除不可删除的属性，否则报错<br>不能删除变量delete prop，会报错，只能删除属性delete global[prop]<br>eval不会在它的外层作用域引入变量<br>eval和arguments不能被重新赋值<br>arguments不会自动反映函数参数的变化<br>不能使用arguments.callee<br>不能使用arguments.caller<br>禁止this指向全局对象<br>不能使用fn.caller和fn.arguments获取函数调用的堆栈<br>增加了保留字（比如protected、static和interface）</p>
<p>#阅读书籍</p>
<p><a href="http://es6.ruanyifeng.com/" target="_blank" rel="external">ECMAScript 6入门</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;let和const命令&quot;&gt;&lt;a href=&quot;#let和const命令&quot; class=&quot;headerlink&quot; title=&quot;let和const命令&quot;&gt;&lt;/a&gt;let和const命令&lt;/h1&gt;&lt;h2 id=&quot;let命令&quot;&gt;&lt;a href=&quot;#let命令&quot; class=&quot;headerlink&quot; title=&quot;let命令&quot;&gt;&lt;/a&gt;let命令&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;let生命的变量仅在块级作用域内有效。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;不存在变量提升&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;暂时性死区（temporal dead zone）&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://sheilacat.github.io/categories/JavaScript/"/>
    
    
  </entry>
  
  <entry>
    <title>JavaScript错误处理</title>
    <link href="http://sheilacat.github.io/javascript-error-handle/"/>
    <id>http://sheilacat.github.io/javascript-error-handle/</id>
    <published>2016-08-09T03:06:10.000Z</published>
    <updated>2016-09-18T07:18:11.415Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h2><h3 id="JavaScript-Error-Hadler"><a href="#JavaScript-Error-Hadler" class="headerlink" title="JavaScript Error Hadler"></a>JavaScript Error Hadler</h3><p>error事件的event handler，Error事件会在不同目标上因各种错误而触发：</p>
<ul>
<li><p>当JavaScript运行时错误（包括语法错误）发生时，window会触发一个ErrorEvent接口的error事件，并执行<code>window.onerror()</code>。</p>
</li>
<li><p>当一项资源（如<code>&lt;img&gt;</code>或<code>&lt;script&gt;</code>）加载失败，加载资源的元素会触发一个Event接口的error事件，并执行该元素上的<code>onerror()</code>处理函数。这些error事件不会向上冒泡到window，不过（至少在Firefox中）能被单一的window.addEventListener捕获。</p>
</li>
</ul>
<a id="more"></a>
<p>加载一个全局的error事件处理函数可用于自动收集错误报告。</p>
<p>一个JavaScript错误由<strong>错误信息</strong>（<code>error message</code>）和<strong>追溯栈</strong>（<code>stack trace</code>）两个主要部分组成。</p>
<p>追溯栈中的每一帧由以下三个部分组成：一个函数名（发生错误的代码不是在全局作用域中执行），发生错误的脚本在网络中的地址，以及发生错误代码的行数和列数。</p>
<h3 id="异步追溯栈"><a href="#异步追溯栈" class="headerlink" title="异步追溯栈"></a>异步追溯栈</h3><p>在JavaScript代码中异步代码是非常常见的，比如<code>setTimeout</code>的使用，或者<code>Promise对象</code>的使用，这些异步调用入口往往会给追溯栈带来问题，因为异步代码会生成一个新的执行上下文，而追溯栈又会重新形成追溯帧。</p>
<p>目前，异步追溯栈只有Chrome DevTools支持，而且只有在DevTools代开的情况下才会捕获，在代码中通过Error对象不会获取到异步追溯栈。</p>
<p>虽然可以模拟异步调用栈，但是这往往会代指应用性能的消耗。</p>
<h2 id="出错处理的常用方式"><a href="#出错处理的常用方式" class="headerlink" title="出错处理的常用方式"></a>出错处理的常用方式</h2><h3 id="window-onerror"><a href="#window-onerror" class="headerlink" title="window.onerror"></a>window.onerror</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">window</span>.onerror = <span class="function"><span class="keyword">function</span>(<span class="params">msg, url, line, col, err</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'Application encountered an error: '</span> + msg);</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'Stack trace: '</span> + err.stack);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在使用这个方法捕获错误的时候会出现如下问题： No Error object provided</p>
<p>这是因为有的浏览器对第五个回调参数并不提供。</p>
<p>浏览器是事件驱动的。JavaScript中的错误也是一个事件。解释器在当前的执行上下文中执行后释放。所以，我们可以利用<code>onerror</code>全局异常事件处理函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (<span class="built_in">window</span>.addEventListener) &#123;</div><div class="line">    <span class="built_in">window</span>.addEventListener(<span class="string">'error'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</div><div class="line">        <span class="keyword">var</span> error = e.error;</div><div class="line">        <span class="built_in">console</span>.log(error);</div><div class="line">    &#125;);</div><div class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">window</span>.attachEvent) &#123;</div><div class="line">    <span class="built_in">window</span>.attachEvent(<span class="string">'onerror'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</div><div class="line">        <span class="keyword">var</span> error = e.error;</div><div class="line">        <span class="built_in">console</span>.log(error);</div><div class="line">    &#125;);</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="built_in">window</span>.onerror = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</div><div class="line">        <span class="keyword">var</span> error = e.error;</div><div class="line">        <span class="built_in">console</span>.log(error);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="try-catch"><a href="#try-catch" class="headerlink" title="try/catch"></a>try/catch</h3><p>在代码中使用 try catch 是否对性能有影响：</p>
<ul>
<li><p>在V8（其他JS引擎也可能出现相同情况）函数中使用了try/catch语句不能够被V8编译器优化。参考 <a href="http://www.html5rocks.com/en/tutorials/speed/v8/" target="_blank" rel="external">http://www.html5rocks.com/en/tutorials/speed/v8/</a></p>
</li>
<li><p>try catch 对性能的影响微乎其微，但是一些用法会让性能受很大的影响， 参考这个实验：<a href="http://taobaofed.org/blog/2015/10/28/try-catch-runing-problem/" target="_blank" rel="external">http://taobaofed.org/blog/2015/10/28/try-catch-runing-problem/</a></p>
</li>
</ul>
<p>总结下来就是：在 try 语句块中不要定义太多的变量，最好是只写一个函数调用，避免 try 运行中变量拷贝造成的性能损耗。</p>
<p>try-catch与window.onerror相比的弱势：</p>
<ol>
<li><p>它只能在单一的作用域内有效</p>
</li>
<li><p>V8引擎不鼓励在函数中使用try-catch 他们的建议是在最外层写这些块</p>
</li>
</ol>
<h2 id="JavaScript错误收集的关键点"><a href="#JavaScript错误收集的关键点" class="headerlink" title="JavaScript错误收集的关键点"></a>JavaScript错误收集的关键点</h2><h3 id="行内JS代码或者使用eval情况"><a href="#行内JS代码或者使用eval情况" class="headerlink" title="行内JS代码或者使用eval情况"></a>行内JS代码或者使用eval情况</h3><p>在使用eval或者HTML中写JS时，追溯栈通常会使用HTML的URL以及代码执行的行数和列数。</p>
<p>由于一些性能或代码优化的原因，HTML中往往会有行内脚本。为了追溯这些JS的错误，Chrome和Firefox支持<code>sourceURL</code>的声明，往往会在追溯帧后面添加一个`inline.js。这里的行数是从HTML文档开始处开始计算的，一般被认为是不正确的。</p>
<p>另外，不同浏览器都有自己处理eval代码错误的追溯栈格式，兼容不同浏览器解析eval代码将变得异常困难。</p>
<h2 id="Cross-domain-sanitization"><a href="#Cross-domain-sanitization" class="headerlink" title="Cross domain sanitization"></a>Cross domain sanitization</h2><p>在Chrome中，<code>window.onerror</code>能够检测到从别的域引用的script文件中的错误（比如从CDN上面引用的jQuery源文件）并且将这些错误标记为<code>Script error</code>。如果你不想处理这些从别的域引入的script文件，那么可以在程序中通过script error标记将其过滤掉。然而，在Firefox、Safari或者IE11中，并不会引入跨域的JS错误，即使在Chrome中，如果使用<code>try/catch</code>将这些讨厌的代码包围，那么Chrome也不会再检测到这些跨域错误。</p>
<h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><p>有两个方案：</p>
<ol>
<li>在Chrome中，可以设置合适的跨域头信息来捕获跨域JS错误。</li>
</ol>
<p>在Chrome中，如果你想通过<code>window.onerror</code>来获取到完整的跨域错误信息，那么这些跨域资源必须提供合适的跨域头信息。可以参考下面地址 <a href="https://mikewest.org/2013/08/debugging-runtime-errors-with-window-onerror" target="_blank" rel="external">https://mikewest.org/2013/08/debugging-runtime-errors-with-window-onerror</a></p>
<pre><code>1. 先给script文件设置一个属性crossorigin

`&lt;script type=&quot;text/javascript&quot; src=&quot;xxx.js&quot; crossorigin&gt;&lt;/script&gt;`

2. 给请求的文件头返回信息设置合适的跨域头信息`Access-Control-Allow-Origin`
</code></pre><ol>
<li>手动包裹一些要检测的代码，没有跨域问题并且可以获得到error对象。这种方式相对麻烦一些，但可以通过全局的hook，处理大部分情况，不必每次都要写<code>try...catch...</code>。这里可以参考<code>tryjs</code>的做法。</li>
</ol>
<p>tryjs可以捕获跨域错误，以及包裹异步方法来捕获并定位错误。</p>
<h4 id="tryjs"><a href="#tryjs" class="headerlink" title="tryjs"></a><a href="https://github.com/imweb/tryjs" target="_blank" rel="external">tryjs</a></h4><blockquote>
<p>window.onerror在webkit中对于跨域的脚本错误无法捕获其stack，经常让我们无法定位上报的问题，tryjs利用try-catch将函数包裹起来，让错误捕获变得容易。</p>
</blockquote>
<h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>对于基于AMD和jQuery的网站，几乎所有业务函数都是通过回调异步触发的，所以我们只需要将所有异步函数包裹起来就可以捕获到大部分错误。</p>
<p>例如，对于require函数，一般是这样使用的：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">require</span>([<span class="string">'./main'</span>],</div><div class="line">    <span class="comment">// 想办法把这个函数包裹起来 </span></div><div class="line">    <span class="function"><span class="keyword">function</span> (<span class="params">main</span>) </span>&#123;</div><div class="line">        <span class="comment">// 实际上这里才是在调用</span></div><div class="line">        main.init();</div><div class="line">    &#125;);</div></pre></td></tr></table></figure>
<p>类似的对于setTimeout函数，一般可以这样：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">setTimeout(</div><div class="line">    <span class="comment">// 想办法把这个函数包裹起来就行了</span></div><div class="line">    <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        dosomthing();</div><div class="line">    &#125;, </div><div class="line">    <span class="number">1000</span></div><div class="line">);</div></pre></td></tr></table></figure>
<h2 id="JavaScript错误监控上报"><a href="#JavaScript错误监控上报" class="headerlink" title="JavaScript错误监控上报"></a>JavaScript错误监控上报</h2><h3 id="基本要素"><a href="#基本要素" class="headerlink" title="基本要素"></a>基本要素</h3><ol>
<li>onerror的回调 try..catch来进行错误处理</li>
</ol>
<p><code>onerror</code>适用于任何错误，<code>try...catch</code>适用于某个明确知道可能会出错的点，并进行错误处理</p>
<ol>
<li>JavaScript错误上报的<strong>采样率</strong></li>
</ol>
<p>没有必要把所有的错误信息全部都送到Log中，量太大。可以限制一个采样率。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">needReport</span> (<span class="params">sampling</span>)</span>&#123;</div><div class="line">  <span class="comment">// sampling: 0 - 1</span></div><div class="line">  <span class="keyword">return</span> <span class="built_in">Math</span>.random() &lt;= sampling;</div><div class="line">&#125;</div><div class="line">Reporter.send = <span class="function"><span class="keyword">function</span>(<span class="params">errInfo, sampling</span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span>(needReport(sampling || <span class="number">1</span>))&#123;</div><div class="line">    Reporter._send(errInfo);</div><div class="line">  &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<ol>
<li><p>是否重复上报、是否延迟上报</p>
</li>
<li><p>上报的错误级别 info log debug…</p>
</li>
</ol>
<h3 id="为了提升代码的可调试性"><a href="#为了提升代码的可调试性" class="headerlink" title="为了提升代码的可调试性"></a>为了提升代码的可调试性</h3><ol>
<li><p>为匿名函数取名</p>
</li>
<li><p>将函数赋给一个变量</p>
</li>
</ol>
<p>inner function Firefox stack frame warning 在一个函数定义在另外一个函数内部的情景下（闭包）Firefox会使用不同于其他浏览器厂商的格式来处理函数名<br>3、displayName属性<br>除了IE11，函数名的展现也可以通过给函数定义一个<code>displayName</code>属性，它会出现在浏览器的devtools debugger中。而Safari，<code>displayName</code>还会出现在追溯帧中。</p>
<h4 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h4><p><a href="http://www.cnblogs.com/hustskyking/p/fe-monitor.html" target="_blank" rel="external">前端代码异常日志收集与监控</a></p>
<p><a href="http://taobaofed.org/blog/2015/10/28/jstracker-how-to-collect-data/" target="_blank" rel="external">JSTracker：前端异常数据采集</a></p>
<h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p><a href="http://jixianqianduan.com/article-translation/2016/05/12/proper-error-handler-in-javascript.html" target="_blank" rel="external">【原译】javascript中的错误处理</a></p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/GlobalEventHandlers/onerror" target="_blank" rel="external">MDN：GlobalEventHandlers.onerror</a></p>
<p><a href="https://cnodejs.org/topic/56f3a1d5ce1f18c57719a4c2" target="_blank" rel="external">JavaScript Error 指南（翻译）</a></p>
<p><a href="http://imweb.io/topic/55e3d6e3771670e207a16bd5" target="_blank" rel="external">关于javascript错误捕获</a></p>
<p><a href="http://www.alloyteam.com/2014/03/front-end-data-monitoring/" target="_blank" rel="external">前端相关数据监控</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;基本介绍&quot;&gt;&lt;a href=&quot;#基本介绍&quot; class=&quot;headerlink&quot; title=&quot;基本介绍&quot;&gt;&lt;/a&gt;基本介绍&lt;/h2&gt;&lt;h3 id=&quot;JavaScript-Error-Hadler&quot;&gt;&lt;a href=&quot;#JavaScript-Error-Hadler&quot; class=&quot;headerlink&quot; title=&quot;JavaScript Error Hadler&quot;&gt;&lt;/a&gt;JavaScript Error Hadler&lt;/h3&gt;&lt;p&gt;error事件的event handler，Error事件会在不同目标上因各种错误而触发：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;当JavaScript运行时错误（包括语法错误）发生时，window会触发一个ErrorEvent接口的error事件，并执行&lt;code&gt;window.onerror()&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;当一项资源（如&lt;code&gt;&amp;lt;img&amp;gt;&lt;/code&gt;或&lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt;）加载失败，加载资源的元素会触发一个Event接口的error事件，并执行该元素上的&lt;code&gt;onerror()&lt;/code&gt;处理函数。这些error事件不会向上冒泡到window，不过（至少在Firefox中）能被单一的window.addEventListener捕获。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://sheilacat.github.io/categories/JavaScript/"/>
    
    
  </entry>
  
  <entry>
    <title>面向对象的程序设计——创建对象</title>
    <link href="http://sheilacat.github.io/create-an-object/"/>
    <id>http://sheilacat.github.io/create-an-object/</id>
    <published>2016-07-14T11:23:00.000Z</published>
    <updated>2016-10-08T12:34:05.356Z</updated>
    
    <content type="html"><![CDATA[<p>参考JavaScript高级程序设计（第3版） 第六章</p>
<p>先放总结图：</p>
<p><img src="http://thumbsnap.com/i/r9JtabZ7.png?1008" alt="总结"></p>
<a id="more"></a>
<h2 id="属性类型"><a href="#属性类型" class="headerlink" title="属性类型"></a>属性类型</h2><h3 id="数据属性"><a href="#数据属性" class="headerlink" title="数据属性"></a>数据属性</h3><p>数据属性包含一个数据值的位置。在这个位置可以读取和写入只。<br>数据属性有4个描述其行为的特性。</p>
<p>[[Configurable]]：<strong>表示能否通过delete删除属性从而重新定义属性，能否修改属性的特性，或者能否把属性修改为访问器属性。默认为true。</strong><br>一旦把属性定义为不可配置，就不能在变回可配置。<br>[[Enumerable]]： 表示能否通过for-in循环返回属性。默认为true。<br>[[Writable]]：表示能否修改属性的值。默认true。<br>[[Value]]：包含这个属性的数据值。默认为undefined。</p>
<p>要修改属性默认的特性，必须使用ECMAScript5的<code>Object.defineProperty()</code>方法。</p>
<h3 id="访问器属性"><a href="#访问器属性" class="headerlink" title="访问器属性"></a>访问器属性</h3><p>访问器属性包含以下4个特性：<br>[[Configurable]]：<strong>表示能否通过delete删除属性从而重新定义属性，能否修改属性的特性，或者能否把属性修改为数据属性。默认为true。</strong><br>[[Enumerable]]：同上<br>[[Get]]：在读取属性时调用的函数，默认undefined<br>[[Set]]：在写入属性时调用的函数。默认undefined</p>
<p>要修改属性默认的特性，必须使用ECMAScript5的<code>Object.defineProperty()</code>方法。<br>在这个方法之前，要创建访问器属性，一般都是用两个非变准的方法：<strong>defineGetter</strong>()和<strong>defineSetter</strong>()。</p>
<p>Object.defineProperty有三个参数，操作的对象，对象的属性，和修改的内容。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> book = &#123;</div><div class="line">_year: <span class="number">2004</span>,</div><div class="line">edition: <span class="number">1</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line">book.__defineGetter__(<span class="string">"year"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line"><span class="keyword">return</span> <span class="keyword">this</span>._year;</div><div class="line">&#125;);</div><div class="line">book.__defineSetter__(<span class="string">"year"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">newValue</span>)</span>&#123;</div><div class="line"><span class="keyword">if</span> (newValue &gt; <span class="number">2004</span>) &#123;</div><div class="line"><span class="keyword">this</span>._year = newValue;</div><div class="line"><span class="keyword">this</span>.edition += newValue - <span class="number">2004</span>;</div><div class="line">&#125;</div><div class="line">&#125;);</div><div class="line">book.year = <span class="number">2005</span>;</div><div class="line">alert(book.edition); <span class="comment">//2</span></div></pre></td></tr></table></figure>
<h2 id="定义多个属性"><a href="#定义多个属性" class="headerlink" title="定义多个属性"></a>定义多个属性</h2><p>Object.defineProperties()</p>
<h2 id="读取属性的特性"><a href="#读取属性的特性" class="headerlink" title="读取属性的特性"></a>读取属性的特性</h2><p>Object.getOwnPropertyDescriptor()</p>
<h2 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h2><h3 id="最简单的方式-Object构造函数或对象字面量"><a href="#最简单的方式-Object构造函数或对象字面量" class="headerlink" title="最简单的方式 Object构造函数或对象字面量"></a>最简单的方式 Object构造函数或对象字面量</h3><p>最简单的创建对象的方式，就是创建一个对象实例，再给它赋值</p>
<p>var person = new Object();<br>person.name = “Nicholas”;<br>person.sayName = function() {<br>     alert(this.name)<br>};</p>
<p>对象字面量就是这种创建方式：</p>
<p>var person = {<br>     name: ‘Nicholas’,<br>     sayName: function() {<br>     alert(this.name);<br>     };<br>};</p>
<p>虽然Object构造函数或对象字面量都可以用来创建单个对象，但这些方式有个明显的缺点：使用同一个接口创建很多对象，会产生大量的重复代码。</p>
<h3 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">createPerson</span>(<span class="params">name, age, job</span>)</span>&#123;</div><div class="line"><span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</div><div class="line">o.name = name;</div><div class="line">o.age = age;</div><div class="line">o.job = job;</div><div class="line">o.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">alert(<span class="keyword">this</span>.name);</div><div class="line">&#125;;</div><div class="line"><span class="keyword">return</span> o;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> person1 = createPerson(<span class="string">"Nicholas"</span>, <span class="number">29</span>, <span class="string">"Software Engineer"</span>);</div><div class="line"><span class="keyword">var</span> person2 = createPerson(<span class="string">"Greg"</span>, <span class="number">27</span>, <span class="string">"Doctor"</span>);</div></pre></td></tr></table></figure>
<p>工厂模式虽然解决了创建多个相似对象的问题，但却没有解决对象识别的问题，不能知道一个对象的类型。</p>
<h3 id="构造函数模式"><a href="#构造函数模式" class="headerlink" title="构造函数模式"></a>构造函数模式</h3><p>创建自定义的构造函数，从而定义自动以对象类型的属性和方法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>)</span>&#123;</div><div class="line"><span class="keyword">this</span>.name = name;</div><div class="line"><span class="keyword">this</span>.age = age;</div><div class="line"><span class="keyword">this</span>.job = job;</div><div class="line"><span class="keyword">this</span>.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">alert(<span class="keyword">this</span>.name);</div><div class="line">&#125;;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(<span class="string">"Nicholas"</span>, <span class="number">29</span>, <span class="string">"Software Engineer"</span>);</div><div class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person(<span class="string">"Greg"</span>, <span class="number">27</span>, <span class="string">"Doctor"</span>);</div></pre></td></tr></table></figure>
<p>与工厂模式的不同点在于：</p>
<ol>
<li><p>没有显式地创建对象</p>
</li>
<li><p>直接将属性和方式赋给了this对象</p>
</li>
<li><p>没有return语句</p>
</li>
</ol>
<p>要创建Person的新实例，必须使用new操作符。会经历以下4个步骤：</p>
<ol>
<li><p>创建一个新对象</p>
</li>
<li><p>将构造函数的作用域赋给新对象</p>
</li>
<li><p>执行构造函数中的代码</p>
</li>
<li><p>返回新对象</p>
</li>
</ol>
<p>这种方法可以用constructor和instanceof来检测实例的对象类型。</p>
<p>另外，我们应该明白</p>
<ol>
<li>把构造函数当作函数</li>
</ol>
<p>构造函数与其他函数唯一的区别就在于他们的调用方式。任何函数，只要通过new操作符来调用，那么它就可以作为构造函数。</p>
<ol>
<li>构造函数的问题</li>
</ol>
<p>每个方法都要在每个实例上重新创建一遍。例如，person1和person2都有一个名为sayName()的方法，但那两个方法不是同一个Function的实例。<br>即，不同实例上的同名函数是不相等的。<br>在ECMAScript中，函数就是对象，那么每定义一个函数，也就是实例化了一个对象。</p>
<p>在这里，我们可以通过把函数定义转移到构造函数外部来解决这个问题。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>)</span>&#123;</div><div class="line"><span class="keyword">this</span>.name = name;</div><div class="line"><span class="keyword">this</span>.age = age;</div><div class="line"><span class="keyword">this</span>.job = job;</div><div class="line"><span class="keyword">this</span>.sayName = sayName;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayName</span>(<span class="params"></span>)</span>&#123;</div><div class="line">alert(<span class="keyword">this</span>.name);</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(<span class="string">"Nicholas"</span>, <span class="number">29</span>, <span class="string">"Software Engineer"</span>);</div><div class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person(<span class="string">"Greg"</span>, <span class="number">27</span>, <span class="string">"Doctor"</span>);</div></pre></td></tr></table></figure>
<p>这样做的确解决了上面所说的问题，但新的问题是，这样在全局作用域定义的函数实际上只能被某个对象所定义，让全局作用域有点名不副实。如果对象需要定义很多方法，就要定义很多全局函数。那么自定义的引用类型就丝毫没有封装性可言了。所以引出了原型模式。</p>
<h3 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h3><h4 id="理解原型对象"><a href="#理解原型对象" class="headerlink" title="理解原型对象"></a>理解原型对象</h4><p><img src="https://app.yinxiang.com/shard/s31/res/0506d0fd-d5b6-4c7e-b362-c2b7dab01bb8" alt="理解原型对象"></p>
<p>无论什么时候，只要创建了一个新函数，就会根据一组特定的规则为该函数创建一个prototype属性，这个属性指向函数的原型对象。<br>就是函数自身会有一个prototype属性，指向该函数的原型对象。</p>
<p>在默认情况下，所有原型对象都会自动获得一个constructor（构造函数）属性，这个属性包含一个指向prototype属性所在函数的指针。</p>
<p>注意，这样的连接是存在于实例与构造函数的原型对象之间的。换句话说，实例与构造函数没有直接的关系。</p>
<p>如图是Person构造函数、Person的原型属性以及Person现有的两个实例之间的关系。</p>
<p>在这里，可以用Object.getPrototypeof()来检测实例与对象呀unxingzhijian的关系。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Person.prototype.isPrototypeOf(person1); <span class="comment">//true</span></div></pre></td></tr></table></figure>
<p>ECMAScript5 增加了一个新方法，叫Object.getPrototypeOf()，这个返回[[Prototype]]的值。</p>
<p>当为对象实例添加一个属性时，这个属性就会屏蔽原型对象中保存的同名属性；换句话说，添加这个属性只会阻止我们访问原型中的那个属性，但不会修改那个属性。<br>使用detele操作符则可以完全删除实例属性，从而让我们能够重新访问原型中的属性。</p>
<p>原型模式的缺点是：</p>
<ol>
<li><p>省略了为构造函数传递初始化参数这一环节，导致所有实例都取得相同的值</p>
</li>
<li><p>所有属性都被很多实例共享。</p>
</li>
</ol>
<p>对于包含基本只的属性倒也说得过去，通过前面说的屏蔽原型中对应的值，可以取得独立的值。但是对于包含引用类型的属性来说，这个就是完全共享的了。</p>
<h2 id="组合使用构造函数模式和原型模式"><a href="#组合使用构造函数模式和原型模式" class="headerlink" title="组合使用构造函数模式和原型模式"></a>组合使用构造函数模式和原型模式</h2><p>创建自定义类型的最常见方式，就是组合使用构造函数与原型模式。</p>
<p><strong>构造函数模式用于定义实例属性，而原型模式用于定义方法和共享的属性。</strong></p>
<p>最大限度地节省了内存，而且这种模式还支持向构造函数传递参数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>)</span>&#123;</div><div class="line"><span class="keyword">this</span>.name = name;</div><div class="line"><span class="keyword">this</span>.age = age;</div><div class="line"><span class="keyword">this</span>.job = job;</div><div class="line"><span class="keyword">this</span>.friends = [<span class="string">"Shelby"</span>, <span class="string">"Court"</span>];</div><div class="line">&#125;</div><div class="line">Person.prototype = &#123;</div><div class="line"><span class="keyword">constructor</span> : Person, //这里用字面量的方式重新定义原型对象 会导致<span class="keyword">constructor</span>不再指向Person 会指向Object构造函数 所以这里要指回来</div><div class="line">sayName : function()&#123;</div><div class="line">alert(<span class="keyword">this</span>.name);</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(<span class="string">"Nicholas"</span>, <span class="number">29</span>, <span class="string">"Software Engineer"</span>);</div><div class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person(<span class="string">"Greg"</span>, <span class="number">27</span>, <span class="string">"Doctor"</span>);</div><div class="line">person1.friends.push(<span class="string">"Van"</span>);</div><div class="line">alert(person1.friends); <span class="comment">//"Shelby,Count,Van"</span></div><div class="line">alert(person2.friends); <span class="comment">//"Shelby,Count"</span></div><div class="line">alert(person1.friends === person2.friends); <span class="comment">//false</span></div><div class="line">alert(person1.sayName === person2.sayName); <span class="comment">//true</span></div></pre></td></tr></table></figure>
<p>这种构造函数与原型混成的模式。一般来说是用来定义引用类型的一种默认模式。</p>
<h2 id="动态原型模式"><a href="#动态原型模式" class="headerlink" title="动态原型模式"></a>动态原型模式</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>)</span>&#123;</div><div class="line"><span class="comment">//属性</span></div><div class="line"><span class="keyword">this</span>.name = name;</div><div class="line"><span class="keyword">this</span>.age = age;</div><div class="line"><span class="keyword">this</span>.job = job;</div><div class="line"><span class="comment">//方法</span></div><div class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">this</span>.sayName != <span class="string">"function"</span>)&#123; <span class="comment">//这个判断语句 只需要判断 其中的任何一个属性或者方法即可 因为只在第一次进行声明</span></div><div class="line">Person.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">alert(<span class="keyword">this</span>.name);</div><div class="line">&#125;;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> friend = <span class="keyword">new</span> Person(<span class="string">"Nicholas"</span>, <span class="number">29</span>, <span class="string">"Software Engineer"</span>);</div><div class="line">friend.sayName();</div></pre></td></tr></table></figure>
<p>这种方法，是为了把构造函数和原型相关的信息都封装在构造函数中。便于其他OO语言经验的开发人员进行理解。</p>
<p>`<br>使用动态原型模式时，不能使用对象字面量重写原型。<br>如果在已经创建了实例的情况下重写原型，那么就会切断现有实例与新原型之间的联系。</p>
<h2 id="寄生构造函数模式"><a href="#寄生构造函数模式" class="headerlink" title="寄生构造函数模式"></a>寄生构造函数模式</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>)</span>&#123;</div><div class="line"><span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</div><div class="line">o.name = name;</div><div class="line">o.age = age;</div><div class="line">o.job = job;</div><div class="line">o.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">alert(<span class="keyword">this</span>.name);</div><div class="line">&#125;;</div><div class="line"><span class="keyword">return</span> o;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> friend = <span class="keyword">new</span> Person(<span class="string">"Nicholas"</span>, <span class="number">29</span>, <span class="string">"Software Engineer"</span>);</div><div class="line">friend.sayName(); <span class="comment">//"Nicholas"</span></div></pre></td></tr></table></figure>
<p>除了使用new操作符并把使用的包装函数叫做构造函数之外，这个模式跟工厂模式是一模一样的。<br>这个模式可以在特殊情况下来为对象创建构造函数。比如创建一个新的对象来继承Array的属性，并且写额外的方法。</p>
<p>不能依赖instanceof操作符来确定对象类型。</p>
<h2 id="稳妥构造函数模式"><a href="#稳妥构造函数模式" class="headerlink" title="稳妥构造函数模式"></a>稳妥构造函数模式</h2>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;参考JavaScript高级程序设计（第3版） 第六章&lt;/p&gt;
&lt;p&gt;先放总结图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://thumbsnap.com/i/r9JtabZ7.png?1008&quot; alt=&quot;总结&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://sheilacat.github.io/categories/JavaScript/"/>
    
    
  </entry>
  
  <entry>
    <title>JavaScript内存泄漏与内存管理</title>
    <link href="http://sheilacat.github.io/javascript-memory-leak/"/>
    <id>http://sheilacat.github.io/javascript-memory-leak/</id>
    <published>2016-04-06T08:22:00.000Z</published>
    <updated>2016-09-18T07:05:01.433Z</updated>
    
    <content type="html"><![CDATA[<p>本文说明了JavaScript中内存的生命周期，以及内存管理与内存泄漏，内存泄漏的常见情况和解决办法。</p>
<p><img src="http://thumbsnap.com/i/UhcQVx2r.png?0406" alt="内存管理与内存泄漏"></p>
<a id="more"></a>
<h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><p>JS运行的时候，会有栈内存（stack）和堆内存（heap），当我们用new实例化一个类的时候，这个new出来的对象就保存在heap里面，而这个对象的引用则存储在stack里。程序通过stack里的引用找到这个对象。例如var a = [1,2,3];，a是存储在stack里的引用，heap里存储着内容为[1,2,3]的Array对象。当栈中的变量被重新符值，原来在堆中存储的对象就会被释放，这个过程就叫垃圾回收。</p>
<h2 id="内存生命周期"><a href="#内存生命周期" class="headerlink" title="内存生命周期"></a>内存生命周期</h2><p>不管什么程序语言，内存生命周期基本一致：   </p>
<ol>
<li>分配你所需要的内存</li>
<li>使用它（读、写）</li>
<li>当它不被使用时释放   ps：和“把大象装冰箱“一个意思</li>
</ol>
<p>第一二部分过程在所有语言中都很清晰。最后一步在低级语言中很清晰，但是在像JavaScript等高级语言中，最后一步不清晰。</p>
<h2 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h2><p>JavaScript具有<strong>自动垃圾收集机制</strong>，也就是说，执行环境会负责管理代码执行过程中使用的内存。这种垃圾收集机制的原因很简单：<strong>找出那些不再继续使用的变量，然后释放其占用的内存。为此，垃圾收集器会按照固定的时间间隔（或代码执行中预定的收集时间），周期性地执行这一操作。</strong></p>
<h3 id="引用计数算法-Reference-Counting"><a href="#引用计数算法-Reference-Counting" class="headerlink" title="引用计数算法 Reference Counting"></a>引用计数算法 Reference Counting</h3><p>这是最简单的垃圾收集算法。此算法把“对象是否不再需要”简化定义为“对象有没有其他对象引用到它”。如果没有引用指向该对象（零引用），对象将被垃圾回收机制回收。</p>
<p><strong>限制：循环引用</strong></p>
<p>这个简单的算法有一个限制，就是如果一个对象引用另一个（形成了循环引用），他们可能“不再需要”了，但是他们不会被回收。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="keyword">var</span> o = &#123;&#125;;</div><div class="line">  <span class="keyword">var</span> o2 = &#123;&#125;;</div><div class="line">  o.a = o2; <span class="comment">// o 引用 o2</span></div><div class="line">  o2.a = o; <span class="comment">// o2 引用 o</span></div><div class="line"></div><div class="line">  <span class="keyword">return</span> <span class="string">"azerty"</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line">f();</div><div class="line"><span class="comment">// 两个对象被创建，并互相引用，形成了一个循环</span></div><div class="line"><span class="comment">// 他们被调用之后不会离开函数作用域</span></div><div class="line"><span class="comment">// 所以他们已经没有用了，可以被回收了</span></div><div class="line"><span class="comment">// 然而，引用计数算法考虑到他们互相都有至少一次引用，所以他们不会被回收</span></div></pre></td></tr></table></figure>
<p>实际当中的例子：</p>
<p>IE 6, 7 对DOM对象进行引用计数回收。对他们来说，一个常见问题就是内存泄露：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> div = <span class="built_in">document</span>.createElement(<span class="string">"div"</span>);</div><div class="line">div.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  doSomething();</div><div class="line">&#125;; </div><div class="line"><span class="comment">// div有了一个引用指向事件处理属性onclick</span></div><div class="line"><span class="comment">// 事件处理也有一个对div的引用可以在函数作用域中被访问到</span></div><div class="line"><span class="comment">// 这个循环引用会导致两个对象都不会被垃圾回收</span></div></pre></td></tr></table></figure>
<p>我们知道，IE中有一部分对象并不是原生JavaScript对象。例如，其BOM和DOM中的对象就是使用C++以COM（Component Object Model，组件对象模型）对象的形式实现的，而COM对象的垃圾收集机制采用的就是引用计数策略。因此，即使IE的JavaScript引擎是使用标记清除策略来实现的，但JavaScript访问的COM对象依然是基于引用计数策略的。换句话说，只要在IE中涉及COM对象，就会存在循环引用的问题：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> element = <span class="built_in">document</span>.getElementById(<span class="string">"some_element"</span>);</div><div class="line"><span class="keyword">var</span> myObject = <span class="keyword">new</span> <span class="built_in">Object</span>();</div><div class="line">myObject.element = element;</div><div class="line">element.someObject = myObject;</div></pre></td></tr></table></figure>
<p>DOM元素与原生JavaScript对象之间创建了循环引用。由于存在这个循环引用，即使将例子中的DOM从页面中移除，它也永远不会被回收。</p>
<p>在不使用它们的时候手工断开连接：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">myObject.element = <span class="literal">null</span>;</div><div class="line">element.someObject = <span class="literal">null</span>;</div></pre></td></tr></table></figure>
<p>为了解决上述问题，IE9把BOM和DOM对象都转换成了真正的JavaScript对象。</p>
<p>JavaScript引擎目前都不再使用这种算法；但在IE中访问非原生JavaScript对象（如DOM元素）时，这种算法仍然可能会导致问题。</p>
<h3 id="标记-清除算法-Mark-and-sweep"><a href="#标记-清除算法-Mark-and-sweep" class="headerlink" title="标记-清除算法 Mark and sweep"></a>标记-清除算法 Mark and sweep</h3><p>这个算法把“对象是否不再需要”简化定义为“对象是否可以获得”。</p>
<p>这个算法假定设置一个叫做根的对象（在Javascript里，根是全局对象）。定期的，垃圾回收器将从根开始，找所有从根开始引用的对象，然后找这些对象引用的对象……从根开始，垃圾回收器将找到所有可以获得的对象和所有不能获得的对象。</p>
<blockquote>
<p>垃圾回收器在运行的时候会给存储在内存中的所有变量都加上标记（当然，可以使用任何标记方式）。然后它会去掉环境中的变量以及被环境中的变量引用的变量标记。而在此之后再被加上标记的变量将被视为准备删除的变量，原因是环境中的变量已经无法访问到这些变量了。最后，垃圾收集器完成内存清除工作，销毁那些带标记的值并回收它们所占用的内存空间。</p>
</blockquote>
<p>这个算法比前一个要好，因为“有零引用的对象”总是不可获得的，但是相反却不一定，参考“循环引用”。</p>
<p>从2012年起，所有现代浏览器都使用了标记-清除垃圾回收算法。所有对JavaScript垃圾回收算法的改进都是基于标记-清除算法的改进，并没有改进标记-清除算法本身和它对“对象是否不再需要”的简化定义。</p>
<p><strong>循环引用不再是问题了</strong></p>
<p>在上面的示例中，函数调用返回之后，两个对象从全局对象出发无法获取。因此，他们将会被垃圾回收器回收。<br>第二个示例同样，一旦 div 和其事件处理无法从根获取到，他们将会被垃圾回收器回收<br>。</p>
<p><strong>限制: 那些无法从根对象查询到的对象都将被清除</strong></p>
<p>尽管这是一个限制，但实践中我们很少会碰到类似的情况，所以开发者不太会去关心垃圾回收机制。</p>
<h2 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h2><p>能导致内存泄漏的一定是引用类型的变量，比如函数和其他自定义对象。而值类型的变量是不存在内存泄漏的，比如字符串、数字、布尔值等。</p>
<p>因为值类型是靠复制来传递的，而引用类型是靠类似c语言中的指针来传递的。<br>可以认为一个引用类型的变量就是一个指向某个具体的内存地址的指针。</p>
<p>当我们用JavaScript代码创建一个引用类型的时候（以下简称对象），js引擎会在内存中开辟一块空间来存放数据，并把指针引用交给那个变量。内存是有限的，js引擎必须保证当开辟的对象没用的时候，把所分配的内存空间释放出来，这个过程叫做垃圾回收，负责回收的叫做垃圾回收器（GC）。</p>
<p>内存泄漏是指我们已经无法再通过js代码来引用到某个对象，但垃圾回收器却认为这个对象还在被引用，因此在回收的时候不会释放它。导致了分配的这块内存永远也无法被释放出来。如果这样的情况越来越多，会导致内存不够用而系统崩溃。</p>
<p>许多功能无需考虑内存管理即可实现，但却忽略了它可能在程序中带来重大的问题。不当清理的对象可能会存在比预期要长得多的时间。这些对象继续响应事件和消耗资源。它们可强制浏览器从一个虚拟磁盘驱动器分配内存页，这显著影响了计算机的速度（在极端的情形中，会导致浏览器崩溃）。</p>
<p>过去导致内存泄漏的许多经典模式在现代浏览器中以不再导致泄漏内存。但是，如今有一种不同的趋势影响着内存泄漏。许多人正设计用于在没有硬页面刷新的单页中运行的 Web 应用程序。在那样的单页中，从应用程序的一个状态到另一个状态时，很容易保留不再需要或不相关的内存。</p>
<h3 id="造成内存泄漏的主要原因"><a href="#造成内存泄漏的主要原因" class="headerlink" title="造成内存泄漏的主要原因"></a>造成内存泄漏的主要原因</h3><h4 id="循环引用"><a href="#循环引用" class="headerlink" title="循环引用"></a>循环引用</h4><p>要想破坏循环引用，引用DOM元素的对象或DOM对象的引用需要被赋值为null。</p>
<h4 id="JavaScript闭包"><a href="#JavaScript闭包" class="headerlink" title="JavaScript闭包"></a>JavaScript闭包</h4><p>闭包可以导致内存泄露是因为内部方法保持一个对外部方法变量的引用，所以尽管方法返回了内部方法还可以继续访问在外部方法中定义的私有变量。对Javascript程序员来说最好的做法是在页面重载前断开所有的事件处理器。</p>
<p>在一个闭包中引用的任何局部变量都会被该闭包保留，只要该闭包存在就永远保留。</p>
<h5 id="销毁对象和对象所有权"><a href="#销毁对象和对象所有权" class="headerlink" title="销毁对象和对象所有权"></a>销毁对象和对象所有权</h5><p>一种不错的做法是，创建一个标准方法来负责让一个对象有资格被垃圾回收。destroy 功能的主要用途是，集中清理该对象完成的具有以下后果的操作的职责：</p>
<ul>
<li><p>阻止它的引用计数下降到0（例如，删除存在问题的事件侦听器和回调，并从任何服务取消注册）。</p>
</li>
<li><p>使用不必要的 CPU 周期，比如间隔或动画。</p>
</li>
</ul>
<p>destroy 方法常常是清理一个对象的必要步骤，但在大多数情况下它还不够。在理论上，在销毁相关实例后，保留对已销毁对象的引用的其他对象可调用自身之上的方法。因为这种情形可能会产生不可预测的结果，所以仅在对象即将无用时调用 destroy 方法，这至关重要。</p>
<p>一般而言，destroy 方法最佳使用是在一个对象有一个明确的所有者来负责它的生命周期时。此情形常常存在于分层系统中，比如 MVC框架中的视图或控制器，或者一个画布呈现系统的场景图。</p>
<h4 id="DOM插入顺序"><a href="#DOM插入顺序" class="headerlink" title="DOM插入顺序"></a>DOM插入顺序</h4><p>DOM 对象应该按照从当前页面存在的最上面的 DOM 元素开始往下直到剩下的 DOM 元素的顺序添加，这样它们就总是有同样的范围，不会产生临时对象。</p>
<h4 id="控制台日志"><a href="#控制台日志" class="headerlink" title="控制台日志"></a>控制台日志</h4><p>控制台日志记录对总体内存配置文件的影响可能是许多开发人员都未想到的极其重大的问题。记录错误的对象可以将大量数据保留在内存中。注意，这也适用于：</p>
<ul>
<li>在用户键入 JavaScript 时，在控制台中的一个交互式会话期间记录的对象。</li>
<li>由 console.log 和 console.dir 方法记录的对象。</li>
</ul>
<h4 id="XMLHttpRequest对象泄漏"><a href="#XMLHttpRequest对象泄漏" class="headerlink" title="XMLHttpRequest对象泄漏"></a>XMLHttpRequest对象泄漏</h4><p>在IE低版本中，除了上面说的BOM和DOM对象的循环引用会造成内存泄露外，还有一个js对象也会产生泄漏，就是XMLHttpRequest对象，XMLHttpRequest在IE&lt;9会造成内存泄露，看下面的代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  setInterval(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">     <span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</div><div class="line">     xhr.largeStr = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">100000</span>).join(<span class="string">'xxoo'</span>);</div><div class="line">     xhr.open(<span class="string">'GET'</span>, <span class="string">'/users'</span>, <span class="literal">true</span>);</div><div class="line">     xhr.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.readyState == <span class="number">4</span> &amp;&amp; <span class="keyword">this</span>.status == <span class="number">200</span>) &#123;</div><div class="line">           <span class="built_in">document</span>.getElementById(<span class="string">'test'</span>).innerHTML++</div><div class="line">        &#125;</div><div class="line">     &#125;;</div><div class="line">     xhr.send();</div><div class="line">    <span class="comment">//xhr = null; 解决办法 切断xhr引用</span></div><div class="line">  &#125;, <span class="number">50</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>关于这个在低版本中XMLHttpRequest对象内存泄露问题，网上资源很少，英文资料也特别少，搜到一篇分析不错的文章： <a href="http://nullprogram.com/blog/2013/02/08/" target="_blank" rel="external">http://nullprogram.com/blog/2013/02/08/</a></p>
<p>结合作者的理解：</p>
<p>按照正常情况，在结束定时器闭包时，xhr及绑定事件的闭包应该被标计清除法清除掉，但是想像一下，如果真清除掉了，这个XHR实例也就没有意思了，因为后面即使请求成功了，也没有XHR来响应了。猜测浏览器内部应该是把这个xhr及闭包函数放在了一个不能被外部直接访问空间里来响应回调。并且通过一套机制来等响应成功后清除掉这块内存空间，但是早期的IE在这个设计上存在不足，没法回收。总结一句就是：XMLHttpRequest特殊就在于它是异部执行的，所以不能立马从内存中释放。</p>
<h3 id="易出现泄露的场景"><a href="#易出现泄露的场景" class="headerlink" title="易出现泄露的场景"></a>易出现泄露的场景</h3><ol>
<li><p>XMLHttpRequest 泄漏发生在IE7-8</p>
</li>
<li><p>DOM&amp;BOM等COM对象循环绑定 泄漏发生在IE6-8</p>
</li>
<li><p>定时器(严格上说不能算是泄露，是被闭包持有了，是正常的表现)</p>
</li>
</ol>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>为了预防内存泄露及持有不必要的内存，做到如下几点：</p>
<ol>
<li><p>在使用XMLHttpRequest，定时器等异步对象时，在函数结尾对不需要引用的对象进行释放</p>
</li>
<li><p>在DOM循环引用中，记得在函数结束时对循环引用切断</p>
</li>
</ol>
<p>解除变量的引用不仅有助于消除循环引用现象，而且对垃圾收集也有好处。为了确保有效地回收内存，应该及时解除不再使用的全局对象、全局对象属性以及循环引用变量的引用。</p>
<p>引用：</p>
<p>《JavaScript高级程序设计》4.3 垃圾回收</p>
<p><a href="https://segmentfault.com/q/1010000000414875" target="_blank" rel="external">内存泄漏</a></p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Memory_Management" target="_blank" rel="external">MDN：内存管理</a></p>
<p><a href="http://www.ituring.com.cn/article/109716" target="_blank" rel="external">关于Javascript内存泄露的那些小事儿</a>.</p>
<p><a href="https://www.ibm.com/developerworks/cn/web/wa-jsmemory/" target="_blank" rel="external">了解 JavaScript 应用程序中的内存泄漏</a></p>
<p>推荐：</p>
<p>JavaScript内存分析实战：<a href="https://github.com/CN-Chrome-DevTools/CN-Chrome-DevTools/blob/master/md/Performance-Profiling/javascript-memory-profiling.md" target="_blank" rel="external">JavaScript内存分析</a></p>
<p><a href="http://newhtml.net/v8-garbage-collection/" target="_blank" rel="external">V8 之旅： 垃圾回收器</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文说明了JavaScript中内存的生命周期，以及内存管理与内存泄漏，内存泄漏的常见情况和解决办法。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://thumbsnap.com/i/UhcQVx2r.png?0406&quot; alt=&quot;内存管理与内存泄漏&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="浏览器相关" scheme="http://sheilacat.github.io/categories/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9B%B8%E5%85%B3/"/>
    
    
  </entry>
  
  <entry>
    <title>正向代理与反向代理</title>
    <link href="http://sheilacat.github.io/reverse-proxy/"/>
    <id>http://sheilacat.github.io/reverse-proxy/</id>
    <published>2016-04-05T02:57:00.000Z</published>
    <updated>2016-10-08T12:24:45.617Z</updated>
    
    <content type="html"><![CDATA[<h2 id="正向代理"><a href="#正向代理" class="headerlink" title="正向代理"></a>正向代理</h2><h3 id="使用正向代理的主要原因"><a href="#使用正向代理的主要原因" class="headerlink" title="使用正向代理的主要原因"></a>使用正向代理的主要原因</h3><ol>
<li><p>访问本无法访问的服务器</p>
<p> 代理服务器代替用户通过其他路由器节点进行访问服务器，从而得到服务器的数据。<br> 例如翻墙，翻墙除了正向代理，还使用了VPN技术。</p>
</li>
</ol>
<a id="more"></a>
<ol>
<li><p>加速访问服务器</p>
<p> 现在带宽流量的飞速发展，这个原因很少了。早期的正向代理中，很多人使用这个就是为了提速。</p>
</li>
<li><p>缓存作用</p>
</li>
<li><p>客户端授权</p>
<p> 采用正向代理服务器来授权用户是否有权限访问互联网。</p>
</li>
<li><p>隐藏访问者的行踪</p>
<p> 代替服务器替用户访问服务器，服务器并不知道真正访问它的是用户。</p>
</li>
</ol>
<p>我们总结一下 正向代理是一个位于客户端和原始服务器(<code>origin server</code>)之间的服务器，为了从原始服务器取得内容，客户端向代理发送一个请求并指定目标(原始服务器)，然后代理向原始服务器转交请求并将获得的内容返回给客户端。客户端必须设置正向代理服务器，当然前提是要知道正向代理服务器的IP地址，还有代理程序的端口。</p>
<h2 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h2><p>在计算机网络中，反向代理是代理服务器的一种。它根据客户端的请求，从后端的服务器上获取资源，然后再将这些资源返回给客户端。与前向代理不同，<strong>前向代理作为一个媒介将互联网上获取的资源返回给相关联的客户端，而反向代理是在服务器端作为代理使用，而不是客户端。</strong></p>
<p><strong>反向代理正好与正向代理相反，对于客户端而言代理服务器就像是原始服务器，并且客户端不需要进行任何特别的设置。客户端向反向代理的命名空间(<code>name-space</code>)中的内容发送普通请求，接着反向代理将判断向何处(原始服务器)转交请求，并将获得的内容返回给客户端。</strong></p>
<p>反向代理的主要作用为：</p>
<ul>
<li>加密和SSL加速</li>
<li>负载均衡</li>
<li>缓存静态内容</li>
<li>压缩</li>
<li>减速上传</li>
<li>安全</li>
<li>外网发布</li>
</ul>
<p>保护和隐藏原始资源服务器与负载均衡。</p>
<h2 id="透明代理"><a href="#透明代理" class="headerlink" title="透明代理"></a>透明代理</h2><p>透明代理的意思是客户端根本不需要知道有代理服务器的存在，它改编你的<code>request fields</code>（报文），并会传送真实IP。注意，加密的透明代理则是属于匿名代理，意思是不用设置使用代理了。<br>透明代理实践的例子就是时下很多公司使用的行为管理软件。</p>
<p><img src="http://thumbsnap.com/i/aKzz0mA8.png?0404" alt="透明代理"></p>
<p>用户A和用户B并不知道行为管理设备充当透明代理行为，当用户A或用户B向服务器A或服务器B提交请求的时候，透明代理设备根据自身策略拦截并修改用户A或B的报文，并作为实际的请求方，向服务器A或B发送请求，当接收信息回传，透明代理再根据自身的设置把允许的报文发回至用户A或B，如上图，如果透明代理设置不允许访问服务器B，那么用户A或者用户B就不会得到服务器B的数据。</p>
<p>参见：<br><a href="http://z00w00.blog.51cto.com/515114/1031287" target="_blank" rel="external">图解正向代理、反向代理、透明代理</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;正向代理&quot;&gt;&lt;a href=&quot;#正向代理&quot; class=&quot;headerlink&quot; title=&quot;正向代理&quot;&gt;&lt;/a&gt;正向代理&lt;/h2&gt;&lt;h3 id=&quot;使用正向代理的主要原因&quot;&gt;&lt;a href=&quot;#使用正向代理的主要原因&quot; class=&quot;headerlink&quot; title=&quot;使用正向代理的主要原因&quot;&gt;&lt;/a&gt;使用正向代理的主要原因&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;访问本无法访问的服务器&lt;/p&gt;
&lt;p&gt; 代理服务器代替用户通过其他路由器节点进行访问服务器，从而得到服务器的数据。&lt;br&gt; 例如翻墙，翻墙除了正向代理，还使用了VPN技术。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="网络知识" scheme="http://sheilacat.github.io/categories/%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86/"/>
    
    
  </entry>
  
  <entry>
    <title>重绘与重排</title>
    <link href="http://sheilacat.github.io/repaint-and-reflow/"/>
    <id>http://sheilacat.github.io/repaint-and-reflow/</id>
    <published>2016-04-01T06:14:00.000Z</published>
    <updated>2016-09-18T07:05:05.647Z</updated>
    
    <content type="html"><![CDATA[<p>先阅读<strong><em>浏览器渲染机制</em></strong>，在浏览器渲染中会进行重绘与重排。</p>
<a id="more"></a>
<p>先阅读<strong><em>浏览器渲染机制</em></strong>，在浏览器渲染中会进行重绘与重排。</p>
<h2 id="重排与重绘"><a href="#重排与重绘" class="headerlink" title="重排与重绘"></a>重排与重绘</h2><ol>
<li><p>当render tree中的一部分(或全部)因为元素的规模尺寸，布局，隐藏等改变而需要重新构建。这就称为重排(reflow)。每个页面至少需要一次重排，就是在页面第一次加载的时候。在重排的时候，浏览器会使渲染树中受到影响的部分失效，并重新构造这部分渲染树，完成重排后，浏览器会重新绘制受影响的部分到屏幕中，该过程成为重绘。</p>
</li>
<li><p>当render tree中的一些元素需要更新属性，而这些属性只是影响元素的外观，风格，而不会影响布局的，比如background-color。则就叫称为重绘。</p>
</li>
</ol>
<p>注意：重排必将引起重绘，而重绘不一定会引起重排。</p>
<h2 id="重排何时发生"><a href="#重排何时发生" class="headerlink" title="重排何时发生"></a>重排何时发生</h2><p>当页面布局和几何属性改变时就需要重排。下述情况会发生浏览器重排：</p>
<ol>
<li><p>添加或者删除可见的DOM元素；</p>
</li>
<li><p>元素位置改变；</p>
</li>
<li><p>元素尺寸改变——边距、填充、边框、宽度和高度</p>
</li>
<li><p>内容改变——比如文本改变或者图片大小改变而引起的计算值宽度和高度改变；</p>
</li>
<li><p>页面渲染初始化；</p>
</li>
<li><p>浏览器窗口尺寸改变——resize事件发生时；</p>
</li>
</ol>
<p>重排的花销跟DOM节点所处的层次有关系，层级越高，开销越大。</p>
<p>以上只是简单列举了出现重排和重绘的情况，附两篇进行详尽列举的文章：</p>
<ul>
<li><p>在JavaScript中会引起强制重排和重绘的相关属性和方法：<a href="https://gist.github.com/paulirish/5d52fb081b3570c81e3a" target="_blank" rel="external">What forces layout / reflow</a></p>
</li>
<li><p>在CSS中能触发布局、绘制或渲染层合并的属性：<a href="https://csstriggers.com/" target="_blank" rel="external">csstriggers</a></p>
</li>
</ul>
<h2 id="flush队列"><a href="#flush队列" class="headerlink" title="flush队列"></a>flush队列</h2><p>重排和重绘很容易被引起，而且重排的花销也不小，如果每句JS操作都去重排重绘的话，浏览器可能就会受不了。所以很多浏览器都会优化这些操作，浏览器会维护1个队列，把所有会引起重排、重绘的操作放入这个队列，等队列中的操作到了一定的数量或者到了一定的时间间隔，浏览器就会flush队列，进行一个批处理。这样就会让多次的重排、重绘变成一次重排重绘。</p>
<p>虽然有了浏览器的优化，但有时候我们写的一些代码可能会强制浏览器提前flush队列，这样浏览器的优化可能就起不到作用了。当你请求向浏览器请求一些 style信息的时候，就会让浏览器flush队列，比如：</p>
<ol>
<li><p>offsetTop, offsetLeft, offsetWidth, offsetHeight</p>
</li>
<li><p>scrollTop/Left/Width/Height</p>
</li>
<li><p>clientTop/Left/Width/Height</p>
</li>
<li><p>width,height</p>
</li>
<li><p>请求了getComputedStyle(), 或者 IE的 currentStyle</p>
</li>
</ol>
<p>当你请求上面的一些属性的时候，浏览器为了给你最精确的值，需要flush队列，因为队列中可能会有影响到这些值的操作。即使你获取元素的布局和样式信息跟最近发生或改变的布局信息无关，浏览器都会强行刷新渲染队列。</p>
<h2 id="如何减少重排、重绘"><a href="#如何减少重排、重绘" class="headerlink" title="如何减少重排、重绘"></a>如何减少重排、重绘</h2><p>减少重排、重绘其实就是需要减少对render tree的操作（合并多次多DOM和样式的修改），并减少对一些style信息的请求，尽量利用好浏览器的优化策略。具体方法有：</p>
<ul>
<li><p>不要单独操作对DOM元素的样式修改，直接改变className，如果动态改变样式，则使用cssText（考虑没有优化的浏览器）</p>
</li>
<li><p>让要操作的元素进行”离线处理”，处理完后一起更新</p>
<p>  <em>a)</em> 使用DocumentFragment进行缓存操作,引发一次重排和重绘；</p>
<p>  <em>b)</em> 使用display:none技术，只引发两次重排和重绘；</p>
<p>  <em>c)</em> 使用cloneNode(true or false) 和 replaceChild 技术，引发一次重排和重绘；</p>
</li>
<li><p>将需要多次重排的元素，position属性设为absolute或fixed，这样此元素就脱离了文档流，它的变化不会影响到其他元素。例如有动画效果的元素就最好设置为绝对定位。</p>
</li>
<li><p>将新建的dom节点操作完毕后在插入到body中。</p>
</li>
<li><p>避免强制同步布局事件的发生：尽量不要在布局信息改变时做查询（会导致渲染队列强制刷新）。</p>
</li>
<li><p>尽可能避免触发布局：</p>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">.box &#123;</div><div class="line">  width: <span class="number">20</span>px;</div><div class="line">  height: <span class="number">20</span>px;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Changing width and height</div><div class="line"> * triggers layout.</div><div class="line"> */</div><div class="line">.box--expanded &#123;</div><div class="line">  width: <span class="number">200</span>px;</div><div class="line">  height: <span class="number">350</span>px;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><p>使用flexbox替代老的布局模型。</p>
</li>
<li><p>避免快速连续的布局：不要经常访问会引起浏览器flush队列的属性，如果你确实要访问，利用先读后写的原则。</p>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">resizeAllParagraphsToMatchBlockWidth</span>(<span class="params"></span>) </span>&#123;</div><div class="line"></div><div class="line">  <span class="comment">// Puts the browser into a read-write-read-write cycle.</span></div><div class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; paragraphs.length; i++) &#123;</div><div class="line">    paragraphs[i].style.width = box.offsetWidth + <span class="string">'px'</span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们使用<code>先读后写</code>的原则，来修复上述代码中的问题：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Read.</span></div><div class="line"><span class="keyword">var</span> width = box.offsetWidth;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">resizeAllParagraphsToMatchBlockWidth</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; paragraphs.length; i++) &#123;</div><div class="line">    <span class="comment">// Now write.</span></div><div class="line">    paragraphs[i].style.width = width + <span class="string">'px'</span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="引用："><a href="#引用：" class="headerlink" title="引用："></a>引用：</h4><p><a href="http://www.css88.com/archives/4996" target="_blank" rel="external">页面重绘和回流以及优化</a></p>
<p><a href="http://www.cnblogs.com/zichi/p/4720000.html" target="_blank" rel="external">高性能JavaScript 重排与重绘</a></p>
<p><a href="http://www.phpied.com/rendering-repaint-reflowrelayout-restyle/" target="_blank" rel="external">Rendering: repaint, reflow/relayout, restyle</a></p>
<p><a href="https://developers.google.com/web/fundamentals/performance/rendering/avoid-large-complex-layouts-and-layout-thrashing?hl=en" target="_blank" rel="external">Avoid large, complex layouts and layout thrashing
</a></p>
<p><a href="https://developers.google.com/web/fundamentals/performance/rendering/avoid-large-complex-layouts-and-layout-thrashing?hl=ch" target="_blank" rel="external">中文翻译 避免大规模、复杂的布局
</a></p>
<h4 id="推荐阅读："><a href="#推荐阅读：" class="headerlink" title="推荐阅读："></a>推荐阅读：</h4><p><a href="http://www.ruanyifeng.com/blog/2015/09/web-page-performance-in-depth.html" target="_blank" rel="external">网页性能管理详解</a></p>
<blockquote>
<p>这篇文章讲到了使用<code>window.requestAnimationFrame()</code>和<code>window.requestIdleCallback()</code>来调节浏览器重新渲染的时间点。</p>
<p>另外，这篇文章中，所提到的，不要在写操作之后紧跟一个读操作。也就是<code>flush队列</code>中提到的，本来是会攒一堆重绘重排操作，但紧跟一个读操作之后，为了给你一个准确值，就会立即进行重绘重排。</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;先阅读&lt;strong&gt;&lt;em&gt;浏览器渲染机制&lt;/em&gt;&lt;/strong&gt;，在浏览器渲染中会进行重绘与重排。&lt;/p&gt;
    
    </summary>
    
      <category term="浏览器相关" scheme="http://sheilacat.github.io/categories/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9B%B8%E5%85%B3/"/>
    
    
  </entry>
  
  <entry>
    <title>浏览器渲染机制</title>
    <link href="http://sheilacat.github.io/browser-rendering-mechanism/"/>
    <id>http://sheilacat.github.io/browser-rendering-mechanism/</id>
    <published>2016-04-01T03:01:00.000Z</published>
    <updated>2016-09-18T07:04:54.947Z</updated>
    
    <content type="html"><![CDATA[<p>简要介绍了浏览器渲染的原理，以及CSS和JavaScript的加载。简要介绍了重绘和重排，以及减少重绘重排的一些方法。</p>
<a id="more"></a>
<h2 id="浏览器显示页面的原理"><a href="#浏览器显示页面的原理" class="headerlink" title="浏览器显示页面的原理"></a>浏览器显示页面的原理</h2><ul>
<li>获取HTML 文档及样式表文件</li>
<li>解析成对应的树形数据结构<ul>
<li>DOM tree</li>
<li>CSSOM tree</li>
</ul>
</li>
<li>计算可见节点形成render tree</li>
<li>计算DOM 的形状及位置进行布局</li>
<li>将每个节点转化为实际像素绘制到视口上（栅格化）</li>
</ul>
<p><code>render tree</code>（页面上所显示的最终结果）是由<code>DOM tree</code>（开发工具中所显示的HTML 所定义的内容结构）与<code>CSSOM tree</code>（样式表所定义的规则结构）合并并剔除不可见的节点所形成的，其中不包含如下节点:</p>
<ul>
<li>本身不可见的<ul>
<li><code>&lt;html&gt;</code></li>
<li><code>&lt;head&gt;</code></li>
<li><code>&lt;meta&gt;</code></li>
<li><code>&lt;link&gt;</code></li>
<li><code>&lt;style&gt;</code></li>
<li><code>&lt;script&gt;</code></li>
</ul>
</li>
<li>设置了<code>display: none;</code>样式的</li>
</ul>
<p>浏览器工作大致流程：</p>
<p><img src="http://thumbsnap.com/s/jbVYmtcJ.jpg?0331" alt="浏览器工作"></p>
<h2 id="浏览器加载和渲染HTML的顺序"><a href="#浏览器加载和渲染HTML的顺序" class="headerlink" title="浏览器加载和渲染HTML的顺序"></a>浏览器加载和渲染HTML的顺序</h2><ol>
<li><p>IE下载的顺序是从上到下，渲染的顺序也是从上到下，下载和渲染是同时进行的。</p>
</li>
<li><p>在渲染到页面的某一部分时，其上面的所有部分都已经下载完成（并不是说所有相关联的元素都已经下载完）</p>
</li>
<li><p>如果遇到语义解释性的标签嵌入文件（JS脚本，CSS样式），那么此时IE的下载过程会启用单独连接进行下载。</p>
</li>
<li><p>并且在下载后进行解析，解析过程中，停止页面所有往下元素的下载。阻塞加载</p>
</li>
<li><p>样式表在下载完成后，将和以前下载的所有样式表一起进行解析，解析完成后，将对此前所有元素（含以前已经渲染的）重新进行渲染。</p>
</li>
<li><p>JS、CSS中如有重定义，后定义函数将覆盖前定义函数</p>
</li>
</ol>
<h2 id="JavaScript的加载"><a href="#JavaScript的加载" class="headerlink" title="JavaScript的加载"></a>JavaScript的加载</h2><ol>
<li>不能并行下载和解析（阻塞下载）</li>
<li>当引用了JS的时候，浏览器发送1个js request就会一直等待该request的返回。因为浏览器需要1个稳定的DOM树结构，而JS中很有可能有代码直接改变了DOM树结构，比如使用 document.write 或 appendChild,甚至是直接使用的location.href进行跳转，浏览器为了防止出现JS修改DOM树，需要重新构建DOM树的情况，所以 就会阻塞其他的下载和呈现.</li>
</ol>
<h2 id="解析CSS"><a href="#解析CSS" class="headerlink" title="解析CSS"></a>解析CSS</h2><p><img src="http://thumbsnap.com/i/iiFti0rb.png?0331" alt="解析CSS"></p>
<h2 id="Reflow-amp-Repaint"><a href="#Reflow-amp-Repaint" class="headerlink" title="Reflow &amp; Repaint"></a>Reflow &amp; Repaint</h2><p><code>Reflow</code>的成本比<code>Repaint</code>的成本高得多。DOM Tree里的每个结点都会有<code>reflow</code>方法，一个结点的<code>reflow</code>很有可能导致子结点、甚至父结点以及同级结点的<code>reflow</code>。</p>
<p>所以，下面这些动作有很大可能会是成本比较高的：</p>
<ul>
<li>当你增加、删除、修改DOM结点时，会导致Reflow或Repaint</li>
<li>当你移动DOM的位置，或是搞个动画的时候。</li>
<li>当你修改CSS样式的时候。</li>
<li>当你Resize窗口的时候（移动端没有这个问题），或是滚动的时候。</li>
<li>当你修改网页的默认字体时。</li>
</ul>
<p>基本上来说，reflow有如下的几个原因：</p>
<ul>
<li>Initial。网页初始化的时候。</li>
<li>Incremental。一些Javascript在操作DOM Tree时。</li>
<li>Resize。其些元件的尺寸变了。</li>
<li>StyleChange。如果CSS的属性发生变化了。</li>
<li>Dirty。几个Incremental的reflow发生在同一个frame的子树上。</li>
</ul>
<p>当然，我们的浏览器是聪明的，它不会你每改一次样式，它就reflow或repaint一次。一般来说，浏览器会把这样的操作积攒一批，然后做一次reflow，这又叫异步reflow或增量异步reflow。但是有些情况浏览器是不会这么做的，比如：resize窗口，改变了页面默认的字体，等。对于这些操作，浏览器会马上进行reflow。</p>
<p>但是有些时候，我们的脚本会阻止浏览器这么干，比如：如果我们请求下面的一些DOM值：</p>
<ul>
<li>offsetTop, offsetLeft, offsetWidth, offsetHeight</li>
<li>scrollTop/Left/Width/Height</li>
<li>clientTop/Left/Width/Height</li>
<li>IE中的 getComputedStyle(), 或 currentStyle</li>
</ul>
<p>因为，如果我们的程序需要这些值，那么浏览器需要返回最新的值，而这样一样会flush出去一些样式的改变，从而造成频繁的reflow/repaint。</p>
<h2 id="减少reflow-repaint"><a href="#减少reflow-repaint" class="headerlink" title="减少reflow/repaint"></a>减少reflow/repaint</h2><p>下面是一些Best Practices：</p>
<p>1）不要一条一条地修改DOM的样式。与其这样，还不如预先定义好css的class，然后修改DOM的className。</p>
<p>2）把DOM离线后修改。如：</p>
<ul>
<li>使用documentFragment 对象在内存里操作DOM</li>
<li>先把DOM给display:none(有一次reflow)，然后你想怎么改就怎么改。比如修改100次，然后再把他显示出来。<br>clone一个DOM结点到内存里，然后想怎么改就怎么改，改完后，和在线的那个的交换一下。</li>
</ul>
<p>3）不要把DOM结点的属性值放在一个循环里当成循环里的变量。不然这会导致大量地读写这个结点的属性。</p>
<p>4）尽可能的修改层级比较低的DOM。当然，改变层级比较底的DOM有可能会造成大面积的reflow，但是也可能影响范围很小。</p>
<p>5）为动画的HTML元件使用fixed或absoult的position，那么修改他们的CSS是不会reflow的。</p>
<p>6）千万不要使用table布局。因为可能很小的一个小改动会造成整个table的重新布局。</p>
<p>参考:<br><a href="http://coolshell.cn/articles/9666.html" target="_blank" rel="external">浏览器的渲染原理简介</a></p>
<p>拓展阅读：<br><a href="https://developers.google.com/speed/docs/insights/rules?csw=1#header" target="_blank" rel="external">PageSpeed Insights规则</a></p>
<p><a href="https://developer.yahoo.com/performance/rules.html" target="_blank" rel="external">Best Practices for Speeding Up Your Web Site</a></p>
<p>推荐阅读：</p>
<p><a href="http://taligarsiel.com/Projects/howbrowserswork1.htm" target="_blank" rel="external">How browsers work</a></p>
<p>中文翻译：<a href="http://my.oschina.net/anna153/blog/377259#OSC_h2_18" target="_blank" rel="external">浏览器是怎样工作的</a></p>
<p><a href="http://div.io/topic/609" target="_blank" rel="external">从FE的角度上再看输入url后都发生了什么</a></p>
<p><a href="http://blog.jobbole.com/84870/" target="_blank" rel="external">当你在浏览器中输入Google.com并且按下回车之后发生了什么？</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;简要介绍了浏览器渲染的原理，以及CSS和JavaScript的加载。简要介绍了重绘和重排，以及减少重绘重排的一些方法。&lt;/p&gt;
    
    </summary>
    
      <category term="浏览器相关" scheme="http://sheilacat.github.io/categories/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9B%B8%E5%85%B3/"/>
    
    
  </entry>
  
  <entry>
    <title>JavaScript异步编程</title>
    <link href="http://sheilacat.github.io/javascript-asynchronous-programming/"/>
    <id>http://sheilacat.github.io/javascript-asynchronous-programming/</id>
    <published>2016-03-23T15:51:22.000Z</published>
    <updated>2016-10-08T12:25:24.009Z</updated>
    
    <content type="html"><![CDATA[<p>如果你想要更正式一点的 JavaScript 语言介绍，请揣摩Marijn Haverbeke 的Eloquent JavaScript一书 。<br>如果你只是JavaScript的初学者，想按部就班提高，避免掉入常见的陷阱，请花点时间看看 JavaScript Garden。</p>
<a id="more"></a>
<h1 id="深入理解JavaScript事件"><a href="#深入理解JavaScript事件" class="headerlink" title="深入理解JavaScript事件"></a>深入理解JavaScript事件</h1><h2 id="JavaScript异步事件模型"><a href="#JavaScript异步事件模型" class="headerlink" title="JavaScript异步事件模型"></a>JavaScript异步事件模型</h2><h3 id="事件的调度"><a href="#事件的调度" class="headerlink" title="事件的调度"></a>事件的调度</h3><p>如果想让JS中的某段代码将来再运行，可以将它放在回调中。</p>
<p>回调就是一种普通函数，只不过它是传给像<code>setTimeout</code>这样的函数，或者绑定为像`document.onready这样的属性。运行回调时，我们称已触发某事件（譬如延时结束或页面加载完毕）。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> ( <span class="keyword">var</span> i = <span class="number">1</span>; i &lt;= <span class="number">3</span>; i++) &#123;</div><div class="line">setTimeout( <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="built_in">console</span>.log(i); &#125;, <span class="number">0</span>);</div><div class="line">&#125;;</div><div class="line"><span class="number">4</span></div><div class="line"><span class="number">4</span></div><div class="line"><span class="number">4</span></div></pre></td></tr></table></figure>
<p>JavaScript事件处理器在线程空闲之前不会运行。</p>
<h3 id="线程的阻塞"><a href="#线程的阻塞" class="headerlink" title="线程的阻塞"></a>线程的阻塞</h3><h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><p>调用 setTimeout 的时候，会有一个延时事件排入队列。然后setTimeout调用之后的那行代码运行，接着是再下一行代码，直到再也没有任何代码。这时JavaScript虚拟机才会问：“队列里都有谁啊？”</p>
<p>如果队列中至少有一个事件适合于“触发”，则虚拟机会挑选一个事件，并调用此事件的处理器。事件处理器返回后，我们又回到队列处。</p>
<p>输入事件的工作方式完全一样：用户单击一个已附加有单击事件处理器的DOM（Document Object Model ，文档对象模型）元素时，会有一个单击事件排入队列。但是，该单击事件处理器要等到当前所有正在运行的代码均已结束后（可能还要等其他此前已排队的事件也依次结束）才会执行。因此，使用 JavaScript的那些网页一不小心就会变得毫无反应。</p>
<h2 id="异步函数的类型"><a href="#异步函数的类型" class="headerlink" title="异步函数的类型"></a>异步函数的类型</h2><p>JavaScript环境提供的异步函数通常可以分为两大类：I/O函数和计时函数。如果想在应用中定义复杂的异步行为，就要使用这两类异步函数作为基本的构造块。</p>
<p>console.log是异步的吗？<br>WebKit的<code>console.log</code>由于表现出异步行为而让很多开发者惊诧不已。在Chrome或Safari中，以下这段代码会在控制台记录<br>{foo:bar}。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> obj = &#123;&#125;;</div><div class="line"><span class="built_in">console</span>.log(obj);</div><div class="line">obj.foo = <span class="string">'bar '</span>;</div></pre></td></tr></table></figure></p>
<p>怎么会这样？ WebKit 的console.log 并没有立即拍摄对象快照，相反，它只存储了一个指向对象的引用，然后在代码返回事件队列时才去拍摄快照。<br>Node 的console.log 是另一回事，它是严格同步的，因此同样的代码输出的却为 {} 。</p>
<p><code>setTimeout</code>和<code>setInterval</code>就是故意设计成慢吞吞的。事实上，HTML规范推行的延时/时隔的最小值就是4毫秒。</p>
<p>那么，如果需要更细粒度的计时，该怎么办呢？有些运行时环境提供了备选方案。</p>
<p>&gt;<br>尽管这些计时函数是异步 JavaScript 混饭吃的家伙什儿，但永远不要忘记， setTimeout 和setInterval 就是些不精确的计时工具。在Node 中，如果只是想产生一个短时延迟，请使用 process.nextTick 。在浏览器端， 请尝试使用垫片技术（ shim ） ③ ： 在支持requestAnimationFrame 的浏览器中， 推荐使用requestAnimationFrame ；在不支持requestAnimationFrame 的浏览器中，则退而使用 setTimeout 。</p>
<h3 id="何时称函数为异步的"><a href="#何时称函数为异步的" class="headerlink" title="何时称函数为异步的"></a>何时称函数为异步的</h3><p>调用一个函数时，程序只在该函数返回之后才能继续。</p>
<p>JS写手如果称一个函数为“异步”的，其意思是这个函数会导致将来再运行另一个函数，后者取自于事件队列（若后面这个函数是作为参数传递给前者的，则称其为回调函数，简称为回调）。</p>
<p>异步函数还涉及另一个术语，即非阻塞。非阻塞这个词强调了异步函数的高速度：异步MySQL数据库驱动程序做一个查询可能要花上一小时，但负责发送查询请求的那个函数却能以微秒级速度返回。这对于那些需要快速处理海量请求的网站服务器来说，绝对是个福音。</p>
<h3 id="回调内抛出的错误"><a href="#回调内抛出的错误" class="headerlink" title="回调内抛出的错误"></a>回调内抛出的错误</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">setTimeoout(<span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params"></span>) </span>&#123;</div><div class="line">     setTimeout(<span class="function"><span class="keyword">function</span> <span class="title">B</span>(<span class="params"></span>)</span>&#123;</div><div class="line">          setTimeout(<span class="function"><span class="keyword">function</span> <span class="title">C</span>(<span class="params"></span>)</span>&#123;</div><div class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Something terrible has happend!'</span>);</div><div class="line">          &#125;, <span class="number">0</span>);</div><div class="line">     &#125;, <span class="number">0</span>);</div><div class="line">), <span class="number">0</span>&#125;;</div></pre></td></tr></table></figure>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&lt;&lt;Error: Something terrible has happened!</div><div class="line">     at Timer<span class="selector-class">.C</span> (/AsyncJS/nestedErrors<span class="selector-class">.js</span>:<span class="number">4</span>:<span class="number">13</span>)</div></pre></td></tr></table></figure>
<p>因为运行C的时候，A和B并不在内存堆栈里。这3个函数都是从事件队列直接运行的。<br>基于同样的理由，<strong><em>利用try/catch语句块并不能捕获从异步回调中抛出的错误。</em></strong>下面进行演示：（这就是为什么throw很少用作回调内错误处理的正确工具。)</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">setTimeout( <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">     <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>( <span class="string">'Catch me if you can!'</span>);</div><div class="line">&#125;, <span class="number">0</span>);</div><div class="line">&#125; <span class="keyword">catch</span> (e) &#123;</div><div class="line"><span class="built_in">console</span>.error(e);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight monkey"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Uncaught <span class="built_in">Error</span>: <span class="keyword">Catch</span> me <span class="keyword">if</span> you can!</div><div class="line">     (anonymous <span class="function"><span class="keyword">function</span>) @ <span class="title">VM192473</span>:</span><span class="number">4</span></div></pre></td></tr></table></figure>
<p>看到这里的问题了吗？这里的 try/catch 语句块只捕获 setTimeout函数自身内部发生的那些错误。因为 setTimeout 异步地运行其回调，所以即使延时设置为 0 ，回调抛出的错误也会直接流向应用程序的未捕获异常处理器。</p>
<p>Node.js对于捕获异步回调函数错误的方法是，它的回调几乎总是接受一个错误作为其首个参数，这样就允许回调自己来决定如何处理这个错误。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">' fs'</span>);</div><div class="line">fs.readFile(<span class="string">' fhgwgdz.txt'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err, data</span>) </span>&#123;</div><div class="line"><span class="keyword">if</span> (err) &#123;</div><div class="line"><span class="keyword">return</span> <span class="built_in">console</span>.error(err);</div><div class="line">&#125;;</div><div class="line"><span class="built_in">console</span>.log(data.toString(<span class="string">' utf8'</span>));</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>可客户端JavaScript库的一致性要稍微差些，不过最常见的模式是，针对成败这两种情况各规定一个单独的回调。jQuery的Ajax方法就遵循了这个模式：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$.get(<span class="string">' /data'</span>, &#123;</div><div class="line">success: successHandler,</div><div class="line">failure: failureHandler</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>不管 API形态像什么，始终要记住的是，<strong><em>只能在回调内部处理源于回调的异步错误。</em></strong></p>
<h3 id="未捕获异常的处理"><a href="#未捕获异常的处理" class="headerlink" title="未捕获异常的处理"></a>未捕获异常的处理</h3><h4 id="在浏览器环境中"><a href="#在浏览器环境中" class="headerlink" title="在浏览器环境中"></a>在浏览器环境中</h4><p>现代浏览器会在开发人员控制台显示那些未捕获的异常，接着返回事件队列。可以给<code>window.onerror</code>附加一个处理器。如果<code>window.onerror</code>处理器返回<code>true</code>，则能阻止浏览器的默认错误处理行为（直接忽略所有错误）。</p>
<h4 id="在Node-js环境中"><a href="#在Node-js环境中" class="headerlink" title="在Node.js环境中"></a>在Node.js环境中</h4><p>在 Node 环境中， window.onerror 的类似物就是 process对象的uncaughtException 事件。正常情况下， Node应用会因未捕获的异常而立即退出。但只要至少还有一个 uncaughtException 事件处理器， Node 应用就会直接返回事件队列。</p>
<p>但是，自 Node 0.8.4 起，uncaughtException 事件就被废弃了。</p>
<p>&gt;<br>对异常处理而言， uncaughtException 是一种非常粗暴的机制，<br>它在将来可能会被放弃……<br>请勿使用 uncaughtException ，而应使用Domain 对象。</p>
<p>Domain 对象又是什么？你可能会这样问。 Domain 对象是事件化对象，它将 throw 转化为’error’ 事件。下面是一个例子。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> myDomain = <span class="built_in">require</span>(<span class="string">' domain'</span>).create();</div><div class="line">myDomain.run( <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">setTimeout( <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">     <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">' Listen to me!'</span>)</div><div class="line">&#125;, <span class="number">50</span>);</div><div class="line">&#125;);</div><div class="line">myDomain.on(<span class="string">' error'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</div><div class="line">     <span class="built_in">console</span>.log(<span class="string">' Error ignored!'</span>);</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>源于延时事件的 throw 只是简单地触发了 Domain 对象的错误处理器。</p>
<p>&lt;&lt;Error ignored!</p>
<p>不管在浏览器端还是服务端，全局的异常处理器都应被视作最后一根救命稻草，请仅在调试时才使用它。</p>
<p>补充：</p>
<p>因为本书当时出版时，nodejs的版本还不高。Domain对象仅作为一种实验性对象。<br>nodejs中处理回调函数的异常：<a href="http://blog.csdn.net/newjueqi/article/details/41278177" target="_blank" rel="external">http://blog.csdn.net/newjueqi/article/details/41278177</a><br>nodejs异常捕获的一些实践：<a href="http://www.uml.org.cn/AJAX/201407115.asp" target="_blank" rel="external">http://www.uml.org.cn/AJAX/201407115.asp</a></p>
<h3 id="JavaScript的多线程性"><a href="#JavaScript的多线程性" class="headerlink" title="JavaScript的多线程性"></a>JavaScript的多线程性</h3><p>JavaScript 中存在一种多线程性：可以孵化出 Worker进程。每个孵化出的进程都可以与其他进程交换数据，其限制等同于任何其他 I/O 进程。Worker 对象使得我们有可能利用多个内核，同时不会破坏 JavaScript 的游戏规则（代码不可能被中断；变量只有处于其作用域内部时才是可访问的）。</p>
<h1 id="分布式事件"><a href="#分布式事件" class="headerlink" title="分布式事件"></a>分布式事件</h1><h2 id="Pub-Sub模式（发布-订阅模式）"><a href="#Pub-Sub模式（发布-订阅模式）" class="headerlink" title="Pub/Sub模式（发布/订阅模式）"></a>Pub/Sub模式（发布/订阅模式）</h2><p>Node的EventEmitter对象（事件发生器，其他对象可以继承它；Node中几乎所有的I/O源都是EventEmitter对象：文件流、HTTP服务器，甚至是应用进程本身）、Backbone的事件化模型和jQuery的自定义事件。在这些工具的帮助下，我们能解嵌套那些嵌套式回调，减少重复冗余，最终编写出易于理解的事件驱动型代码。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">PubSub = &#123;handlers: &#123;&#125;&#125;;</div><div class="line"></div><div class="line">PubSub.on = <span class="function"><span class="keyword">function</span>(<span class="params">eventType, handler</span>) </span>&#123;</div><div class="line"><span class="keyword">if</span> (!(eventType <span class="keyword">in</span> <span class="keyword">this</span>.handlers)) &#123;</div><div class="line"><span class="keyword">this</span>.handlers[eventType] = [];</div><div class="line">&#125;</div><div class="line"><span class="keyword">this</span>.handlers[eventType].push(handler);</div><div class="line"><span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">&#125;</div><div class="line">PubSub.emit = <span class="function"><span class="keyword">function</span>(<span class="params">eventType</span>) </span>&#123;</div><div class="line"><span class="keyword">var</span> handlerArgs = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>);</div><div class="line"><span class="keyword">for</span> ( <span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.handlers[eventType].length; i++) &#123;</div><div class="line">     <span class="keyword">this</span>.handlers[eventType][i].apply(<span class="keyword">this</span>, handlerArgs);</div><div class="line">&#125;</div><div class="line"><span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="事件化模型"><a href="#事件化模型" class="headerlink" title="事件化模型"></a>事件化模型</h2><p>JavaScript确实没有一种每当对象变化时就触发事件的机制。因此，事件化模型要是想工作的话，必须要使用一些像Backbone.js的set/get这样的方法。</p>
<h1 id="Promise对象和Deferred对象"><a href="#Promise对象和Deferred对象" class="headerlink" title="Promise对象和Deferred对象"></a>Promise对象和Deferred对象</h1><p>jQuery1.5所有Ajax函数（$.ajax、$.get及$.post）现在都会返回Promise对象。Promise对象代表一项有两种可能结果（成功或失败）的任务，它还持有多个回调，出现不同结果时会分别触发相应的回调。</p>
<p>jQuery1.4中的代码必须写成这样：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$.get( <span class="string">'/mydata'</span>, &#123;</div><div class="line">success: onSuccess,</div><div class="line">failure: onFailure,</div><div class="line">always: onAlways</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>而到了jQuery1.5+：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> promise = $.get( <span class="string">'/mydata'</span>);</div><div class="line">promise.done(onSuccess);</div><div class="line">promise.fail(onFailure);</div><div class="line">promise.always(onAlways);</div></pre></td></tr></table></figure></p>
<p>为什么非得在触发Ajax调用之后再附加回调呢？一言以蔽之：封装。如果Ajax调用要实现很多效果，那么仅由负责发出请求的那部分应用代码来处理所有这些效果，显然很拙劣。</p>
<p>不过使用 Promise 对象的最大优势仍然在于，它可以轻松从现有Promise 对象派生出新的 Promise 对象。我们可以要求代表着并行任务的两个 Promise 对象合并成一个 Promise 对象，由后者负责通知前面那些任务都已完成。也可以要求代表着任务系列中首任务的Promise 对象派生出一个能代表任务系列中末任务的 Promise 对象，这样后者就能知道这一系列任务是否均已完成。待会儿我们就会看到， Promise 对象天生就适合用来进行这些操作。</p>
<p>Deferred 是 Promise 的超集，它比 Promise 多了一项关键特性：<strong><em>可以直接触发</em></strong>。纯 Promise 实例只允许添加多个调用，而且必须由其他什么东西来触发这些调用。</p>
<p><strong><em>使用 resolve （执行）方法和 reject（拒绝）方法均可触发 Deferred对象。</em></strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> promptDeferred = <span class="keyword">new</span> $.Deferred();<span class="comment">//生成一个Deferred对象（Promise对象）</span></div><div class="line">promptPromise = promptDeferred.promise();<span class="comment">//生成一个不是Deferred的Promise对象</span></div></pre></td></tr></table></figure>
<p>promptPromise 只是promptDeferred 对象的一个没有resolve /reject 方法的副本。我们把回调绑定至 Deferred 或其下辖的 Promise 并无不同，因为这两个对象本质上分享着同样的回调。它们也分享着同样的 state （返回的状态值为 “pending”、 “resolved”或 “rejected”）。这意味着，对同一个 Deferred 对象生成多个 Promise对象是毫无意义的。事实上， jQuery 给出的只不过是同一个对象。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> promise1 = promptDeferred.promise();</div><div class="line"><span class="keyword">var</span> promise2 = promptDeferred.promise();</div><div class="line"><span class="built_in">console</span>.log(promise1 === promise2); <span class="comment">// true</span></div></pre></td></tr></table></figure>
<p>而且，对一个纯 Promise 对象再调用promise 方法，产生的只不过是<br>一个指向相同对象的引用。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(promise1 === promise1.promise()); <span class="comment">// true</span></div></pre></td></tr></table></figure></p>
<h2 id="进度通知"><a href="#进度通知" class="headerlink" title="进度通知"></a>进度通知</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> nanowrimoing = $.Deferred();</div><div class="line"><span class="keyword">var</span> wordGoal = <span class="number">5000</span>;</div><div class="line">nanowrimoing.progress( <span class="function"><span class="keyword">function</span>(<span class="params">wordCount</span>) </span>&#123;</div><div class="line"><span class="keyword">var</span> percentComplete = <span class="built_in">Math</span>.floor(wordCount / wordGoal * <span class="number">100</span>);</div><div class="line">$( <span class="string">'#indicator'</span>).text(percentComplete + <span class="string">'% complete'</span> );</div><div class="line">&#125;);</div><div class="line">nanowrimoing.done (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">     $(<span class="string">' #indicator'</span>).text(<span class="string">'Good job!'</span>);</div><div class="line">&#125;);</div><div class="line">$( <span class="string">'#document'</span>).on(<span class="string">'keypress'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line"><span class="keyword">var</span> wordCount = $(<span class="keyword">this</span>).val().split(<span class="regexp">/\s+/</span>).length;</div><div class="line"><span class="keyword">if</span> (wordCount &gt;= wordGoal) &#123;</div><div class="line">     nanowrimoing.resolve();</div><div class="line">&#125;;</div><div class="line">nanowrimoing.notify(wordCount);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>Deferred 对象的notify （通知）调用会调用我们设定的 progress回调。就像 resolve 和reject 一样， notify 也能接受任意参数。请注意，一旦执行了 nanowrimoing 对象，则再作 nanowrimoing.notify 调用将不会有任何反应，这就像任何额外的 resolve 调用及reject 调用也会被直接无视一样。</p>
<p>Promise 对象接受3 种回调形式： done 、fail 和progress 。执行Promise 对象时，运行的是 done 回调；拒绝 Promise对象时，运行的是 fail 回调；对处于挂起状态的 Deferred 对象调用notify 时，运行的是 progress 回调。</p>
<h2 id="Promise对象的合并"><a href="#Promise对象的合并" class="headerlink" title="Promise对象的合并"></a>Promise对象的合并</h2><p>Promise最终只有两种状态，已执行或已拒绝。Promise如此强大的一个主要原因是，它允许我们把任务当成布尔值来处理。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$.when($.post( &apos;/1&apos;, data1), $.post(&apos;/2&apos;, data2)).then(onPosted, onFailure);</div></pre></td></tr></table></figure>
<p>不过最好不要通过合并后的promise的回调函数来进行参数的处理，相反应该直接向那些传递至when方法的成员Promise对象附加回调来收集相应的结果。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> serverData = &#123;&#125;;</div><div class="line"><span class="keyword">var</span> getting1 = $.get(<span class="string">' /1'</span>).done( <span class="function"><span class="keyword">function</span>(<span class="params">result</span>) </span>&#123;serverData[<span class="string">'1'</span>] = result;&#125;);</div><div class="line"><span class="keyword">var</span> getting2 = $.get( <span class="string">'/2'</span>).done( <span class="function"><span class="keyword">function</span>(<span class="params">result</span>) </span>&#123;serverData[<span class="string">'2'</span>] = result;&#125;);</div><div class="line">$.when(getting1, getting2).done( <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">     <span class="comment">// 获得的信息现在都已位于 serverData ……</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h2 id="管道连接未来"><a href="#管道连接未来" class="headerlink" title="管道连接未来"></a>管道连接未来</h2><p>在 JavaScript 中常常无法便捷地执行一系列异步任务，一个主要原因是无法在第一个任务结束之前就向第二个任务附加处理器。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> getPromise = $.get( <span class="string">'/query'</span>);</div><div class="line">getPromise.done( <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</div><div class="line">     <span class="keyword">var</span> postPromise = $.post( <span class="string">'/search'</span>, data);</div><div class="line">&#125;);</div><div class="line"><span class="comment">// 现在我们想给 postPromise 附加处理器……</span></div></pre></td></tr></table></figure>
<p>jQuery1.6为Promise对象新增pipe方法：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> getPromise = $.get( <span class="string">'/query'</span>);</div><div class="line"><span class="keyword">var</span> postPromise = getPromise.pipe( <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</div><div class="line"><span class="keyword">return</span> $.post( <span class="string">'/search'</span>, data);</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>假设有个 Promise 对象发出的进度通知表示成 0 与1 之间的某个数，则可以使用 pipe 方法生成一个完全相同的 Promise对象，但它发出的进度通知却转变成可读性更高的字符串。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> promise2 = promise1.pipe(<span class="literal">null</span>, <span class="literal">null</span>, <span class="function"><span class="keyword">function</span>(<span class="params">progress</span>) </span>&#123;</div><div class="line">     <span class="keyword">return</span> <span class="built_in">Math</span>.floor(progress * <span class="number">100</span>) + <span class="string">' % complete'</span>;</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>pipe最多能接受3个参数，对应这done、fail和progress。</p>
<p>总的说来， pipe 的回调可以做以下两件事情。</p>
<ul>
<li>如果pipe 回调返回的是 Promise 对象，则pipe 生成的那个 Promise对象会模仿这个 Promise 对象。</li>
<li>如果pipe 回调返回的是非 Promise 对象（值或空白），则 pipe 生成的那个 Promise 对象会立即因该赋值而执行、拒绝或得到通知，具体取决于调用 pipe 的那个初始Promise 对象刚刚发生了什么。</li>
</ul>
<h3 id="jQuery与Promises-A的对比"><a href="#jQuery与Promises-A的对比" class="headerlink" title="jQuery与Promises/A的对比"></a>jQuery与Promises/A的对比</h3><p>jQuery 使用 resolve 作为fail 的反义词，而 Promises/A使用的是 fulfill 。在Promises/A 规范中， Promise 对象不管是已履行还是已失败，都称“已执行”。<br>在 jQuery 1.8 问世之前， jQuery 的then 方法只是一种可以同时调用done 、fail 和 progress 这 3 种回调的速写法，而 Promises/A 的 then在行为上更像是 jQuery 的pipe 。 jQuery 1.8 订正了这个问题，使得then 成为pipe 的同义词。</p>
<h2 id="用Promise对象代替回调函数"><a href="#用Promise对象代替回调函数" class="headerlink" title="用Promise对象代替回调函数"></a>用Promise对象代替回调函数</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> timing = <span class="keyword">new</span> $.Deferred();</div><div class="line">setTimeout(timing.resolve, <span class="number">500</span>);</div></pre></td></tr></table></figure>
<p>考虑到 API 可能会出错，我们还要写一个根据情况指向 resolve 或<br>reject 的回调函数。例如，我们会这样写 Node 风格的回调：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> fileReading = <span class="keyword">new</span> $.Deferred();</div><div class="line">fs.readFile(filename, <span class="string">'utf8'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</div><div class="line"><span class="keyword">if</span> (err) &#123;</div><div class="line">     fileReading.reject(err);</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">     fileReading.resolve(<span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>));</div><div class="line">&#125;;</div><div class="line">&#125;);</div><div class="line">总这么写很麻烦，所以何不写一个工具函数以根据任何给定 Deferred</div><div class="line">对象来生成 Node 风格的回调呢？</div><div class="line"><span class="string">``</span><span class="string">`javascript</span></div><div class="line">deferredCallback = function(deferred) &#123;</div><div class="line">return function(err) &#123;</div><div class="line">if (err) &#123;</div><div class="line">     deferred.reject(err);</div><div class="line">&#125; else &#123;</div><div class="line">     deferred.resolve(Array.prototype.slice.call(arguments, 1));</div><div class="line">&#125;;</div><div class="line">     &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="Async-js的工作流控制"><a href="#Async-js的工作流控制" class="headerlink" title="Async.js的工作流控制"></a>Async.js的工作流控制</h1><p>异步函数序列的运行<code>async.series</code>和异步函数的并行运行<code>async.parallel</code>，任务列表是静态的，一旦调用了他们，就再也不能增减任务了。而且任务处于黑箱状态，除非我们自行从任务内部派发更新信息。<br>只有两个选择，要么是完全没有并发性，要么是不受限制的并发性。这对文件 I/O 任务可是个大问题。如果要操作上千个文件，当然不想因按顺序操作而效率低下，但如果试着并行执行所有操作，又很可能会激怒操作系统。<br>Async.js 提供了一种可以解决上述所有问题的全能方法： async.queue。</p>
<p>async.queue 接受的参数有两个：一个是 worker（办事员）函数，而不是一个函数列表；一个是代表着 concurrency（并发度）的值，代表了办事员最多可同时处理的任务数。</p>
<h1 id="异步的脚本加载"><a href="#异步的脚本加载" class="headerlink" title="异步的脚本加载"></a>异步的脚本加载</h1><ul>
<li><p>异步脚本加载技术，要尽量避免使用内联，如果非得用内联脚本，请勿试图对该脚本使用<code>defer/async</code>属性。</p>
</li>
<li><p>也请勿使用<code>document.write</code></p>
</li>
</ul>
<h2 id="defer（延迟）"><a href="#defer（延迟）" class="headerlink" title="defer（延迟）"></a>defer（延迟）</h2><p><code>defer</code>属性规定是否对脚本执行进行延迟，直到页面加载为止。<br>如果您的脚本不会改变文档的内容（如documen.write），可将defer属性加入到<code>&lt;script&gt;</code>标签中，以便加快处理文档的速度。因为浏览器知道它将能够安全地读取文档的剩余部分而不用执行脚本，它将推迟对脚本的解释，直到文档已经显示给用户为止。</p>
<h2 id="async（异步）"><a href="#async（异步）" class="headerlink" title="async（异步）"></a>async（异步）</h2><p>无序执行脚本。可以在页面需要加入一些小部件脚本时使用。</p>
<p>在那些同时支持这两个属性的浏览器中， async会覆盖掉defer。由于defer有着更广泛的支持，而且具有 async的主要优势（允许在下载脚本的同时进行DOM的渲染），因 此我们建议尽量使用defer代替async。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;如果你想要更正式一点的 JavaScript 语言介绍，请揣摩Marijn Haverbeke 的Eloquent JavaScript一书 。&lt;br&gt;如果你只是JavaScript的初学者，想按部就班提高，避免掉入常见的陷阱，请花点时间看看 JavaScript Garden。&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://sheilacat.github.io/categories/JavaScript/"/>
    
    
  </entry>
  
  <entry>
    <title>《Coffeescript小书》笔记</title>
    <link href="http://sheilacat.github.io/Coffeescript-minibook/"/>
    <id>http://sheilacat.github.io/Coffeescript-minibook/</id>
    <published>2016-03-23T15:25:48.000Z</published>
    <updated>2016-10-08T12:25:41.091Z</updated>
    
    <content type="html"><![CDATA[<h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ul>
<li>简洁、充分地利用空格</li>
<li>有一些优雅的特性，比如列表解析、原型符号别名和类等等，能够有效减少输入</li>
<li>有原则地选择了一些JavaScript的特性，巧妙地避开了JavaScript的一些怪癖</li>
<li>CoffeeScript不是JavaScript的超集</li>
</ul>
<p>为什么CoffeeScript不是超集？阻止其成为超集最直接的原因是在CoffeeScript程序中空格是有意义的。</p>
<a id="more"></a>
<h2 id="劣势"><a href="#劣势" class="headerlink" title="劣势"></a>劣势</h2><ul>
<li>需要编译</li>
</ul>
<p>CoffeeScript也在尝试尽力通过产生优雅的可读性强的JavaScript，以及在服务器端继承自动编译来弥补这个问题。</p>
<h2 id="变量与作用域"><a href="#变量与作用域" class="headerlink" title="变量与作用域"></a>变量与作用域</h2><p>CoffeeScript修复了JavaScript中一个最让人头疼的问题——去阿菊变量。在JavaScript中，一不小心，就很容易在定义变量时遗漏var关键字导致产生全局变量。CoffeeScript使用一个匿名函数把所有脚本都包裹起来，将其限定在局部作用域中，并且为所有的变量赋值前自动添加var。</p>
<p>CoffeeScript还更近了一步，让覆盖一个高一级的变量也很困难。这大量地减少了程序员常犯的错误。</p>
<p>然而，有时候全局变量还是有用的。你可以通过直接给全局对象（浏览器中的window）赋值来获得全局变量，也可以如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">exports = <span class="keyword">this</span></div><div class="line">exports.MyVariable = <span class="string">"foo-bar"</span></div></pre></td></tr></table></figure>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>函数的最后一个表达式会作为隐式的返回值。但仍可使用return。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">func = -&gt; <span class="string">"bar"</span></div></pre></td></tr></table></figure>
<h2 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">times = (a, b) -&gt; a*b</div></pre></td></tr></table></figure>
<p>支持默认参数</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">times =(a = <span class="number">1</span>, b = <span class="number">2</span>) -&gt; a*b</div></pre></td></tr></table></figure>
<p>你还可以使用参数槽（splats）接收多个参数，使用…表示： </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sum = (nums...) -&gt; result = <span class="number">0</span> nums.forEach (n) -&gt; result += n result</div></pre></td></tr></table></figure>
<p>在上面的例子中，nums是一个包含传递给函数全部参数的数组。它不是一个arugments对 象，而是一个真实的数组对象，这样的话在你想操作它的时候就不 不需要先使用 Array.prototype.splice或者jQuery.makeArray()了。</p>
<h2 id="函数调用"><a href="#函数调用" class="headerlink" title="函数调用"></a>函数调用</h2><p>如果函数被至少一个参数跟着的话，CoffeeScript会自动地调用这个函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">a = <span class="string">"Howdy!"</span></div><div class="line">alert a</div><div class="line">alert(a)</div></pre></td></tr></table></figure>
<p>最好加上括号，以免在多重调用中混淆。</p>
<h2 id="函数上下文"><a href="#函数上下文" class="headerlink" title="函数上下文"></a>函数上下文</h2><p>在JavaScript上下文会频繁地变化。尤其是在回调函数中，CoffeeScript为此提供了一些辅助。其中之一就是-&gt;的变种胖箭头的函数=&gt;</p>
<p>使用胖箭头代替普通箭头是为了确保函数的上下文可以绑定为当前的上下文。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">this</span>.clickHandler = -&gt; alert <span class="string">"clicked"</span></div><div class="line">element.addEventListener <span class="string">"click"</span>, (e) =&gt; <span class="keyword">this</span>.clickHandler(e)</div></pre></td></tr></table></figure>
<h2 id="对象字面量与数组定义"><a href="#对象字面量与数组定义" class="headerlink" title="对象字面量与数组定义"></a>对象字面量与数组定义</h2><p>CoffeeScript在定义时可以省略括号，还可以使用缩进和换行来代替起分割作用的符号。</p>
<h2 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h2><p>在if和else的关键字中也可省略括号。</p>
<p>在单行的if语句中，你需要使用then关键字，这样CoffeeScript才能明白执行体从什么地方开始。</p>
<p>CoffeeScript并不支持条件运算符，作为替代应该使用单行的if/else语句。</p>
<p>CoffeeScript还支持一项Ruby的特性，即运行在if语句前使用前缀表达式。</p>
<p>可以用not关键字来代替感叹号。</p>
<p>可使用unless关键字，即if的否定。</p>
<p>is语句，===。</p>
<p>会把==、!=转换为===、!==。</p>
<p><img src="http://thumbsnap.com/i/wXqWKCfl.png?0323" alt="coffee"></p>
<h2 id="字符串插值法"><a href="#字符串插值法" class="headerlink" title="字符串插值法"></a>字符串插值法</h2><p>在双引号的字符串中可以包含<code>#{}</code>标记，这些标记中可以包含被插入到字符串中的表达式。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">lala = <span class="string">"hello"</span></div><div class="line">haha = <span class="string">"i can say #&#123;lala&#125;"</span></div></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> haha, lala;</div><div class="line">lala = <span class="string">"hello"</span>;</div><div class="line">haha = <span class="string">"i can say "</span> + lala;</div></pre></td></tr></table></figure>
<h2 id="循环和列表解析"><a href="#循环和列表解析" class="headerlink" title="循环和列表解析"></a>循环和列表解析</h2><p>如果需要知道当前迭代索引，多加一个参数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> name, i <span class="keyword">in</span> [<span class="string">"Roger the pickpocket"</span>, <span class="string">"Roderick the robber"</span>]</div><div class="line"> alert <span class="string">"#&#123;i&#125; - Release #&#123;name&#125;"</span></div></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> i, name, _i, _len, _ref;</div><div class="line"></div><div class="line">_ref = [<span class="string">"Roger the pickpocket"</span>, <span class="string">"Roderick the robber"</span>];</div><div class="line"><span class="keyword">for</span> (i = _i = <span class="number">0</span>, _len = _ref.length; _i &lt; _len; i = ++_i) &#123;</div><div class="line">  name = _ref[i];</div><div class="line">  alert(<span class="string">""</span> + i + <span class="string">" - Release "</span> + name);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以过滤：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">prisoners = [<span class="string">"Roger"</span>, <span class="string">"Roderick"</span>, <span class="string">"Brian"</span>]</div><div class="line">release prisoner <span class="keyword">for</span> prisoner <span class="keyword">in</span> prisoners when prisoner[<span class="number">0</span>] is <span class="string">"R"</span></div></pre></td></tr></table></figure></p>
<p>可以使用推导式来迭代对象的全部属性，不过要使用of代替in关键字<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">names = sam: seaborn, donna: moss</div><div class="line">alert(<span class="string">"#&#123;first&#125; #&#123;last&#125;"</span>) <span class="keyword">for</span> first, last <span class="keyword">of</span> names</div></pre></td></tr></table></figure></p>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>两个数字之间使用<code>..</code>或者<code>...</code>来分隔。前者包含最后一个位置，后者不包含。</p>
<p>然而，如果区间被指定到一个变量之后，CoffeeScript则会将其转换为一个<code>slice()</code>调用。</p>
<p>在JavaScript中检测数组中是否存在某个值是一件麻烦事，特别是indexOf()并不是所有的 浏览器都支持（IE，我说的就是你！）。CoffeeScript使用in操作符来解决这个问题，例 如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">words = [<span class="string">"rattled"</span>, <span class="string">"roudy"</span>, <span class="string">"rebbles"</span>, <span class="string">"ranks"</span>]</div><div class="line"> alert <span class="string">"Stop wagging me"</span> <span class="keyword">if</span> <span class="string">"ranks"</span> <span class="keyword">in</span> words</div></pre></td></tr></table></figure>
<h2 id="别名和存在操作符"><a href="#别名和存在操作符" class="headerlink" title="别名和存在操作符"></a>别名和存在操作符</h2><p><code>@</code>是<code>this</code>的别名。<code>::</code>是<code>prototype</code>的别名</p>
<p>CoffeeScript存在操作符<code>?</code>只会在变量为null或者undefined的时候返回真。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">praise <span class="keyword">if</span> brian?</div></pre></td></tr></table></figure>
<p>还能替换||操作符</p>
<p>如果在访问属性之前进行null检查：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">blackKnight.getLegs()?.kick()</div></pre></td></tr></table></figure></p>
<p>可以用相同的方法检查一个属性是否是函数，是否可以调用。如果属性不存在或者不是一个函数，则就不会被调用。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">blackKnight.getLegs().kick?()</div></pre></td></tr></table></figure>
<h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">class Animal</div><div class="line"> constructor: (@name) -&gt;</div><div class="line"></div><div class="line">animal = new Animal(&quot;Parrot&quot;)</div><div class="line">alert &quot;Animal is a #&#123;animal.name&#125;&quot;</div></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> Animal, animal;</div><div class="line"></div><div class="line">Animal = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">Animal</span>(<span class="params">name</span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.name = name;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">return</span> Animal;</div><div class="line"></div><div class="line">&#125;)();</div><div class="line"></div><div class="line">animal = <span class="keyword">new</span> Animal(<span class="string">"Parrot"</span>);</div><div class="line"></div><div class="line">alert(<span class="string">"Animal is a "</span> + animal.name);</div></pre></td></tr></table></figure>
<h2 id="CoffeeScript惯用法"><a href="#CoffeeScript惯用法" class="headerlink" title="CoffeeScript惯用法"></a>CoffeeScript惯用法</h2><h3 id="Each"><a href="#Each" class="headerlink" title="Each"></a>Each</h3><p>尽管forEach()语法非常简洁易读，但有个缺点是在每次数组迭代时都需要调用回调函数，因此它比等价的for循环要慢。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">myFunction(item) <span class="keyword">for</span> item <span class="keyword">in</span> array</div></pre></td></tr></table></figure>
<p>但在CoffeeScript中，在这背后会被编译为for循环。也就是语法提供了便捷性，但是没有性能的耗损。</p>
<h2 id="CoffeeScript中没有修正的部分"><a href="#CoffeeScript中没有修正的部分" class="headerlink" title="CoffeeScript中没有修正的部分"></a>CoffeeScript中没有修正的部分</h2><p>CoffeeScript竭尽全力地解决了JavaScript设计上的一些缺陷，但不针对JavaScript的关键字提供一层抽象，因此很多缺陷依然带到了CoffeeScript中。</p>
<h3 id="使用eval"><a href="#使用eval" class="headerlink" title="使用eval"></a>使用eval</h3><h3 id="使用typeof"><a href="#使用typeof" class="headerlink" title="使用typeof"></a>使用typeof</h3><p>typeof操作符是JavaScript最坑爹的设计，因为它完全就是鸡肋。事实上，它只有一个用途，就是检测一个值是否是undefined。</p>
<h3 id="使用instanceof"><a href="#使用instanceof" class="headerlink" title="使用instanceof"></a>使用instanceof</h3><p>JavaScript的instanceof关键字几乎就和typeof一样不给力。理想的instanceof将比较 两个对象的构造器，看其中一个是否另外一个的实例而返回真假值。实际上instanceof只 在比较自定义的对象上工作正常。如果用来比较内置类型时，就像typeof一样废。</p>
<h3 id="使用delete"><a href="#使用delete" class="headerlink" title="使用delete"></a>使用delete</h3><p>delete关键字只能用来移除对象内部的属性，用于其他地方，比如删除一个变量或者函数，就完全不行。<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">aVar = 1</div><div class="line">delete aVar</div><div class="line">typeof Var # 'integer'</div></pre></td></tr></table></figure></p>
<p>如果你想移除一个变量的引用，将其赋值为null即可</p>
<h3 id="使用parseInt"><a href="#使用parseInt" class="headerlink" title="使用parseInt"></a>使用parseInt</h3><p>使用parseInt函数的时候别忘了传递一个基数，否则会得到意外的值。</p>
<p>参考《Coffeescript小书》</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;优点&quot;&gt;&lt;a href=&quot;#优点&quot; class=&quot;headerlink&quot; title=&quot;优点&quot;&gt;&lt;/a&gt;优点&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;简洁、充分地利用空格&lt;/li&gt;
&lt;li&gt;有一些优雅的特性，比如列表解析、原型符号别名和类等等，能够有效减少输入&lt;/li&gt;
&lt;li&gt;有原则地选择了一些JavaScript的特性，巧妙地避开了JavaScript的一些怪癖&lt;/li&gt;
&lt;li&gt;CoffeeScript不是JavaScript的超集&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;为什么CoffeeScript不是超集？阻止其成为超集最直接的原因是在CoffeeScript程序中空格是有意义的。&lt;/p&gt;
    
    </summary>
    
      <category term="Coffeescript" scheme="http://sheilacat.github.io/categories/Coffeescript/"/>
    
    
  </entry>
  
  <entry>
    <title>《编写可维护的JavaScript》</title>
    <link href="http://sheilacat.github.io/maintainable-javascript/"/>
    <id>http://sheilacat.github.io/maintainable-javascript/</id>
    <published>2016-03-23T14:13:07.000Z</published>
    <updated>2016-10-08T12:26:37.360Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基本的格式化"><a href="#基本的格式化" class="headerlink" title="基本的格式化"></a>基本的格式化</h2><h3 id="缩进层级"><a href="#缩进层级" class="headerlink" title="缩进层级"></a>缩进层级</h3><p>TAB或者2个空格、4个空格、8个空格。</p>
<p>建议使用4个空格为一个制表符。</p>
<a id="more"></a>
<h3 id="语句结尾"><a href="#语句结尾" class="headerlink" title="语句结尾"></a>语句结尾</h3><p>有赖于分析器的自动分号插入（Automatic Semicolon Insertion，ASI）机制，JavaScript代码省略分号也是可以正常工作的。ASI会自动寻找代码中应当使用分号但实际没有分号的位置，并插入分号。大多数场景下ASI都会正确插入分号，不会产生错误。但ASI的分号插入规则非常复杂且很难记住，因此我推荐不要省略分号。</p>
<h3 id="行的长度"><a href="#行的长度" class="headerlink" title="行的长度"></a>行的长度</h3><p>80</p>
<h3 id="换行"><a href="#换行" class="headerlink" title="换行"></a>换行</h3><p>运算符后缩进，且增加两个层级的缩进。</p>
<p>逗号是一个运算符，应当作为前一行的行尾。这个换行位置非常重要，因为ASI机制会在某些场景下在行结束的位置插入分号。总是将一个运算符置于行尾，ASI就不会自作主张地插入分号，也就避免了错误的发生。</p>
<p>这个规则有个例外：给变量赋值时</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> result = something + anotherThing + yetAnotherThing + somethingElse +</div><div class="line">                   anotherSomethingElse;</div></pre></td></tr></table></figure>
<h3 id="空行"><a href="#空行" class="headerlink" title="空行"></a>空行</h3><ul>
<li><p>在每个流控制语句之前（比如if和for语句）添加空行。</p>
</li>
<li><p>在方法之间。</p>
</li>
<li><p>在方法中的局部变量和第一条语句之间。</p>
</li>
<li><p>在多行或单行注释之前。</p>
</li>
<li><p>在方法内的逻辑片段之间插入空行，提高可读性。</p>
</li>
</ul>
<h3 id="变量和函数"><a href="#变量和函数" class="headerlink" title="变量和函数"></a>变量和函数</h3><p>命名采用驼峰命名法。变量的前缀是名词，函数前缀是动词。</p>
<h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><p>使用大写字母和下划线来命名，下划线用以分隔单词。</p>
<h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p>大驼峰命名法。</p>
<h3 id="null"><a href="#null" class="headerlink" title="null"></a>null</h3><p>理解null最好的方式是将它当做对象的占位符（placeholder）。</p>
<h3 id="undefined"><a href="#undefined" class="headerlink" title="undefined"></a>undefined</h3><p>那些没有被初始化的变量都有一个初始值，即undefined，表示这个变量等待被赋值。</p>
<p>通过禁止使用特殊值undefined，可以有效地确保只在一种情况下typeof才会返回“undefined”：当变量未声明时。如果你使用了一个可能赋值为一个对象的变量时，则将其赋值为null。</p>
<p>将变量初始值赋值为null表明了这个变量的意图，它最终很可能赋值为对象。typeof运算符运算null的类型时返回“object”，这样就可以和undefined区分开了。</p>
<h3 id="对象直接量"><a href="#对象直接量" class="headerlink" title="对象直接量"></a>对象直接量</h3><p>这种方式可以取代先显式地创建Object的实例，然后添加属性的这种做法。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">// 不好的写法</div><div class="line">var book = new Object();</div><div class="line">book.title = "Maintainable JavaScript;</div><div class="line">book.author = "Nicholas C. Zakas";</div><div class="line">// 好的写法</div><div class="line">var book = &#123;</div><div class="line">     title: "Maintainable JavaScript,</div><div class="line">     author: "Nicholas C. Zakas"</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h3 id="数组直接量"><a href="#数组直接量" class="headerlink" title="数组直接量"></a>数组直接量</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 不好的写法</span></div><div class="line"><span class="keyword">var</span> colors = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="string">"red"</span>, <span class="string">"green"</span>, <span class="string">"blue"</span>);</div><div class="line"><span class="comment">// 好的做法</span></div><div class="line"><span class="keyword">var</span> colors = [<span class="string">"red"</span>, <span class="string">"green"</span>, <span class="string">"blue"</span>];</div></pre></td></tr></table></figure>
<h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><h3 id="单行注释"><a href="#单行注释" class="headerlink" title="单行注释"></a>单行注释</h3><p>建议：</p>
<p>斜杠后一个空格</p>
<p>单行注释前有一个空行</p>
<p>缩进到与下一行代码对齐</p>
<p>如果是代码尾部的注释，与代码之间要有一个缩进的距离</p>
<p>最好不要连续使用单行注释</p>
<h3 id="多行注释"><a href="#多行注释" class="headerlink" title="多行注释"></a>多行注释</h3><p>JAVA风格的多行注释：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line">* 这是一段注释</div><div class="line">* 第二行</div><div class="line">*/</div></pre></td></tr></table></figure>
<p>代码尾部注释不要用多行注释格式</p>
<h2 id="语句和表达式"><a href="#语句和表达式" class="headerlink" title="语句和表达式"></a>语句和表达式</h2><h3 id="with语句"><a href="#with语句" class="headerlink" title="with语句"></a>with语句</h3><p>with语句用于暂修改作用域链，其语法为</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">with</span>(object)&#123;</div><div class="line">    statement </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>width的本意是用来减少键盘的输入的，比如<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">obj.a = obj.b</div><div class="line">obj.c = obj.d</div></pre></td></tr></table></figure></p>
<p>可以简写成<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">with</span>(obj)&#123;</div><div class="line">     a = b;</div><div class="line">     c = d;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>但是在实际运行时，解释器会首先判断obj.b和obj.d是否存在，如果不存在的话，再判断全局变量b和d是否存在。这样就导致了低效率，而且可能会导致意外，因此最好不要使用with语句。也就是无法知道变量b和d到底是局部变量还是obj的一个属性。实际上这种困惑对开发者的影响更甚，JavaScript引擎和压缩工具无法对这段代码进行优化，因为它们无法猜出代码的正确含义。</p>
<p>在严格模式中，with语句是被明确禁止的。</p>
<h3 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h3><p>for循环有两种更改循环执行过程的方法，第一种是break，第二种是continue。</p>
<p>Crockford的编程规范不允许使用continue。他主张代码中与其使用continue不如使用条件语句。更容易理解，且不易出错。可由当前代码可读性决定是否使用。</p>
<h3 id="for-in-循环"><a href="#for-in-循环" class="headerlink" title="for-in 循环"></a>for-in 循环</h3><p><strong><em>for-in循环，不仅遍历对象的实例属性（instance property），同样还遍历从原型继承来的属性。</em></strong>当遍历自定义对象的属性时，往往会因为意外的结果而终止。因此，最好使用<code>hasOwnProperty()</code>方法来为for-in循环过滤出实例属性。</p>
<p>通常for循环用来遍历数组成员，for-in循环用来遍历对象的属性。</p>
<p><strong><em>for-in循环是用来对实例对象和原型链中的键（key）做遍历的，而不是用来遍历包含数字索引的数组的。</em></strong></p>
<h2 id="变量、函数和运算符"><a href="#变量、函数和运算符" class="headerlink" title="变量、函数和运算符"></a>变量、函数和运算符</h2><h3 id="变量声明"><a href="#变量声明" class="headerlink" title="变量声明"></a>变量声明</h3><p>推荐使用单var进行变量的声明。</p>
<h3 id="函数声明"><a href="#函数声明" class="headerlink" title="函数声明"></a>函数声明</h3><p>…</p>
<p>此外，函数声明不应当出现在语句块之内。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 不好的写法</span></div><div class="line"><span class="keyword">if</span> (condition) &#123;</div><div class="line">     <span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params"></span>) </span>&#123;</div><div class="line">          alert(<span class="string">'Hi!'</span>);</div><div class="line">     &#125;</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">     <span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params"></span>) </span>&#123;</div><div class="line">         alert(<span class="string">'Yo!'</span>); </div><div class="line">     &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>不论condition计算结果如何，大部分浏览器都会使用第二个函数。Firefox会根据计算结果选用合适的函数声明。<br>这种场景是ECMAScript的一个灰色地带，应当尽可能地避免。</p>
<h3 id="严格模式"><a href="#严格模式" class="headerlink" title="严格模式"></a>严格模式</h3><p>最好不要在全局作用域中使用”use strict”。</p>
<h3 id="eval"><a href="#eval" class="headerlink" title="eval()"></a>eval()</h3><p>在JavaScript中，<code>eval()</code>的参数是一个字符串，<code>eval()</code>会将传入的字符串当作代码来执行。开发者可以通过这个函数来载入外部的JavaScript代码，或者随即生成代码并执行它。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">eval</span>(<span class="string">"alert('Hi!')"</span>);</div></pre></td></tr></table></figure>
<p>在JavaScript中，<code>eval()</code>并不是唯一可以执行JavaScript字符串的函数，使用Function构造函数、setTimeout()和setInterval也可以。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> myfunc = <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">"alert('Hi!')"</span>);</div><div class="line">setTimeout(<span class="string">"document.body.style.background='red'"</span>, <span class="number">50</span>);</div><div class="line">setInterval(<span class="string">"document.title = 'It is now '"</span> + (<span class="keyword">new</span> <span class="built_in">Date</span>()), <span class="number">1000</span>);</div></pre></td></tr></table></figure>
<p>一个通用的原则是，严禁使用Function，并且只在别无他法时使用eval()。setTimeout()和setInterval也是可以使用的，但不要用字符串形式而要用函数。</p>
<h1 id="编程实践"><a href="#编程实践" class="headerlink" title="编程实践"></a>编程实践</h1><h2 id="避免使用全局变量"><a href="#避免使用全局变量" class="headerlink" title="避免使用全局变量"></a>避免使用全局变量</h2><h3 id="全局变量带来的问题"><a href="#全局变量带来的问题" class="headerlink" title="全局变量带来的问题"></a>全局变量带来的问题</h3><h4 id="命名冲突"><a href="#命名冲突" class="headerlink" title="命名冲突"></a>命名冲突</h4><h4 id="代码的脆弱性"><a href="#代码的脆弱性" class="headerlink" title="代码的脆弱性"></a>代码的脆弱性</h4><h4 id="难以测试"><a href="#难以测试" class="headerlink" title="难以测试"></a>难以测试</h4><h3 id="单全局变量"><a href="#单全局变量" class="headerlink" title="单全局变量"></a>单全局变量</h3><p>*YUI定义了唯一一个YUI全局对象。</p>
<p>*jQuery定义了两个全局对象，$和jQuery。只有在$被其他的类库使用了的情况下，为了避免冲突，应当使用jQuery。</p>
<p>单全局变量的意思是所创建的这个唯一全局对象名是独一无二的（不会和内置API产生冲突），并将你所有的功能代码都挂载到这个全局对象上，因此每个可能的全局变量都成为你唯一全局变量的属性，从而不会创建多个全局变量。</p>
<h3 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h3><h3 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h3><h3 id="零全局变量"><a href="#零全局变量" class="headerlink" title="零全局变量"></a>零全局变量</h3><h2 id="事件处理"><a href="#事件处理" class="headerlink" title="事件处理"></a>事件处理</h2><h3 id="规则1：隔离应用逻辑"><a href="#规则1：隔离应用逻辑" class="headerlink" title="规则1：隔离应用逻辑"></a>规则1：隔离应用逻辑</h3><p>应用逻辑是和应用相关的功能性代码，而不是和用户行为相关的。</p>
<p>将应用逻辑从所有事件处理程序中抽离出来的做法是一种最佳实践。</p>
<p>另一个缺点是和测试有关。测试时需要直接触发功能代码，而不必通过模拟对元素的点击来触发。</p>
<h3 id="规则2：不要分发事件对象"><a href="#规则2：不要分发事件对象" class="headerlink" title="规则2：不要分发事件对象"></a>规则2：不要分发事件对象</h3><p>最佳的办法是让事件处理程序使用event对象来处理事件，然后拿到所有需要的数据传给应用逻辑。</p>
<p>在处理事件时，最好让事件处理程序成为接触到event对象的唯一的函数。事件处理程序应当在进入应用逻辑之前针对event对象执行任何必要的操作，包括阻止默认事件或阻止事件冒泡，都应当直接包含在事件处理程序中。</p>
<p>例如</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> MyApplication = &#123;</div><div class="line">     handleClick: <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</div><div class="line">          event.preventDefault();</div><div class="line">          event.stopPropagation();</div><div class="line">     </div><div class="line">          <span class="keyword">this</span>.showPopup(event.clientX, event.clientY);</div><div class="line">     &#125;,</div><div class="line"></div><div class="line">     showPopup: <span class="function"><span class="keyword">function</span>(<span class="params">x, y</span>) </span>&#123;</div><div class="line">          ...</div><div class="line">     &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">addListener(element, <span class="string">"click"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</div><div class="line">     MyApplication.handleClick(event);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h2 id="避免“空比较”"><a href="#避免“空比较”" class="headerlink" title="避免“空比较”"></a>避免“空比较”</h2><h3 id="检查原始值"><a href="#检查原始值" class="headerlink" title="检查原始值"></a>检查原始值</h3><p>5种原型类型：字符串、数字、布尔值、null和undefined。</p>
<p>最佳选择是用typeof运算符。（实际上也只能准确检测undefined）</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> num1 = <span class="number">1</span>;</div><div class="line"><span class="keyword">var</span> num2 = <span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">2</span>);</div><div class="line"></div><div class="line"><span class="keyword">typeof</span> num1; <span class="comment">// "number"</span></div><div class="line"><span class="keyword">typeof</span> num2; <span class="comment">// "object"</span></div><div class="line"></div><div class="line"><span class="keyword">typeof</span> <span class="literal">null</span>; <span class="comment">// "object"</span></div></pre></td></tr></table></figure>
<p>如果要检测null，则直接使用===/!==。</p>
<h3 id="检测引用值"><a href="#检测引用值" class="headerlink" title="检测引用值"></a>检测引用值</h3><p>引用值也称作对象。在JavaScript中除了原始值之外的值都是引用。内置的引用类型：Object、Array、Date和Error。</p>
<p>instanceof，它不仅检测构造这个对象的构造器，还检测原型链。检测自定义类型最好能的做法也是用instanceof运算符。</p>
<h3 id="检测函数"><a href="#检测函数" class="headerlink" title="检测函数"></a>检测函数</h3><p>大部分情况下，用typeof，不用instanceof。instanceof不能“跨帧”。</p>
<h3 id="检测数组"><a href="#检测数组" class="headerlink" title="检测数组"></a>检测数组</h3><p>JavaScript中最古老的跨域问题之一就是在帧之间来回传递数组。instanceof Array在此场景中不总是返回正确的结果。每个帧都会有各自的Array构造函数，因此一个帧中的实例在另外一个帧里不会被识别。</p>
<p>鸭式辨型：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 采用鸭式辨型的方法检测数组</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">isArray</span>(<span class="params">value</span>) </span>&#123;</div><div class="line">     <span class="keyword">return</span> <span class="keyword">typeof</span> value.sort === <span class="string">"function"</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这种检测方法依赖一个事实，就是数组是唯一包含sort()方法的对象。</p>
<p>最终，Kangax给出了一种优雅的解决方案：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">isArray</span>(<span class="params">value</span>) </span>&#123;</div><div class="line">     <span class="keyword">return</span> <span class="built_in">Object</span>.prototype.toString.call(value) === <span class="string">"[object Array]"</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>ECMAScript5将Array.isArray()正式引入JavaScript。</p>
<h3 id="检测属性"><a href="#检测属性" class="headerlink" title="检测属性"></a>检测属性</h3><p>因为存在IE8以及更早版本IE的情形（在调用DOM对象的hasOwnProperty方法之前应当先检测其是否存在），在判断实例对象是否存在时，更倾向于使用in运算符，只有在需要判断实例属性时才会用到hasOwnProperty()。</p>
<h2 id="将配置数据从代码中分离出来"><a href="#将配置数据从代码中分离出来" class="headerlink" title="将配置数据从代码中分离出来"></a>将配置数据从代码中分离出来</h2><h3 id="什么是配置数据"><a href="#什么是配置数据" class="headerlink" title="什么是配置数据"></a>什么是配置数据</h3><p>*URL</p>
<p>*需要展现给用户的字符串</p>
<p>*重复的值</p>
<p>*设置（比如每页的配置项）</p>
<p>*任何可能发生变更的值</p>
<h3 id="抽离配置数据"><a href="#抽离配置数据" class="headerlink" title="抽离配置数据"></a>抽离配置数据</h3><h3 id="保存配置数据"><a href="#保存配置数据" class="headerlink" title="保存配置数据"></a>保存配置数据</h3><p>*java属性文件等进行保存</p>
<p>然后将这个文件转换为JavaScript可用的额文件：</p>
<p>*JSON</p>
<p>*JSONP</p>
<p>*纯JavaScript</p>
<h2 id="抛出自定义错误"><a href="#抛出自定义错误" class="headerlink" title="抛出自定义错误"></a>抛出自定义错误</h2><h3 id="try-catch语句"><a href="#try-catch语句" class="headerlink" title="try-catch语句"></a>try-catch语句</h3><h3 id="错误类型"><a href="#错误类型" class="headerlink" title="错误类型"></a>错误类型</h3><h4 id="Error"><a href="#Error" class="headerlink" title="Error"></a>Error</h4><p>所有错误的基本类型。实际上引擎从来不会抛出该类型的错误。</p>
<h4 id="EvalError"><a href="#EvalError" class="headerlink" title="EvalError"></a>EvalError</h4><p>通过eval()函数执行代码发生错误时抛出。</p>
<h4 id="RangeError"><a href="#RangeError" class="headerlink" title="RangeError"></a>RangeError</h4><p>一个数字超过它的边界时抛出。</p>
<h4 id="ReferenceError"><a href="#ReferenceError" class="headerlink" title="ReferenceError"></a>ReferenceError</h4><p>期望的对象不存在时抛出。引用错误。</p>
<h4 id="SyntaxError"><a href="#SyntaxError" class="headerlink" title="SyntaxError"></a>SyntaxError</h4><p>给eval()函数传递的代码中有语法错误时。</p>
<h4 id="TypeError"><a href="#TypeError" class="headerlink" title="TypeError"></a>TypeError</h4><p>变量不是期望的类型时抛出。</p>
<h4 id="URIError"><a href="#URIError" class="headerlink" title="URIError"></a>URIError</h4><p>给encodeURI()、encodeURIComponent()、decodeURI()或者decodeURIComponent()等函数传递格式非法的URI字符串时抛出。</p>
<h1 id="不是你的对象不要动"><a href="#不是你的对象不要动" class="headerlink" title="不是你的对象不要动"></a>不是你的对象不要动</h1><h2 id="原则"><a href="#原则" class="headerlink" title="原则"></a>原则</h2><p>针对原生对象、DOM对象、浏览器对象模型（BOM）对象、类库对象</p>
<h3 id="不覆盖方法"><a href="#不覆盖方法" class="headerlink" title="不覆盖方法"></a>不覆盖方法</h3><h3 id="不新增方法"><a href="#不新增方法" class="headerlink" title="不新增方法"></a>不新增方法</h3><h3 id="不删除方法"><a href="#不删除方法" class="headerlink" title="不删除方法"></a>不删除方法</h3><h2 id="更好的途径"><a href="#更好的途径" class="headerlink" title="更好的途径"></a>更好的途径</h2><h3 id="基于对象的继承"><a href="#基于对象的继承" class="headerlink" title="基于对象的继承"></a>基于对象的继承</h3><p>Object.create()</p>
<h3 id="基于类型的继承"><a href="#基于类型的继承" class="headerlink" title="基于类型的继承"></a>基于类型的继承</h3><p>首先，原型继承；然后，构造器继承。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</div><div class="line">     <span class="keyword">this</span>.name;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Author</span>(<span class="params">name</span>) </span>&#123;</div><div class="line">     Person.call(<span class="keyword">this</span>, name); <span class="comment">//继承构造器</span></div><div class="line">&#125;</div><div class="line"></div><div class="line">Author.prototype = <span class="keyword">new</span> Person();</div></pre></td></tr></table></figure>
<h3 id="门面模式"><a href="#门面模式" class="headerlink" title="门面模式"></a>门面模式</h3><p>门面模式，也叫做包装器。它为一个已存在的对象创建一个新的接口。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">DOMWrapper</span>(<span class="params">element</span>) </span>&#123; </div><div class="line">     <span class="keyword">this</span>.element = element;</div><div class="line">&#125;</div><div class="line"></div><div class="line">DOMWrapper.prototype.addClass = <span class="function"><span class="keyword">function</span>(<span class="params">className</span>) </span>&#123;</div><div class="line">     element.className += <span class="string">" "</span> + className;</div><div class="line">&#125;</div><div class="line"></div><div class="line">DOMWrapper.prototype.remove = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">     <span class="keyword">this</span>.element.parentNode.removeChild(<span class="keyword">this</span>.element);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> wrapper = <span class="keyword">new</span> DOMWrapper(<span class="built_in">document</span>.getElementById(<span class="string">"my-div"</span>));</div><div class="line">wrapper.addClass(<span class="string">"selected"</span>);</div><div class="line">wrapper.remove();</div></pre></td></tr></table></figure>
<h3 id="关于Polyfill的注解"><a href="#关于Polyfill的注解" class="headerlink" title="关于Polyfill的注解"></a>关于Polyfill的注解</h3><p>Polyfills也称为shims，是指一种功能的模拟，模拟一些新版本中新特性的原生功能并且要以完全兼容的方式实现。</p>
<p>从维护角度说，最好使用门面模式来代替polyfill。</p>
<h3 id="阻止修改"><a href="#阻止修改" class="headerlink" title="阻止修改"></a>阻止修改</h3><p>三种锁定修改的级别：</p>
<h4 id="防止扩展"><a href="#防止扩展" class="headerlink" title="防止扩展"></a>防止扩展</h4><p>禁止添加，但可以删除和修改。</p>
<p>Object.preventExtension()，防止扩展。Object.isExtensible()，检测是否可拓展。</p>
<h4 id="密封"><a href="#密封" class="headerlink" title="密封"></a>密封</h4><p>禁止添加和删除，但可以修改。</p>
<p>Object.seal()<br>Object.isSealed()</p>
<h4 id="冻结"><a href="#冻结" class="headerlink" title="冻结"></a>冻结</h4><p>禁止删除和添加、修改，只读模式。</p>
<p>Object.freeze()<br>Object.isFrozen()</p>
<p>以上三种模式中，当操作禁止行为时会静默失败，只有在严格模式下才会报错。</p>
<p>一旦一个对象被锁定了，将无法解锁。</p>
<h2 id="浏览器嗅探"><a href="#浏览器嗅探" class="headerlink" title="浏览器嗅探"></a>浏览器嗅探</h2><h2 id="自动化"><a href="#自动化" class="headerlink" title="自动化"></a>自动化</h2>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;基本的格式化&quot;&gt;&lt;a href=&quot;#基本的格式化&quot; class=&quot;headerlink&quot; title=&quot;基本的格式化&quot;&gt;&lt;/a&gt;基本的格式化&lt;/h2&gt;&lt;h3 id=&quot;缩进层级&quot;&gt;&lt;a href=&quot;#缩进层级&quot; class=&quot;headerlink&quot; title=&quot;缩进层级&quot;&gt;&lt;/a&gt;缩进层级&lt;/h3&gt;&lt;p&gt;TAB或者2个空格、4个空格、8个空格。&lt;/p&gt;
&lt;p&gt;建议使用4个空格为一个制表符。&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://sheilacat.github.io/categories/JavaScript/"/>
    
    
  </entry>
  
  <entry>
    <title>git学习笔记</title>
    <link href="http://sheilacat.github.io/learn-git/"/>
    <id>http://sheilacat.github.io/learn-git/</id>
    <published>2015-11-17T14:19:57.000Z</published>
    <updated>2016-10-08T12:26:18.767Z</updated>
    
    <content type="html"><![CDATA[<h2 id="版本控制（VCS）的类型"><a href="#版本控制（VCS）的类型" class="headerlink" title="版本控制（VCS）的类型"></a>版本控制（VCS）的类型</h2><ul>
<li>本地版本控制系统</li>
<li>集中化的版本控制系统(Centralized Version Control Systems）</li>
<li>分布式版本控制系统(Distributed Version Control System）<br>分布式版本控制系统的客户端，每一次的提取操作，实际上都是一次对代码仓库的完整备份。这么一来，任何一处协同工作用的服务器发生故障，事后都可以用任何一个镜像出来的本地仓库恢复。</li>
</ul>
<a id="more"></a>
<h2 id="Git基础"><a href="#Git基础" class="headerlink" title="Git基础"></a>Git基础</h2><ul>
<li>直接记录快照，而非差异比较</li>
<li>近乎所有操作都是本地执行</li>
<li>时刻保持数据完整性<br>在保存到Git之前，所有数据都要进行内容的校验和（checksum）计算，并将此结果作为数据的唯一标识和索引。Git使用SHA-1算法计算数据的校验和，通过对文件的内容或目录的结构计算出一个SHA-1哈希值，作为指纹字符串。该字串由40个十六进制字符（0-9及a-f）组成。</li>
<li>多数操作仅添加数据</li>
<li>文件的三种状态<br>对于任何一个文件，在 Git 内都只有三种状态：<code>已提交（committed）</code>，<code>已修改（modified）</code>和<code>已暂存（staged）</code>。已提交表示该文件已经被安全地保存在本地数据库中了；已修改表示修改了某个文件，但还没有提交保存；已暂存表示把已修改的文件放在下次提交时要保存的清单中。<br>由此我们看到 Git 管理项目时，文件流转的三个工作区域：Git 的工作目录，暂存区域，以及本地仓库。</li>
</ul>
<h3 id="在工作目录中初始化新仓库"><a href="#在工作目录中初始化新仓库" class="headerlink" title="在工作目录中初始化新仓库"></a>在工作目录中初始化新仓库</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git init</div></pre></td></tr></table></figure>
<h3 id="记录每次更新到仓库"><a href="#记录每次更新到仓库" class="headerlink" title="记录每次更新到仓库"></a>记录每次更新到仓库</h3><p><img src="http://7xoefy.com1.z0.glb.clouddn.com/FileStatusLifecycle.png" alt="img"></p>
<h3 id="检查当前文件状态"><a href="#检查当前文件状态" class="headerlink" title="检查当前文件状态"></a>检查当前文件状态</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git status</div></pre></td></tr></table></figure>
<h3 id="暂存已修改文件"><a href="#暂存已修改文件" class="headerlink" title="暂存已修改文件"></a>暂存已修改文件</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git add</div></pre></td></tr></table></figure>
<p><code>git add</code>命令（这是个多功能命令，根据目标文件的状态不同，此命令的效果也不同：可以用它开始跟踪新文件，或者把已跟踪的文件放到暂存区，还能用于合并时把有冲突的文件标记为已解决状态等）</p>
<h3 id="忽略某些文件"><a href="#忽略某些文件" class="headerlink" title="忽略某些文件"></a>忽略某些文件</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ cat .gitignore</div><div class="line">*.[oa]</div><div class="line">*~</div></pre></td></tr></table></figure>
<p>文件 .gitignore 的格式规范如下：</p>
<ul>
<li>所有空行或者以注释符号 ＃ 开头的行都会被 Git 忽略。</li>
<li>可以使用标准的 glob 模式匹配。</li>
<li>匹配模式最后跟反斜杠（/）说明要忽略的是目录。</li>
<li>要忽略指定模式以外的文件或目录，可以在模式前加上惊叹号（!）取反。</li>
</ul>
<p>所谓的 glob 模式是指 shell 所使用的简化了的正则表达式。星号（*）匹配零个或多个任意字符；[abc] 匹配任何一个列在方括号中的字符（这个例子要么匹配一个 a，要么匹配一个 b，要么匹配一个 c）；问号（?）只匹配一个任意字符；如果在方括号中使用短划线分隔两个字符，表示所有在这两个字符范围内的都可以匹配（比如 [0-9] 表示匹配所有 0 到 9 的数字）。</p>
<h3 id="查看已暂存和未暂存的更新"><a href="#查看已暂存和未暂存的更新" class="headerlink" title="查看已暂存和未暂存的更新"></a>查看已暂存和未暂存的更新</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git diff</div></pre></td></tr></table></figure>
<p><code>git diff</code>会使用文件补丁的格式显示具体添加和删除的行。<br>此命令比较的是工作目录中当前文件和暂存区域快照之间的差异，也就是修改之后<strong><em>还没有暂存起来的变化内容</em></strong>。<br>若要看已经暂存起来的文件和上次提交时的快照之间的差异，可以用<code>git diff --cached</code>命令。（Git 1.6.1及更高版本还允许使用<code>git diff --staged</code>，效果是相同的）</p>
<h3 id="提交更新"><a href="#提交更新" class="headerlink" title="提交更新"></a>提交更新</h3><p><code>git commit</code>命令，之后会进入文本编辑环境要求输入本次提交的说明。<br><code>git commit -m &quot;xxx&quot;</code><br><code>git commit -a -m &quot;xxx&quot;</code> 跳过使用暂存区域，<code>-a</code>选项Git自动把所有已经跟踪过的文件暂存起来一并提交。</p>
<h3 id="移除文件"><a href="#移除文件" class="headerlink" title="移除文件"></a>移除文件</h3><p>要从Git中移除某个文件，就必须要从已跟踪文件清单中移除（确切地说，是从暂存区域移除），然后提交。<code>git rm</code>，并连带从工作目录中删除指定的文件。</p>
<p>另外一种情况是，我们想把文件从 Git 仓库中删除（亦即从暂存区域移除），但仍然希望保留在当前工作目录中。换句话说，仅是从跟踪清单中删除。比如一些大型日志文件或者一堆 .a 编译文件，不小心纳入仓库后，要移除跟踪但不删除文件，以便稍后在 .gitignore 文件中补上，用 –cached 选项即可：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git rm --cached readme.txt</div></pre></td></tr></table></figure></p>
<h3 id="移动文件"><a href="#移动文件" class="headerlink" title="移动文件"></a>移动文件</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git mv file_from file_to</div></pre></td></tr></table></figure>
<p>重命名文件，其实，运行<code>git mv</code>就相当于运行了下面三条命令<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ mv README.txt README</div><div class="line">$ git rm README.txt</div><div class="line">$ git add README</div></pre></td></tr></table></figure></p>
<h3 id="查看提交历史"><a href="#查看提交历史" class="headerlink" title="查看提交历史"></a>查看提交历史</h3><p><code>git log</code>命令</p>
<p><code>git log -p -2</code>命令     <code>-p</code>选项展开显示每次提交的内容差异，用<code>-2</code>则仅显示最近的两次更新</p>
<p><code>git log --stat</code>仅显示简要的增改行数统计</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">选项 说明</div><div class="line"></div><div class="line">    -p 按补丁格式显示每个更新之间的差异。</div><div class="line"></div><div class="line">    --stat 显示每次更新的文件修改统计信息。</div><div class="line"></div><div class="line">    --shortstat 只显示 --stat 中最后的行数修改添加移除统计。</div><div class="line"></div><div class="line">    --name-only 仅在提交信息后显示已修改的文件清单。</div><div class="line"></div><div class="line">    --name-status 显示新增、修改、删除的文件清单。</div><div class="line"></div><div class="line">    --abbrev-commit 仅显示 SHA<span class="number">-1</span> 的前几个字符，而非所有的 <span class="number">40</span> 个字符。</div><div class="line"></div><div class="line">    --relative-date 使用较短的相对时间显示（比如，“<span class="number">2</span> weeks ago”）。</div><div class="line"></div><div class="line">    --graph 显示 ASCII 图形表示的分支合并历史。</div><div class="line"></div><div class="line">    --pretty 使用其他格式显示历史提交信息。可用的选项包括 oneline，short，full，fuller 和 format（后跟指定格式）。</div></pre></td></tr></table></figure>
<p>更有意思的是<code>format</code>，可以定制要显示的记录格式，这样的输出便于后期编程提取分析：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">$ git log --pretty=format:<span class="string">"%h - %an, %ar : %s"</span></div><div class="line"></div><div class="line">    ca82a6d - Scott Chacon, <span class="number">11</span> months ago : changed the version number</div><div class="line"></div><div class="line">    <span class="number">085</span>bb3b - Scott Chacon, <span class="number">11</span> months ago : removed unnecessary test code</div><div class="line"></div><div class="line">    a11bef0 - Scott Chacon, <span class="number">11</span> months ago : first commit</div></pre></td></tr></table></figure></p>
<p>列出了常用的格式占位符写法及其代表的意义。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">选项 说明</div><div class="line"></div><div class="line">    %H 提交对象（commit）的完整哈希字串</div><div class="line"></div><div class="line">    %h 提交对象的简短哈希字串</div><div class="line"></div><div class="line">    %T 树对象（tree）的完整哈希字串</div><div class="line"></div><div class="line">    %t 树对象的简短哈希字串</div><div class="line"></div><div class="line">    %P 父对象（parent）的完整哈希字串</div><div class="line"></div><div class="line">    %p 父对象的简短哈希字串</div><div class="line"></div><div class="line">    %an 作者（author）的名字</div><div class="line"></div><div class="line">    %ae 作者的电子邮件地址</div><div class="line"></div><div class="line">    %ad 作者修订日期（可以用 -date= 选项定制格式）</div><div class="line"></div><div class="line">    %ar 作者修订日期，按多久以前的方式显示</div><div class="line"></div><div class="line">    %cn 提交者(committer)的名字</div><div class="line"></div><div class="line">    %ce 提交者的电子邮件地址</div><div class="line"></div><div class="line">    %cd 提交日期</div><div class="line"></div><div class="line">    %cr 提交日期，按多久以前的方式显示</div><div class="line"></div><div class="line">    %s 提交说明</div></pre></td></tr></table></figure></p>
<p>还有时间限制，比如<code>--since</code>和<code>--until</code>，<code>git log --since=2.weeks</code><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">选项 说明</div><div class="line"></div><div class="line">    -(n) 仅显示最近的 n 条提交</div><div class="line"></div><div class="line">    --since, --after 仅显示指定时间之后的提交。</div><div class="line"></div><div class="line">    --until, --before 仅显示指定时间之前的提交。</div><div class="line"></div><div class="line">    --author 仅显示指定作者相关的提交。</div><div class="line"></div><div class="line">    --committer 仅显示指定提交者相关的提交。</div></pre></td></tr></table></figure></p>
<h3 id="使用图形化工具查阅提交历史"><a href="#使用图形化工具查阅提交历史" class="headerlink" title="使用图形化工具查阅提交历史"></a>使用图形化工具查阅提交历史</h3><p>随Git一同发布的gitk，基本上相当于<code>git log</code>命令的可视化版本。</p>
<h3 id="撤销操作"><a href="#撤销操作" class="headerlink" title="撤销操作"></a>撤销操作</h3><h4 id="修改最后一次提交"><a href="#修改最后一次提交" class="headerlink" title="修改最后一次提交"></a>修改最后一次提交</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git commit --amend</div></pre></td></tr></table></figure>
<h4 id="取消已经暂存的文件"><a href="#取消已经暂存的文件" class="headerlink" title="取消已经暂存的文件"></a>取消已经暂存的文件</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git reset HEAD filename</div></pre></td></tr></table></figure>
<h4 id="取消对文件的修改"><a href="#取消对文件的修改" class="headerlink" title="取消对文件的修改"></a>取消对文件的修改</h4><p>取消对工作目录文件的修改<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git checkout -- filename</div></pre></td></tr></table></figure></p>
<h3 id="远程仓库的使用"><a href="#远程仓库的使用" class="headerlink" title="远程仓库的使用"></a>远程仓库的使用</h3><h4 id="查看当前的远程库"><a href="#查看当前的远程库" class="headerlink" title="查看当前的远程库"></a>查看当前的远程库</h4><p><code>git remote</code><br><code>git remote -v</code>显示对应的克隆地址</p>
<h4 id="添加远程仓库"><a href="#添加远程仓库" class="headerlink" title="添加远程仓库"></a>添加远程仓库</h4><p><code>git remote add [shortname] [url]</code></p>
<h4 id="查看远程仓库信息"><a href="#查看远程仓库信息" class="headerlink" title="查看远程仓库信息"></a>查看远程仓库信息</h4><p><code>git remote show [remote-name]</code></p>
<h4 id="远程仓库的删除和重命名"><a href="#远程仓库的删除和重命名" class="headerlink" title="远程仓库的删除和重命名"></a>远程仓库的删除和重命名</h4><p><code>git remote rename</code>命令修改某个远程仓库在本地的简称<br><code>git remote rm branchname</code>移除对应的远端仓库</p>
<p>参考<a href="http://git.oschina.net/progit/" target="_blank" rel="external">http://git.oschina.net/progit/</a></p>
<p>最后附上一张GIT API总结图，图片来自网络</p>
<p><img src="http://7xoefy.com1.z0.glb.clouddn.com/git-api.png" alt="img"></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;版本控制（VCS）的类型&quot;&gt;&lt;a href=&quot;#版本控制（VCS）的类型&quot; class=&quot;headerlink&quot; title=&quot;版本控制（VCS）的类型&quot;&gt;&lt;/a&gt;版本控制（VCS）的类型&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;本地版本控制系统&lt;/li&gt;
&lt;li&gt;集中化的版本控制系统(Centralized Version Control Systems）&lt;/li&gt;
&lt;li&gt;分布式版本控制系统(Distributed Version Control System）&lt;br&gt;分布式版本控制系统的客户端，每一次的提取操作，实际上都是一次对代码仓库的完整备份。这么一来，任何一处协同工作用的服务器发生故障，事后都可以用任何一个镜像出来的本地仓库恢复。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="http://sheilacat.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>《HTTP权威指南》读书笔记</title>
    <link href="http://sheilacat.github.io/http-guide/"/>
    <id>http://sheilacat.github.io/http-guide/</id>
    <published>2015-11-15T13:20:30.000Z</published>
    <updated>2016-10-08T12:27:03.031Z</updated>
    
    <content type="html"><![CDATA[<p>HTTP(Hypertext Transfer Protocol，超文本传输协议)是在万维网上进行通信时所使用的协议方案。HTTP最著名的是用于Web浏览器和Web服务器之间的双工通信。</p>
<a id="more"></a>
<h2 id="HTTP：Web的基础"><a href="#HTTP：Web的基础" class="headerlink" title="HTTP：Web的基础"></a>HTTP：Web的基础</h2><h3 id="URI-Uniform-Resource-Identifier"><a href="#URI-Uniform-Resource-Identifier" class="headerlink" title="URI(Uniform Resource Identifier)"></a>URI(Uniform Resource Identifier)</h3><p>服务器资源名被称为统一资源标识符，URI就像是因特网上的邮件地址一样，在世界范围内唯一标识并定位信息资源。<br>URI有两种类型：URL和URN。<br>URL，统一资源定位符是资源标志符最常见的形式。URL描述了一台特定服务器上某资源的特定位置。现在，几乎所有URI都是URL。<br>URN，统一资源名。URN是作为特定内容的唯一名称使用的，与目前的资源所在地无关。通过URN，还可以用同一个名字通过多种网络访问协议来访问资源。URN依然处于试验阶段，还未大范围使用。</p>
<h3 id="HTTP请求报文和相应报文"><a href="#HTTP请求报文和相应报文" class="headerlink" title="HTTP请求报文和相应报文"></a>HTTP请求报文和相应报文</h3><p>HTTP请求和相应报文的格式很类似，HTTP报文包括以下三个部分：</p>
<ul>
<li>起始行<br>HTTP/1.0 200 OK</li>
<li>首部字段<br>Content-type: text/plain<br>Content-length: 19</li>
<li>主体<br>I’m a message!</li>
</ul>
<h3 id="TCP-IP"><a href="#TCP-IP" class="headerlink" title="TCP/IP"></a>TCP/IP</h3><p>TCP(Transmission Control Protocol)，传输控制协议。</p>
<p>TCP提供了</p>
<ul>
<li>无差错的数据传输</li>
<li>按序传输（数据总是会按照发送的顺序到达）</li>
<li><p>未分段的数据流（可以在任意时刻以任意尺寸将数据发送出去）<br><img src="http://7xoefy.com1.z0.glb.clouddn.com/1.png" alt="img"></p>
<h3 id="HTTP协议版本"><a href="#HTTP协议版本" class="headerlink" title="HTTP协议版本"></a>HTTP协议版本</h3></li>
<li><p>HTTP/0.9<br>HTTP 的 1991 原型版本称为 HTTP/0.9。这个协议有很多严重的设计缺陷，只应 该用于与老客户端的交互。HTTP/0.9 只支持 GET 方法，不支持多媒体内容的 MIME 类型、各种 HTTP 首部，或者版本号。HTTP/0.9 定义的初衷是为了获取 简单的 HTML 对象，它很快就被 HTTP/1.0 取代了。</p>
</li>
<li><p>HTTP/1.0<br>1.0 是第一个得到广泛使用的 HTTP 版本。HTTP/1.0 添加了版本号、各种 HTTP 首部、一些额外的方法，以及对多媒体对象的处理。HTTP/1.0 使得包含生动图 片的 Web 页面和交互式表格成为可能，而这些页面和表格促使万维网为人们广 泛地接受。这个规范从未得到良好地说明。在这个 HTTP 协议的商业演进和学术 研究都在快速进行的时代，它集合了一系列的最佳实践。</p>
</li>
<li><p>HTTP/1.0+<br>在 20 世纪 90 年代中叶，很多流行的 Web 客户端和服务器都在飞快地向 HTTP 中添加各种特性，以满足快速扩张且在商业上十分成功的万维网的需要。其中很 多特性，包括持久的 keep-alive 连接、虚拟主机支持，以及代理连接支持都被加 入到 HTTP 之中，并成为非官方的事实标准。这种非正式的 HTTP 扩展版本通常 称为 HTTP/1.0+。</p>
</li>
<li><p>HTTP/1.1<br>HTTP/1.1 重点关注的是校正 HTTP 设计中的结构性缺陷，明确语义，引入重要 的性能优化措施，并删除一些不好的特性。HTTP/1.1 还包含了对 20 世纪 90 年 代末正在发展中的更复杂的 Web 应用程序和部署方式的支持。HTTP/1.1 是当前 使用的 HTTP 版本。</p>
</li>
<li><p>HTTP/2.0（HTTP-NG）<br>HTTP-NG 是 HTTP/1.1 后继结构的原型建议，它重点关注的是性能的大幅优化， 以及更强大的服务逻辑远程执行框架。HTTP-NG 的研究工作终止于 1998 年，编 写本书时，还没有任何要用此建议取代 HTTP/1.1 的推广计划。更多信息请参见 第 10 章。</p>
</li>
</ul>
<h3 id="Web的结构组件"><a href="#Web的结构组件" class="headerlink" title="Web的结构组件"></a>Web的结构组件</h3><h4 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h4><p>代理，位于客户端和服务器之间的HTTP中间实体。<br>代理位于客户端和服务器之间，接收所有客户端的HTTP请求，并将这些请求转发给服务器（可能会对请求进行修改之后转发）。<br>出于安全考虑，通常会将代理作为转发所有Web流量的可信任中间节点使用。代理还可以对请求和响应进行过滤。</p>
<h4 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h4><p>缓存，HTTP的仓库，使常用页面的副本可以保存在离客户端更近的地方。<br>Web缓存或代理缓存是一种特殊的HTTP代理服务器。</p>
<h4 id="网关（gateway）"><a href="#网关（gateway）" class="headerlink" title="网关（gateway）"></a>网关（gateway）</h4><p>网关，连接其他应用程序的特殊Web服务器。<br>网关是一种特殊的服务器，作为其他服务器的中间实体使用。通常用于将HTTP流量转换成其他协议。</p>
<p><img src="http://7xoefy.com1.z0.glb.clouddn.com/2.png" alt="img"></p>
<h4 id="隧道（tunnel）"><a href="#隧道（tunnel）" class="headerlink" title="隧道（tunnel）"></a>隧道（tunnel）</h4><p>隧道，对HTTP通信报文进行盲转发的特殊代理。<br>隧道是建立起来之后，就会在两条连接之间对原始数据进行盲转发的HTTP应用程序。HTTP隧道通常用来在一条或多条HTTP连接上转发非HTTP数据，转发时不会窥探数据。<br>HTTP 隧道的一种常见用途是通过 HTTP 连接承载加密的安全套接字层（SSL， Secure Sockets Layer）流量，这样 SSL 流量就可以穿过只允许 Web 流量通过的防 火墙了。如图 1-14 所示，HTTP/SSL 隧道收到一条 HTTP 请求，要求建立一条到目 的地址和端口的输出连接，然后在 HTTP 信道上通过隧道传输加密的 SSL 流量，这 样就可以将其盲转发到目的服务器上去了。</p>
<p><img src="http://7xoefy.com1.z0.glb.clouddn.com/3.png" alt="img"></p>
<h4 id="Agent代理"><a href="#Agent代理" class="headerlink" title="Agent代理"></a>Agent代理</h4><p>Agent代理，发起自动HTTP请求的半智能Web客户端。<br>所有发布Web请求的应用程序都是HTTP Agent代理，包括Web浏览器、搜索引擎机器人。</p>
<h2 id="连接管理"><a href="#连接管理" class="headerlink" title="连接管理"></a>连接管理</h2><p><img src="http://7xoefy.com1.z0.glb.clouddn.com/4.png" alt="img"></p>
<p><img src="http://7xoefy.com1.z0.glb.clouddn.com/5.png" alt="img"></p>
<h3 id="HTTP事务的时延"><a href="#HTTP事务的时延" class="headerlink" title="HTTP事务的时延"></a>HTTP事务的时延</h3><p>与建立 TCP 连接，以及传输请求和响应报文的时间相比，事务处理时间可能 是很短的。除非客户端或服务器超载，或正在处理复杂的动态资源，否则 HTTP 时 延就是由 TCP 网络时延构成的。</p>
<h3 id="性能聚焦区域"><a href="#性能聚焦区域" class="headerlink" title="性能聚焦区域"></a>性能聚焦区域</h3><p>常见的TCP相关时延：</p>
<ul>
<li>TCP连接建立握手</li>
<li>TCP慢启动拥塞控制</li>
<li>数据聚焦的Nagle算法</li>
<li>用于捎带确认的TCP延迟确认算法</li>
<li>TIME_WAIT时延和端口耗尽</li>
</ul>
<h3 id="TCP慢启动"><a href="#TCP慢启动" class="headerlink" title="TCP慢启动"></a>TCP慢启动</h3><p>TCP数据传输的性能还取决于TCP连接的使用期。TCP连接会随着时间进行自我“调谐”，起初会限制连接的最大速度，如果数据成功传输，会随着时间的推移提高传输的速度。这种调谐被称为TCP慢启动，用于防止因特网的突然过载和拥塞。</p>
<p>TCP 慢启动限制了一个 TCP 端点在任意时刻可以传输的分组数。简单来说，每成功 接收一个分组，发送端就有了发送另外两个分组的权限。如果某个 HTTP 事务有大 量数据要发送，是不能一次将所有分组都发送出去的。必须发送一个分组，等待确 认；然后可以发送两个分组，每个分组都必须被确认，这样就可以发送四个分组了， 以此类推。这种方式被称为“打开拥塞窗口”。</p>
<p>由于存在这种拥塞控制特性，所以新连接的传输速度会比已经交换过一定量数据的、 “已调谐”连接慢一些。由于已调谐连接要更快一些，所以 HTTP 中有一些可以重用 现存连接的工具。本章稍后会介绍这些 HTTP“持久连接”。</p>
<h3 id="Nagle算法与TCP-NODELAY"><a href="#Nagle算法与TCP-NODELAY" class="headerlink" title="Nagle算法与TCP_NODELAY"></a>Nagle算法与TCP_NODELAY</h3><p>TCP 有一个数据流接口，应用程序可以通过它将任意尺寸的数据放入 TCP 栈中—— 即使一次只放一个字节也可以！但是，每个 TCP 段中都至少装载了 40 个字节的标 记和首部，所以如果 TCP 发送了大量包含少量数据的分组，网络的性能就会严重 下降。</p>
<p>Nagle 算法（根据其发明者 John Nagle 命名）试图在发送一个分组之前，将大量 TCP 数据绑定在一起，以提高网络效率。RFC 896“IP/TCP 互连网络中的拥塞控 制”对此算法进行了描述。</p>
<p>Nagle 算法鼓励发送全尺寸（LAN 上最大尺寸的分组大约是 1500 字节，在因特网 上是几百字节）的段。只有当所有其他分组都被确认之后，Nagle 算法才允许发送 非全尺寸的分组。如果其他分组仍然在传输过程中，就将那部分数据缓存起来。只 有当挂起分组被确认，或者缓存中积累了足够发送一个全尺寸分组的数据时，才会 将缓存的数据发送出去。</p>
<p>Nagle 算法会引发几种 HTTP 性能问题。首先，小的 HTTP 报文可能无法填满一个 分组，可能会因为等待那些永远不会到来的额外数据而产生时延。其次，Nagle 算 法与延迟确认之间的交互存在问题——Nagle 算法会阻止数据的发送，直到有确认 分组抵达为止，但确认分组自身会被延迟确认算法延迟 100 ～ 200 毫秒。</p>
<p>HTTP 应用程序常常会在自己的栈中设置参数 <code>TCP_NODELAY</code>，禁用 Nagle 算法， 提高性能。如果要这么做的话，一定要确保会向 TCP 写入大块的数据，这样就不会 产生一堆小分组了。</p>
<h3 id="串行事务处理时延"><a href="#串行事务处理时延" class="headerlink" title="串行事务处理时延"></a>串行事务处理时延</h3><ul>
<li><p>并行连接<br>通过多条TCP连接发起并发的HTTP请求。</p>
</li>
<li><p>持久连接<br>重用TCP连接，以消除连接及关闭时延。</p>
</li>
<li><p>管道化连接<br>通过共享的TCP连接发起并发的HTTP请求。</p>
</li>
<li><p>复用的连接<br>交替传送请求和响应报文（试验阶段）。</p>
</li>
</ul>
<h2 id="集成点：网关、隧道及中继"><a href="#集成点：网关、隧道及中继" class="headerlink" title="集成点：网关、隧道及中继"></a>集成点：网关、隧道及中继</h2><h3 id="网关"><a href="#网关" class="headerlink" title="网关"></a>网关</h3><p><img src="http://7xoefy.com1.z0.glb.clouddn.com/6.png" alt="img"></p>
<ul>
<li>协议网关</li>
<li>HTTP/*:服务器端Web网关</li>
<li>HTTP/HTTPS:服务器端安全网关</li>
<li>HTTPS/HTTP客户端安全加速器网关</li>
<li>资源网关<ul>
<li>CGI （Common Gateway Interface,CGI）<br>通用网关接口，CGI是一个标准接口集，Web服务器可以用它来装载程序以响应对特对URL的HTTP请求，并收集程序的输出数据，将其放在HTTP响应中回送。<br>CGI应用程序是独立于服务器的，所以，几乎可以用任意语言来实现，包括Perl、Tcl、C和各种shell语言。<br>它在服务器和众多的资源类型 之间提供了一种简单的、函数形式的粘合方式，用来处理各种需要的转换。这个接 口还能很好地保护服务器，防止一些糟糕的扩展对它造成的破坏（如果这些扩展直 接与服务器相连，造成的错误可能会引发服务器崩溃）。 但是，这种分离会造成性能的耗费。为每条 CGI 请求引发一个新进程的开销是很高 的，会限制那些使用 CGI 的服务器的性能，并且会加重服务端机器资源的负担。为 了解决这个问题，人们开发了一种新型 CGI——并将其恰当地称为快速 CGI。这个 接口模拟了 CGI，但它是作为持久守护进程运行的，消除了为每个请求建立或拆除 新进程所带来的性能损耗。</li>
</ul>
</li>
</ul>
<h3 id="隧道"><a href="#隧道" class="headerlink" title="隧道"></a>隧道</h3><p>Web隧道允许用户通过HTTP连接发送非HTTP流量，这样就可以在HTTP上捎带其他协议数据了。</p>
<h4 id="用CONNECT建立HTTP隧道"><a href="#用CONNECT建立HTTP隧道" class="headerlink" title="用CONNECT建立HTTP隧道"></a>用CONNECT建立HTTP隧道</h4><p>CONNECT请求：除了起始行之外，CONNECT的语法与其他HTTP方法类似。主机和端口都必须指定：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">CONNECT home.netscape.com:<span class="number">443</span> HTTP/<span class="number">1.0</span></div><div class="line">User-agent: Mozilla/<span class="number">4.0</span></div></pre></td></tr></table></figure></p>
<p>CONNECT响应：按照惯例，响应中的原因短语通常被设置为<code>Connection Established</code>：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">HTTP/<span class="number">1.0</span> <span class="number">200</span> Connection Established</div><div class="line"><span class="built_in">Proxy</span>-agent: Netscape-<span class="built_in">Proxy</span>/<span class="number">1.1</span></div></pre></td></tr></table></figure></p>
<p>与普通HTTP响应不同，这个响应并不需要包含<code>Content-Type</code>首部。此时连接至是对原始字节进行转接，不再是报文的承载者，所以不需要使用内容类型了。</p>
<h3 id="中继"><a href="#中继" class="headerlink" title="中继"></a>中继</h3><p>HTTP中继（relay）是没有完全遵循HTTP规范的简单HTTP代理。中继负责处理HTTP中建立连接的部分，然后对字节进行盲转发。</p>
<p>HTTP 很复杂，所以实现基本的代理功能并对流量进行盲转发，而且不执行任何首 部和方法逻辑，有时是很有用的。盲中继很容易实现，所以有时会提供简单的过滤、 诊断或内容转换功能。但这种方式可能潜在严重的互操作问题，所以部署的时候要 特别小心。</p>
<p>某些简单盲中继实现中存在的一个更常见（也更声名狼藉的）问题是，由于它们无 法正确处理 Connection 首部，所以有潜在的挂起 keep-alive 连接的可能。</p>
<h2 id="安全HTTP"><a href="#安全HTTP" class="headerlink" title="安全HTTP"></a>安全HTTP</h2><p><img src="http://7xoefy.com1.z0.glb.clouddn.com/7.png" alt="img"></p>
<h3 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h3><p><img src="http://7xoefy.com1.z0.glb.clouddn.com/8.png" alt="img"></p>
<p>大部分困难的编码及解码工作都是在 SSL 库中完成的，所以 Web 客户端和服务器 在使用安全 HTTP 时无需过多地修改其协议处理逻辑。在大多数情况下，只需要用 SSL 的输入 / 输出调用取代 TCP 的调用，再增加其他几个调用来配置和管理安全信 息就行了。</p>
<h3 id="数字加密"><a href="#数字加密" class="headerlink" title="数字加密"></a>数字加密</h3><p>基本概念：</p>
<ul>
<li>密码<br>对文本进行编码，使偷窥者无法识别的算法。</li>
<li>密钥<br>改变密码行为的数字化参数。</li>
<li>对称密钥加密系统<br>编/解码使用相同密钥的算法。</li>
<li>不对称密钥加密系统<br>编/解码使用不同密钥的算法。</li>
<li>公开密钥加密系统<br>一种能够使数百万计算机便捷地发送机密报文的系统。</li>
<li>数字签名<br>用来验证报文未被伪造或篡改的校验和。</li>
<li>数字认证<br>由一个可信的组织验证和签发的识别信息。</li>
</ul>
<h3 id="HTTPS方案"><a href="#HTTPS方案" class="headerlink" title="HTTPS方案"></a>HTTPS方案</h3><p>SSL 是个二进制协议，与 HTTP 完全不同，其流量是承载在另一个端口上的（SSL 通常是由端口 443 承载的）。如果 SSL 和 HTTP 流量都从端口 80 到达，大部分 Web 服务器会将二进制 SSL 流量理解为错误的 HTTP 并关闭连接。将安全服务进一步整 合到 HTTP 层中去就无需使用多个目的端口了，在实际中这样不会引发严重的问题。</p>
<h3 id="站点证书的有效性"><a href="#站点证书的有效性" class="headerlink" title="站点证书的有效性"></a>站点证书的有效性</h3><p>SSL自身不要求用户检查Web服务器证书，但大部分现代浏览器都会对证书进行简单的完整性检查，并为用户提供进行进一步彻查的手段。网景公司提出的一种Web服务器证书有效性算法是大部分浏览器有效性验证技术的基础。验证步骤如下所述：</p>
<ul>
<li>日期检测</li>
<li>签名颁发者可信度检测</li>
<li>签名检测</li>
<li>站点身份检测</li>
</ul>
<h3 id="OpenSSL"><a href="#OpenSSL" class="headerlink" title="OpenSSL"></a>OpenSSL</h3><p>OpenSSL是SSL和TLS最常见的开源实现。OpenSSL项目由一些志愿者合作开发，目标是开发一个强壮的、具有完备功能的商业级工具集，以实现SSL和TLS协议以及一个全功能的通用加密库。</p>
<h3 id="通过代理以隧道形式传输安全流量"><a href="#通过代理以隧道形式传输安全流量" class="headerlink" title="通过代理以隧道形式传输安全流量"></a>通过代理以隧道形式传输安全流量</h3><p>客户端通常会用 Web 代理服务器（参见第 6 章）代表它们来访问 Web 服务器。比 如，很多公司都会在公司网络和公共因特网的安全边界上放置一个代理（参见图 14-19）。代理是防火墙路由器唯一允许进行 HTTP 流量交换的设备，它可能会进行 病毒检测或其他的内容控制工作。但一旦客户端开始用服务器的公开密钥对发往服务器的数据进行加密，代理无法转发加密请求。</p>
<p>为了使HTTPS与代理配合工作，要进行几处修改以告知代理连接到何处。一种常用的技术就是HTTPS SSL隧道协议。 使用 HTTPS 隧道协议，客户端首先要告知代 理，它想要连接的安全主机和端口。这是在开始加密之前，以明文形式告知的，所 以代理可以理解这条信息。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;HTTP(Hypertext Transfer Protocol，超文本传输协议)是在万维网上进行通信时所使用的协议方案。HTTP最著名的是用于Web浏览器和Web服务器之间的双工通信。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>高性能网站建设指南</title>
    <link href="http://sheilacat.github.io/high-performance-web-sites/"/>
    <id>http://sheilacat.github.io/high-performance-web-sites/</id>
    <published>2015-10-21T05:36:44.000Z</published>
    <updated>2016-09-18T07:04:58.937Z</updated>
    
    <content type="html"><![CDATA[<ul>
<li>性能黄金法则（Performance Golden Rule）揭示了只有10%~20%的最终用户响应时间花在接收所请求的HTML文档上。剩下的80%~90%时间花在为HTML文档所引用的所有组件（图片、脚本、样式表、Flash等）进行的HTTP请求上。</li>
</ul>
<a id="more"></a>
<h2 id="减少HTTP请求"><a href="#减少HTTP请求" class="headerlink" title="减少HTTP请求"></a>减少HTTP请求</h2><p>用户在第一次访问你的网站时能更有效地减少HTTP请求的数量。</p>
<h3 id="图片地图-Image-Maps"><a href="#图片地图-Image-Maps" class="headerlink" title="图片地图 Image Maps"></a>图片地图 Image Maps</h3><p>图片地图允许你在一个图片关联多个URL，目标URL的选择取决于用户单击了图片上的哪个位置。</p>
<p>图片地图有两种类型：</p>
<ul>
<li>服务端图片地图（Server-side image maps）</li>
<li>客户端图片地图（Client-side image maps） 映射通过HTML的<code>map</code>标签实现</li>
</ul>
<h3 id="CSS-Sprites"><a href="#CSS-Sprites" class="headerlink" title="CSS Sprites"></a>CSS Sprites</h3><p>通过合并多张图片为一个，然后使用CSS的<code>background-position</code>属性，可以将HTML元素放置到背景图片中期望的位置上。</p>
<p>CSS Sprites还降低了图片下载量。很多人会认为合并后的图片会比分离的图片的总和要大，因为合并的图片中包含附件的空白区域。实际上，合并的图片会比分离的图片的总和要小，这是因为它降低了图片自身的开销（颜色表、格式信息、等等）。</p>
<h3 id="内联图片-Inline-Images"><a href="#内联图片-Inline-Images" class="headerlink" title="内联图片 Inline Images"></a>内联图片 Inline Images</h3><p>通过使用<code>data:URL</code>模式可以在Web页面中包含图片但无需任何额外的HTTP请求。尽管IE目前还不支持这种方式，但它能给其他浏览器带来的节省使得它值得关注。</p>
<p>缺陷在于浏览器支持和数据大小上的限制。另外，Base64编码会增加图片的大小。</p>
<h3 id="合并脚本和样式表"><a href="#合并脚本和样式表" class="headerlink" title="合并脚本和样式表"></a>合并脚本和样式表</h3><p>一个页面可能需要script1、script2和script3，而另一个页面可能需要script1、script3、script4。解决的方法是遵守编译型语言的模式，保持JavaScript的模块化，在生成过程中从一组特定的模块生成一个目标文件。</p>
<h2 id="使用内容发布网络"><a href="#使用内容发布网络" class="headerlink" title="使用内容发布网络"></a>使用内容发布网络</h2><p>CDN用于发布静态内容，如图片、脚本、样式表和Flash。提供动态HTML页面会引入特殊的存储需求——数据库连接、状态管理、验证、硬件和OS优化等。这些复杂性超越了CDN的能力范围。另一方面，静态文件更容易存储并具有较少的依赖性。</p>
<h2 id="添加Expires头"><a href="#添加Expires头" class="headerlink" title="添加Expires头"></a>添加Expires头</h2><p>HTTP1.1引入了Cache-Control头来克服Expires头的限制。因为Expires头使用一个特定的时间，它要求服务器和客户端的时钟严格同步。另外，过期日期需要经常检查，并且一旦未来这一天到来了，还需要在服务器配置中提供一个新的日期。换一种方式，Cache-Control使用<code>max-age</code>指令指定组件被缓存多久。它以秒为单位定义了一个更新窗。如果从组件被请求开始过去的秒数少于max-age，浏览器就使用缓存的版本，这就避免了额外的HTTP请求。如果这两者同时出现，HTTP规范规定max-age指令将重写Expires头。</p>
<h2 id="压缩组件"><a href="#压缩组件" class="headerlink" title="压缩组件"></a>压缩组件</h2><p>从HTTP1.1开始，Web客户端可以通过HTTP请求中的<code>Accept-Encoding</code>头来标识对压缩的支持。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Accept-Encoding: gzip,deflate</div></pre></td></tr></table></figure></p>
<p>一般支持gzip的不一定支持deflate，但支持deflate的一定支持gzip。一般来说，gzip比deflate能多压缩6%。<br>如果Web服务器看到请求中有这个头，就会使用客户端列出来的方法中的一种来压缩响应。Web服务器通过响应中的<code>Content-Encoding</code>头来通知Web客户端。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Content-Encoding: gzip</div></pre></td></tr></table></figure></p>
<p>压缩的成本有——服务器端会花费额外的CPU周期来完成压缩，客户端要对压缩文件进行解压缩。</p>
<h2 id="将样式表放在顶部"><a href="#将样式表放在顶部" class="headerlink" title="将样式表放在顶部"></a>将样式表放在顶部</h2><blockquote>
<p>进度指示器有三个主要优势——它们让用户知道系统没有崩溃，只是正则为他或她解决问题；它们指出了用户大概还需要等多久，以便用户能够在漫长的等待中做些其他事情；最后，它们能给用户提供一些可以看的东西，使得等待不再是那么无聊。</p>
</blockquote>
<p>将样式表放在文档底部会导致在浏览器中阻止内容<strong><em>逐步呈现</em></strong>。为避免当样式变化时重绘页面中的元素，浏览器会阻塞内容逐步呈现。“将样式表放在顶部”这条规则对于加载页面所需的实际时间没有太多影响，它影响更多的是浏览器对这些组件顺序的反应。实际上，用户感觉缓慢的页面反而是可视化组建加载得更快的页面。在浏览器和用户等待位于底部的样式表时，浏览器会延迟显示任何可视化组件。</p>
<h3 id="无样式内容的闪烁-Flash-of-Unstyled-Content"><a href="#无样式内容的闪烁-Flash-of-Unstyled-Content" class="headerlink" title="无样式内容的闪烁 Flash of Unstyled Content"></a>无样式内容的闪烁 Flash of Unstyled Content</h3><blockquote>
<p>如果样式表仍在加载，构建呈现树就是一种浪费，因为在所有样式表加载并解析完毕之前无需绘制任何东西。否则，在其准备好之前显示内容会遇到FOUC（无样式内容的闪烁）问题。</p>
</blockquote>
<p>白屏是浏览器在尝试修改前端工程师所犯的错误——将样式表放在文档比较靠后的位置。白屏是对FOUC问题的弥补。浏览器可以延迟呈现，直到所有的样式表都下载完之后，这就导致了白屏。</p>
<h2 id="将脚本放在底部"><a href="#将脚本放在底部" class="headerlink" title="将脚本放在底部"></a>将脚本放在底部</h2><h3 id="并行下载"><a href="#并行下载" class="headerlink" title="并行下载"></a>并行下载</h3><p>对响应时间影响最大的是页面中组件的数量。当缓存为空时，每个组件都会产生一个HTTP请求，有时即便缓存是完整的亦是如此。<strong><em>HTTP1.1规范建议浏览器从每个主机名并行地下载两个组件。</em></strong></p>
<p>今天的很多网站使用HTTP1.1，但将并行下载数增加到每个主机名超过两个也是有可能的。前端工程师与其依赖用户来修改浏览器设置，不如简单地使用CNAME（DNS别名）来将组件分别放到多个主机名中。但增加并行下载数量并不是没有开销的，其优劣取决于你的带宽和CPU速度，过多的并行下载反而会降低性能。Yahoo!的研究表明，使用两个主机名比使用1、4或10个主机名能带来更好的性能。</p>
<h3 id="脚本阻塞下载"><a href="#脚本阻塞下载" class="headerlink" title="脚本阻塞下载"></a>脚本阻塞下载</h3><p>并行下载组件的有点是很明显的。然而，在下载脚本时并行下载实际上是被禁用的——即使使用了不同的主机名，浏览器也不会启动其他的下载。其中一个原因是，脚本可能使用document.write来修改页面内容，因此浏览器会等待，以确保页面能够恰当地布局。</p>
<p>在下载脚本时浏览器阻塞并行下载的另外一个原因是为了保证脚本能够按照正确的顺序执行。如果并行下载多个脚本，就无法保证响应是按照特定顺序到达浏览器的。例如，后面的脚本比页面中之前出现的脚本更小，它可能首先执行。如果它们之间存在着依赖关系，不按顺序执行就会导致JavaScript错误。</p>
<p>如果将脚本放在顶部，脚本会阻塞对其后面内容的呈现、对其后面组件的下载。</p>
<h2 id="避免CSS表达式"><a href="#避免CSS表达式" class="headerlink" title="避免CSS表达式"></a>避免CSS表达式</h2><p>表达式的问题在于对其进行的求值的频率比人们期望的要高。它们不止在页面呈现和大小改变时求值，当页面滚动、甚至用户鼠标在页面上移过时都要求值。</p>
<p>有两种技术可以避免CSS表达式产生这一问题——创建一次性表达式和使用事件处理器取代CSS表达式。</p>
<h2 id="使用外部JavaScript和CSS"><a href="#使用外部JavaScript和CSS" class="headerlink" title="使用外部JavaScript和CSS"></a>使用外部JavaScript和CSS</h2><p>使用外部JS和CSS，关键是外部文件所带来的收益——JavaScript和CSS文件有机会被浏览器缓存起来。HTML文档——至少是那些包含动态内容的HTML文档——通常不会被配置为可以进行缓存。另一方面，如果JS和CSS是外部文件，浏览器就能缓存他们，HTML文档的大小减小，而且不会增加HTTP请求的数量。</p>
<p>关键因素是，与HTML文档请求数量相关的、外部JavaScript和CSS组件被缓存的频率。这可通过以下衡量：</p>
<ul>
<li>Page View</li>
<li>空缓存与完整缓存</li>
<li>组件重用</li>
</ul>
<h3 id="两全其美的方法"><a href="#两全其美的方法" class="headerlink" title="两全其美的方法"></a>两全其美的方法</h3><ul>
<li>加载后下载</li>
<li>动态内联</li>
</ul>
<h2 id="减少DNS查找"><a href="#减少DNS查找" class="headerlink" title="减少DNS查找"></a>减少DNS查找</h2><p>DNS也是开销。通常浏览器查找一个给定的主机名的IP地址要花费20~120毫秒。在DNS查找完成之前，浏览器不能呢个从主机名那里下载到任何东西。响应时间依赖于DNS解析器（通常由你的ISP提供）、它所承担的请求压力、你与它之间的距离和你的带宽速度。</p>
<h3 id="DNS缓存和TTL"><a href="#DNS缓存和TTL" class="headerlink" title="DNS缓存和TTL"></a>DNS缓存和TTL</h3><p>DNS查找可以被缓存起来以提高性能。这种缓存可以发生在由你的ISP或局域网中的一台特殊的缓存服务器上。但我们这里要探索的是发生在独立用户的计算机上的DNS缓存；在用户请求了一个主机名之后，DNS信息会留在操作系统的DNS缓存中（Microsoft Windows上的“DNS Client服务“），之后对该主机名的请求将无需进行过多的DNS查找，至少短时间内不需要。</p>
<p>很多浏览器拥有其自己的缓存，和操作系统的缓存相分离。只要浏览器在其缓存中保留了DNS记录，它就不会麻烦操作系统来请求这个记录。只有当浏览器缓存丢弃了记录，它才会向操作系统询问地址——然后操作系统或者通过其缓存来相应这个请求，或者将请求发送给一台远程服务器，这时就会发生潜在的速度降低。</p>
<h3 id="影响DNS缓存的因素"><a href="#影响DNS缓存的因素" class="headerlink" title="影响DNS缓存的因素"></a>影响DNS缓存的因素</h3><p>服务器可以表明记录可以被缓存多久。查找返回的DNS记录包含了一个存活时间（Time-to-live，TTL）值。该值告诉客户端可以对该记录缓存多久。</p>
<p>尽管操作系统缓存会考虑TTL值，但浏览器通常忽略该值，并设置它自己的时间限制。</p>
<p>浏览器对缓存的DNS记录的数量也有限制，而不管缓存记录的时间。</p>
<p>TTL值短的原因一般是拥有巨大数量用户的顶级网站在努力做到当服务器、虚拟IP地址（VIP）或联合定位掉线时提供<strong><em>快速故障转移</em></strong>。如果长的话，一般是因为定位到一个联合定位工具，对于其当前的网络拓补，故障转移并不是那么重要，因此较长的TTL可以减少DNS查找，同时也降低了其名称服务器的负载。</p>
<h3 id="减少DNS查找-1"><a href="#减少DNS查找-1" class="headerlink" title="减少DNS查找"></a>减少DNS查找</h3><p>当客户端的DNS缓存为空（浏览器和操作系统都是）时，DNS查找的数量与Web页面中唯一主机名的数量相等。这包括页面URL、图片、脚本文件、样式表、Flash对象等的主机名。减少唯一主机名的数量就可以减少DNS查找的数量。</p>
<p>减少唯一主机名的数量会潜在地减少页面中并行下载的数量。避免DNS查找降低了响应时间，但减少并行下载可能会响应时间。建议是至少2个，但不要超过4个主机名下。</p>
<p>使用Keep-Alive所带来的好处在于，它可以通过重用现有连接，从而通过避免TCP/IP开销来减少响应时间。确保服务器支持Keep-Alive还能减少DNS查找。</p>
<p><strong><em>通过使用Keep-Alive和较少的域名来减少DNS查找。</em></strong></p>
<h2 id="精简JavaScript"><a href="#精简JavaScript" class="headerlink" title="精简JavaScript"></a>精简JavaScript</h2><h3 id="精简-Minification"><a href="#精简-Minification" class="headerlink" title="精简 Minification"></a>精简 Minification</h3><p>精简是从代码中移除不必要的字符以减小其大小。</p>
<h3 id="混淆-Obfuscation"><a href="#混淆-Obfuscation" class="headerlink" title="混淆 Obfuscation"></a>混淆 Obfuscation</h3><p>混淆除了精简外，还会改写代码。函数和变量的名字将被转换为更短的字符串，这样做是为了增加对代码进行反向工程的难度。</p>
<p>混淆JavaScript有以下缺点：</p>
<ul>
<li>缺陷</li>
</ul>
<p>由于混淆更加复杂，混淆过程本身很有可能引入错误。</p>
<ul>
<li>维护</li>
</ul>
<p>由于混淆会改变JavaScript符号，因此需要对任何不能改变的符号（例如API函数）进行标记，防止混淆器修改它们。</p>
<ul>
<li>调试</li>
</ul>
<p>经过混淆的代码很难阅读。这使得在产品环境中调试问题更加困难。</p>
<p>在结合使用了gzip压缩之后，精简和混淆之间的差距将会减小。精简脚本可以降低响应时间，但不会带来混淆的风险。</p>
<h3 id="精简CSS"><a href="#精简CSS" class="headerlink" title="精简CSS"></a>精简CSS</h3><p>精简CSS能够带来的节省通常要小于精简JS。最大的潜在节省来自于优化CSS。</p>
<h2 id="避免重定向"><a href="#避免重定向" class="headerlink" title="避免重定向"></a>避免重定向</h2><p>重定向引起的延迟很严重，因为它延迟了整个HTML文档的传输。</p>
<p>重定向用于将用户从一个URL重新路由到另一个URL。重定向有很多种——301和302是最常用的两种。通常针对HTML文档进行重定向，但通常也可能用在请球页面中的组件时。实现重定向可能有很多不同的原因，包括网站重新设计、跟踪流量、记录广告点击和简历易于记忆的URL。</p>
<p><strong><em>重定向会使你的页面变慢。</em></strong></p>
<ul>
<li>300 Multiple Choices（基于Content-Type）</li>
<li>301 Moved Permancently</li>
<li>302 Moved Temporarily</li>
<li>303 See Other（对302的说明）</li>
<li>304 Not Modified （并不是真的重定向，对GET请求的回应）</li>
<li>305 Use Proxy</li>
<li>306 （不再使用）</li>
<li>307 Temporary Redirect（对302的说明）</li>
</ul>
<p>状态码301和302是使用得最多的。状态码303和307是在HTTP1.1规范中添加的，用来澄清对302的使用（滥用），但几乎没有人用它们，绝大多数网站仍然在沿用302。</p>
<h3 id="重定向之外的其他选择"><a href="#重定向之外的其他选择" class="headerlink" title="重定向之外的其他选择"></a>重定向之外的其他选择</h3><ul>
<li><p>解决缺少结尾斜线的问题</p>
</li>
<li><p>连接网站</p>
</li>
</ul>
<p>Alias、mod_rewrite、DirectorySlash和直接链接代码来避免重定向。</p>
<h2 id="移除重复脚本"><a href="#移除重复脚本" class="headerlink" title="移除重复脚本"></a>移除重复脚本</h2><p>重复脚本损伤性能——不必要的HTTP请求和执行JavaScript所浪费的时间。</p>
<ul>
<li><p>在页面中多次包含相同的脚本会使页面变慢。</p>
</li>
<li><p>在IE中，如果脚本没有被缓存，或在重新加载页面时，会产生额外的HTTP请求。</p>
</li>
<li><p>在Firefox和IE中，脚本会被多次求值。</p>
</li>
</ul>
<h2 id="配置或移除ETag"><a href="#配置或移除ETag" class="headerlink" title="配置或移除ETag"></a>配置或移除ETag</h2><p>ETag的问题在于，对于服务器集群来处理请求的网站来说，ETag在不同服务器是不匹配的。默认情况下，对于拥有多台服务器的网站，Apache和IIS向ETag中嵌入的数据都会大大地降低有效性验证的成功率。</p>
<p>从ETag中移除ChangeNumber或完全移除ETag可以避免当数据已经位于浏览器缓存中时进行不必要的和低效的下载。</p>
<h2 id="使Ajax可缓存"><a href="#使Ajax可缓存" class="headerlink" title="使Ajax可缓存"></a>使Ajax可缓存</h2><p>确保Ajax请求遵守性能知道，尤其应具有长久的Expires头。</p>
<p>本篇文章参考《高性能网站建设指南》<br>提到的优化方法参见<a href="http://stevesouders.com/hpws/rules.php" target="_blank" rel="external">http://stevesouders.com/hpws/rules.php</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;性能黄金法则（Performance Golden Rule）揭示了只有10%~20%的最终用户响应时间花在接收所请求的HTML文档上。剩下的80%~90%时间花在为HTML文档所引用的所有组件（图片、脚本、样式表、Flash等）进行的HTTP请求上。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="http://sheilacat.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>Express4.x入门</title>
    <link href="http://sheilacat.github.io/basic-express/"/>
    <id>http://sheilacat.github.io/basic-express/</id>
    <published>2015-09-22T11:28:31.000Z</published>
    <updated>2016-09-18T07:04:56.846Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Express，基于<code>Node.js</code>平台，快速、开放、极简的web开发框架。</p>
<p><img src="http://thumbsnap.com/i/sEtWabU1.png?0922" alt="img"></p>
<a id="more"></a>
<p>性能方面，express不对Node.js已有的特性进行二次抽象，只是在它之上扩展了Web应用所需的基本功能。</p>
<p>本篇记录了Express 4中文API中的一些重点部分，作为Express大体的入门参考，了解Express的主要组成。</p>
<h2 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h2><h3 id="express应用生成器"><a href="#express应用生成器" class="headerlink" title="express应用生成器"></a>express应用生成器</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ npm install express-generator -g</div></pre></td></tr></table></figure>
<h3 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h3><p>路由（Routing）是由一个 URI（或者叫路径）和一个特定的 HTTP 方法（GET、POST 等）组成的，涉及到应用如何响应客户端对某个网站节点的访问。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">app.get(<span class="string">'/'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</div><div class="line">  res.send(<span class="string">'Hello World!'</span>);&#125;);</div></pre></td></tr></table></figure>
<p>路由路径可以用字符串、字符串模式、正则表达式来匹配路径。<br>对于字符串模式，字符 ?、+、* 和 () 是正则表达式的子集，- 和 . 在基于字符串的路径中按照字面值解释。</p>
<h3 id="响应方法"><a href="#响应方法" class="headerlink" title="响应方法"></a>响应方法</h3><p>响应方法</p>
<p>下表中响应对象（res）的方法向客户端返回响应，终结请求响应的循环。如果在路由句柄中一个方法也不调用，来自客户端的请求会一直挂起。</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>res.download()</td>
<td>提示下载文件。</td>
</tr>
<tr>
<td>res.end()</td>
<td>终结响应处理流程。</td>
</tr>
<tr>
<td>res.json()</td>
<td>发送一个 JSON 格式的响应。</td>
</tr>
<tr>
<td>res.jsonp()</td>
<td>发送一个支持 JSONP 的 JSON 格式的响应。</td>
</tr>
<tr>
<td>res.redirect()</td>
<td>重定向请求。</td>
</tr>
<tr>
<td>res.render()</td>
<td>渲染视图模板。</td>
</tr>
<tr>
<td>res.send()</td>
<td>发送各种类型的响应。</td>
</tr>
<tr>
<td>res.sendFile</td>
<td>以八位字节流的形式发送文件。</td>
</tr>
<tr>
<td>res.sendStatus()</td>
<td>设置响应状态代码，并将其以字符串形式作为响应体的一部分发送。</td>
</tr>
</tbody>
</table>
<h3 id="路由方法"><a href="#路由方法" class="headerlink" title="路由方法"></a>路由方法</h3><p>Express 定义了如下和 HTTP 请求对应的路由方法： get, post, put, head, delete, options, trace, copy, lock, mkcol, move, purge, propfind, proppatch, unlock, report, mkactivity, checkout, merge, m-search, notify, subscribe, unsubscribe, patch, search, 和 connect。</p>
<p>有些路由方法名不是合规的 JavaScript 变量名，此时使用括号记法，比如： app[‘m-search’](‘/‘, function …</p>
<h3 id="app-route"><a href="#app-route" class="headerlink" title="app.route()"></a>app.route()</h3><p>可使用 app.route() 创建路由路径的链式路由句柄。由于路径在一个地方指定，这样做有助于创建模块化的路由，而且减少了代码冗余和拼写错误。</p>
<h3 id="express-Router"><a href="#express-Router" class="headerlink" title="express.Router"></a>express.Router</h3><p>可使用 express.Router 类创建模块化、可挂载的路由句柄。Router 实例是一个完整的中间件和路由系统，因此常称其为一个 “mini-app”。</p>
<p>下面的实例程序创建了一个路由模块，并加载了一个中间件，定义了一些路由，并且将它们挂载至应用的路径上。</p>
<h3 id="静态文件"><a href="#静态文件" class="headerlink" title="静态文件"></a>静态文件</h3><p>利用 Express 托管静态文件</p>
<p>如果你的静态资源存放在多个目录下面，你可以多次调用 express.static 中间件：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">app.use(express.static(<span class="string">'public'</span>));</div><div class="line"></div><div class="line">app.use(express.static(<span class="string">'files'</span>));</div></pre></td></tr></table></figure></p>
<p>访问静态资源文件时，express.static 中间件会根据目录添加的顺序查找所需的文件。</p>
<p>如果你希望所有通过 express.static 访问的文件都存放在一个“虚拟（virtual）”目录（即目录根本不存在）下面，可以通过为静态资源目录指定一个挂载路径的方式来实现，如下所示：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">app.use(<span class="string">'/static'</span>, express.static(<span class="string">'public'</span>));</div></pre></td></tr></table></figure></p>
<h3 id="如何处理-404-？"><a href="#如何处理-404-？" class="headerlink" title="如何处理 404 ？"></a>如何处理 404 ？</h3><p>在 Express 中，404 并不是一个错误（error）。因此，错误处理器中间件并不捕获 404。这是因为 404 只是意味着某些功能没有实现。也就是说，Express 执行了所有中间件、路由之后还是没有获取到任何输出。你所需要做的就是在其所有他中间件的后面添加一个处理 404 的中间件。如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">app.use(<span class="function"><span class="keyword">function</span>(<span class="params">req, res, next</span>) </span>&#123;</div><div class="line">  res.status(<span class="number">404</span>).send(<span class="string">'Sorry cant find that!'</span>);&#125;);</div></pre></td></tr></table></figure></p>
<p>如何设置一个错误处理器？</p>
<p>错误处理器中间件的定义和其他中间件一样，唯一的区别是 <code>4 个</code>而不是 3 个参数，即 (err, req, res, next)：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">app.use(<span class="function"><span class="keyword">function</span>(<span class="params">err, req, res, next</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.error(err.stack);</div><div class="line">  res.status(<span class="number">500</span>).send(<span class="string">'Something broke!'</span>);&#125;);</div></pre></td></tr></table></figure>
<p>请参考错误处理章节以了解更多信息。</p>
<p>如何渲染纯 HTML 文件？</p>
<p>不需要！无需通过 res.render() 渲染 HTML。你可以通过 res.sendFile() 直接对外输出 HTML 文件。如果你需要对外提供的资源文件很多，可以使用 express.static() 中间件。</p>
<h2 id="内置方法"><a href="#内置方法" class="headerlink" title="内置方法"></a>内置方法</h2><h3 id="express-static-root-options"><a href="#express-static-root-options" class="headerlink" title="express.static(root,[options]]"></a>express.static(root,[options]]</h3><p><code>express.static</code>是Express内置的唯一一个中间件。是基于<code>serve-static</code>开发的，负责托管Express应用内的静态资源。</p>
<h2 id="从Express-3迁移到Express-4"><a href="#从Express-3迁移到Express-4" class="headerlink" title="从Express 3迁移到Express 4"></a>从Express 3迁移到Express 4</h2><p>实例</p>
<p>运行下述命令创建一个 Express 4 应用：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ express app4</div></pre></td></tr></table></figure></p>
<p>如果查看 app4/app.js 的内容，会发现应用需要的所有中间件（不包括 express.static）都作为独立模块载入，而且再不显式地加载 router 中间件。</p>
<p>您可能还会发现，和旧的生成器生成的应用相比， app.js 现在成了一个 Node 模块。</p>
<p>安装完依赖后，使用如下命令启动应用：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ npm start</div></pre></td></tr></table></figure></p>
<p>如果看一看 package.json 文件中的 npm 启动脚本，会发现启动应用的真正命令是 <code>node ./bin/www</code>，在 Express 3 中则为 node app.js。</p>
<p>Express 4 应用生成器生成的 app.js 是一个 Node 模块，不能作为应用（除非修改代码）单独启动，需要通过一个 Node 文件加载并启动，这里这个文件就是 node ./bin/www。</p>
<p>创建或启动 Express 应用时，bin 目录或者文件名没有后缀的 www 文件都不是必需的，它们只是生成器推荐的做法，请根据需要修改。</p>
<p>如果不想保留 www，想让应用变成 Express 3 的形式，则需要删除 module.exports = app;，并在 app.js 末尾粘贴如下代码。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">app.set(<span class="string">'port'</span>, process.env.PORT || <span class="number">3000</span>);</div><div class="line"></div><div class="line"><span class="keyword">var</span> server = app.listen(app.get(<span class="string">'port'</span>), <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  debug(<span class="string">'Express server listening on port '</span> + server.address().port);&#125;);</div></pre></td></tr></table></figure></p>
<p>记得在 app.js 上方加入如下代码加载 debug 模块。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> debug = <span class="built_in">require</span>(<span class="string">'debug'</span>)(<span class="string">'app4'</span>);</div></pre></td></tr></table></figure></p>
<p>然后将 package.json 文件中的 “start”: “node ./bin/www” 修改为 “start”: “node app.js”。</p>
<p>现在就将 ./bin/www 的功能又改回到 app.js 中了。我们并不推荐这样做，这个练习只是为了帮助大家理解 ./bin/www 是如何工作的，以及为什么 app.js不能再自己启动。</p>
<p>参考<br><a href="http://www.expressjs.com.cn/" target="_blank" rel="external">express 中文API</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;Express，基于&lt;code&gt;Node.js&lt;/code&gt;平台，快速、开放、极简的web开发框架。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://thumbsnap.com/i/sEtWabU1.png?0922&quot; alt=&quot;img&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>缓存策略</title>
    <link href="http://sheilacat.github.io/cache-strategy/"/>
    <id>http://sheilacat.github.io/cache-strategy/</id>
    <published>2015-09-16T09:22:48.000Z</published>
    <updated>2016-09-18T07:04:57.418Z</updated>
    
    <content type="html"><![CDATA[<p>学习整理了web缓存的一些策略，如有不正确的地方，欢迎指正。</p>
<p><img src="http://thumbsnap.com/i/bTOegvzm.png?0809" alt="缓存策略"></p>
<a id="more"></a>
<h1 id="浏览器端的缓存规则"><a href="#浏览器端的缓存规则" class="headerlink" title="浏览器端的缓存规则"></a>浏览器端的缓存规则</h1><p>对于浏览器端的缓存来讲，这些规则是在<code>HTTP协议头</code>和<code>HTML页面的Meta标签</code>中定义的。他们分别从<strong>新鲜度</strong>和<strong>校验值</strong>两个维度来规定浏览器是否可以直接使用缓存中的副本，还是需要去源服务器获取更新的版本。</p>
<p><strong>新鲜度（过期机制）</strong>：也就是缓存副本有效期。一个缓存副本必须满足以下条件，浏览器会认为它是有效的，足够新的：</p>
<ul>
<li>含有完整的过期时间控制头信息（HTTP协议报头），并且仍在有效期内；</li>
<li>浏览器已经使用过这个缓存副本，并且在一个会话中已经检查过新鲜度</li>
</ul>
<p>满足以上两个情况的一种，浏览器会直接从缓存中获取副本并渲染。</p>
<p><strong>校验值（验证机制）</strong>：服务器返回资源的时候有时在控制头信息带上这个资源的实体标签<code>Etag（Entity Tag）</code>，它可以用来作为浏览器再次请求过程的校验标识。如过发现校验标识不匹配，说明资源已经被修改或过期，浏览器需求重新获取资源内容。</p>
<h4 id="一个重要的概念"><a href="#一个重要的概念" class="headerlink" title="一个重要的概念"></a>一个重要的概念</h4><p><strong>缓存命中率</strong>：一个缓存的有效性是依照缓存的命中率来度量。它是根据得到数据请求次数与所有请求次数的比率。缓存命中率高意味着有很高的比率数据是从缓存中获取到数据的。</p>
<p>在HTTP请求和响应的消息报头中，常见的与缓存有关的消息报头有：</p>
<p><img src="http://thumbsnap.com/i/4ltwyuXH.png?0809" alt="图片"></p>
<h2 id="Web缓存的作用"><a href="#Web缓存的作用" class="headerlink" title="Web缓存的作用"></a>Web缓存的作用</h2><ul>
<li>减少网络带宽消耗</li>
<li>降低服务器压力</li>
<li>减少网络延迟，加快页面打开速度</li>
</ul>
<h2 id="HTTP缓存机制"><a href="#HTTP缓存机制" class="headerlink" title="HTTP缓存机制"></a>HTTP缓存机制</h2><p>缓存行为主要由缓存策略决定，而缓存策略由内容拥有者设置。这些策略主要通过特定的HTTP头部来清晰地表达。</p>
<p>当一个用户发起一个静态资源请求的时候，浏览器会通过以下几步来获取资源：</p>
<ul>
<li>本地缓存阶段：先在本地查找该资源，如果有发现该资源，而且该资源还没有过期，就使用这一个资源，完全不会发送http请求到服务器；</li>
<li>协商缓存阶段：如果在本地缓存找到对应的资源，但是不知道该资源是否过期或者已经过期，则发一个http请求到服务器,然后服务器判断这个请求，如果请求的资源在服务器上没有改动过，则返回304，让浏览器使用本地找到的那个资源；</li>
<li>缓存失败阶段：当服务器发现请求的资源已经修改过，或者这是一个新的请求(在本来没有找到资源)，服务器则返回该资源的数据，并且返回200， 当然这个是指找到资源的情况下，如果服务器上没有这个资源，则返回404。</li>
</ul>
<h2 id="用户操作行为与缓存"><a href="#用户操作行为与缓存" class="headerlink" title="用户操作行为与缓存"></a>用户操作行为与缓存</h2><p><img src="http://thumbsnap.com/i/TYHrxqQt.png?0809" alt="img"></p>
<p>浏览器中的操作对缓存的影响:</p>
<ul>
<li>强制刷新 – 当按下ctrl+F5来刷新页面的时候, 浏览器将绕过各种缓存(本地缓存和协商缓存), 直接让服务器返回最新的资源;</li>
<li>普通刷新 – 当按下F5来刷新页面的时候,浏览器将绕过本地缓蹲来发送请求到服务器, 此时, 协商缓存是有效的</li>
<li>回车或转向 – 当在地址栏上输入回车或者按下跳转按钮的时候, 所有缓存都生效</li>
</ul>
<h2 id="本地缓存阶段"><a href="#本地缓存阶段" class="headerlink" title="本地缓存阶段"></a>本地缓存阶段</h2><h4 id="Expires"><a href="#Expires" class="headerlink" title="Expires"></a>Expires</h4><p>指定缓存到期GMT的绝对时间，如果设了<code>max-age</code>，<code>max-age</code>就会覆盖<code>expires</code>。如果<code>expires</code>到期需要重新请求。</p>
<h4 id="Cache-Control"><a href="#Cache-Control" class="headerlink" title="Cache-Control"></a>Cache-Control</h4><p>Cache-Control:这个是http 1.1中为了弥补 Expires 缺陷新加入的。</p>
<p>对已缓存的内容进行控制：</p>
<p><code>Cache-control: public</code>表示缓存的版本可以被代理服务器或者其他中间服务器识别。</p>
<p><code>Cache-control: private</code>意味着这个文件对不同的用户是不同的。只有用户自己的浏览器能够进行缓存，公共的代理服务器不允许缓存。</p>
<p><code>Cache-control: no-cache</code>意味着文件的内容不应当被缓存。这在搜索或者翻页结果中非常有用，因为同样的URL，对应的内容会发生变化。</p>
<p>其他相关控制字段：</p>
<p>max-age: 指定缓存过期的相对时间秒数，max-ag=0或者是负值，浏览器会在对应的缓存中把Expires设置为1970-01-01 08:00:00 。</p>
<p>s-maxage: 类似于max-age，只用在共享缓存上，比如proxy.</p>
<p>public: 通常情况下需要http身份验证的情况，响应是不可cahce的，加上public可以使它被cache。</p>
<p>no-cache: 强制浏览器在使用cache拷贝之前先提交一个http请求到源服务器进行确认。这对身份验证来说是非常有用的,能比较好的遵守 (可以结合public进行考虑)。它对维持一个资源总是最新的也很有用，与此同时还不完全丧失cache带来的好处)，因为它在本地是有拷贝的，但是在用之前都进行了确认，这样http请求并未减少，但可能会减少一个响应体。</p>
<p>no-store:  告诉浏览器在任何情况下都不要进行cache，不在本地保留拷贝。</p>
<p>must-revalidate: 强制浏览器严格遵守你设置的cache规则。</p>
<p>proxy-revalidate: 强制proxy严格遵守你设置的cache规则。</p>
<p>用法举例:  Cache-Control: max-age=3600, must-revalidate</p>
<p>cache:使用本地缓存，不发生请求。</p>
<h2 id="协商缓存阶段"><a href="#协商缓存阶段" class="headerlink" title="协商缓存阶段"></a>协商缓存阶段</h2><h4 id="Last-Modified-amp-if-modified-since"><a href="#Last-Modified-amp-if-modified-since" class="headerlink" title="Last-Modified &amp; if-modified-since"></a>Last-Modified &amp; if-modified-since</h4><p>Last-Modified与If-Modified-Since是一对报文头，属于http 1.0。</p>
<p>last-modified是WEB服务器认为对象的最后修改时间，比如文件的最后修改时间，动态页面的最后产生时间。</p>
<h4 id="ETag-amp-If-None-Match"><a href="#ETag-amp-If-None-Match" class="headerlink" title="ETag &amp; If-None-Match"></a>ETag &amp; If-None-Match</h4><p>ETag与If-None-Match是一对报文，属于http 1.1。 </p>
<p>ETag可以用来解决这种问题。ETag是一个文件的唯一标志符。就像一个哈希或者指纹，每个文件都有一个单独的标志，只要这个文件发生了改变，这个标志就会发生变化。</p>
<p>ETag机制类似于乐观锁机制，如果请求报文的ETag与服务器的不一致，则表示该资源已经被修改过来，需要发最新的内容给浏览器。 </p>
<p>同时使用这两个报文头，在完全匹配If-Modified-Since和If-None-Match即检查完修改时间和Etag之后，如都与服务器的相符，服务器返回304，否则，发送最新内容给浏览器。 </p>
<p><strong>Etag/lastModified过程如下</strong>：</p>
<p>1.客户端请求一个页面（A）。</p>
<p>2.服务器返回页面A，并在给A加上一个Last-Modified/ETag。</p>
<p>3.客户端展现该页面，并将页面连同Last-Modified/ETag一起缓存。</p>
<p>4.客户再次请求页面A，并将上次请求时服务器返回的Last-Modified/ETag一起传递给服务器。</p>
<p>5.服务器检查该Last-Modified或ETag，并判断出该页面自上次客户端请求之后还未被修改，直接返回响应304和一个空的响应体。</p>
<blockquote>
<p>304：通过If-Modified-Since If-Match判断资源是否修改，如未修改则返回304，发生了一次请求，但请求内容长度为0，节省了带宽。<br>如果有多台负载均衡的服务器，不同服务器计算出的Etag可能不同，这样就会造成资源的重复加载。</p>
</blockquote>
<p><strong>Etag 主要为了解决 Last-Modified 无法解决的一些问题</strong>：</p>
<p>1、一些文件也许会周期性的更改，但是他的内容并不改变(仅仅改变的修改时间)，这个时候我们并不希望客户端认为这个文件被修改了，而重新GET；</p>
<p>2、某些文件修改非常频繁，比如在秒以下的时间内进行修改，(比方说1s内修改了N次)，If-Modified-Since能检查到的粒度是s级的，这种修改无法判断(或者说UNIX记录MTIME只能精确到秒)；</p>
<p>3、某些服务器不能精确的得到文件的最后修改时间。</p>
<h4 id="其他标签"><a href="#其他标签" class="headerlink" title="其他标签"></a>其他标签</h4><p><strong>Content-Length</strong>：尽管并没有在缓存中明确涉及，Content-Length头部在设置缓存策略时很重要。某些软件如果不提前获知内容的大小以留出足够空间，则会拒绝缓存该内容。</p>
<p><strong>Vary</strong>：缓存系统通常使用请求的主机和路径作为存储该资源的键。当判断一个请求是否是请求同样内容时，Vary头部可以被用来提醒缓存系统需要注意另一个附加头部。它通常被用来告诉缓存系统同样注意Accept-Encoding头部，以便缓存系统能够区分压缩和未压缩的内容。</p>
<h1 id="服务器端缓存"><a href="#服务器端缓存" class="headerlink" title="服务器端缓存"></a>服务器端缓存</h1><h2 id="CDN缓存"><a href="#CDN缓存" class="headerlink" title="CDN缓存"></a>CDN缓存</h2><p>CDN缓存，也叫网关缓存、反向代理缓存。浏览器先向CDN网关发起WEB请求，网关服务器后面对应着一台或多台负载均衡源服务器，会根据它们的负载请求，动态地请求转发到合适的源服务器上。</p>
<h4 id="CDN缓存策略"><a href="#CDN缓存策略" class="headerlink" title="CDN缓存策略"></a>CDN缓存策略</h4><p>CDN边缘节点缓存策略因服务商不同而不同，但一般都会遵循http标准协议，通过http响应头中的<code>Cache-control: max-age</code>的字段来设置CDN边缘节点数据缓存时间。</p>
<p>当客户端向CDN节点请求数据时，CDN节点会判断缓存数据是否过期，若缓存数据并没有过期，则直接将缓存数据返回给客户端；否则，CDN节点就会向源站发出<code>回源请求（back to the source request）</code>，从源站拉取最新数据，更新本地缓存，并将最新数据返回给客户端。</p>
<p>CDN服务商一般会提供基于文件后缀、目录多个维度来指定CDN缓存时间，为用户提供更精细化的缓存管理。</p>
<p>CDN缓存时间会对<code>“回源率”</code>产生直接的影响。若CDN缓存时间较短，CDN边缘节点上的数据会经常失效，导致频繁回源，增加了源站的负载，同时也增大的访问延时；若CDN缓存时间太长，会带来数据更新时间慢的问题。开发者需要增对特定的业务，来做特定的数据缓存时间管理。</p>
<p>CDN缓存刷新CDN边缘节点对开发者是透明的，相比于浏览器Ctrl+F5的强制刷新来使浏览器本地缓存失效，开发者可以通过CDN服务商提供的“刷新缓存”接口来达到清理CDN边缘节点缓存的目的。这样开发者在更新数据后，可以使用“刷新缓存”功能来强制CDN节点上的数据缓存过期，保证客户端在访问时，拉取到最新的数据。</p>
<h4 id="CDN的优势"><a href="#CDN的优势" class="headerlink" title="CDN的优势"></a>CDN的优势</h4><ul>
<li>CDN节点解决了跨运营商和跨地域访问的问题，访问延时大大降低；</li>
<li>大部分请求在CDN边缘节点完成，CDN起到了分流作用，减轻了源站的负载。</li>
</ul>
<h4 id="CDN缓存的缺点"><a href="#CDN缓存的缺点" class="headerlink" title="CDN缓存的缺点"></a>CDN缓存的缺点</h4><p>当网站更新时，如果CDN节点上数据没有及时更新，即便用户再浏览器使用Ctrl +F5的方式使浏览器端的缓存失效，也会因为CDN边缘节点没有同步最新数据而导致用户访问异常。</p>
<p>CDN架构及原理参见<a href="http://blog.yemou.net/article/query/info/tytfjhfascvhzxcytp61" target="_blank" rel="external">CDN架构以及原理分析</a></p>
<h2 id="Combo服务"><a href="#Combo服务" class="headerlink" title="Combo服务"></a>Combo服务</h2><p>Combo服务，也就是我们在最终拼接生成页面资源引用的时候，并不是生成多个独立的link标签，而是将资源地址拼接成一个url路径，请求一种线上的动态资源合并服务，<strong>从而实现减少HTTP请求的需求</strong>。</p>
<p><code>/??fle1,file2,file3,...</code>的url请求响应就是动态combo服务提供的，它的原理很简单，就是根据url找到对应的多个文件，合并成一个文件来响应请求，并将其缓存，以加快访问速度。</p>
<p>但它也存在一些缺陷：</p>
<ul>
<li>浏览器有<strong>url长度限制</strong>，因此不能无限制的合并资源。</li>
<li>如果用户在网站内有公共资源的两个页面间跳转访问，由于两个页面的combo的url不一样导致用户不能利用浏览器缓存来加快对公共资源的访问速度。<strong>如果combo的url中任何一个文件发生改变，都会导致整个url缓存失效，从而导致浏览器缓存利用率降低</strong>。</li>
</ul>
<h1 id="HTML5缓存思路"><a href="#HTML5缓存思路" class="headerlink" title="HTML5缓存思路"></a>HTML5缓存思路</h1><h2 id="HTML5离线应用缓存manifest"><a href="#HTML5离线应用缓存manifest" class="headerlink" title="HTML5离线应用缓存manifest"></a>HTML5离线应用缓存manifest</h2><ul>
<li>用户可<strong>离线访问你的应用</strong>，这对于无法随时保持联网状态的移动终端用户来说尤其重要</li>
<li>用户访问<strong>本地的缓存文件</strong>，通常意味着更快的访问速度</li>
<li><strong>仅仅加载被修改过的资源</strong>，避免同一资源对服务器多次的请求，大大降低了对服务器的访问压力</li>
</ul>
<p>manifest文件罗列了需要被缓存的文件清单。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">CACHE MANIFEST</div><div class="line"># wanz app v1</div><div class="line"> </div><div class="line"># 指明缓存入口</div><div class="line">CACHE:</div><div class="line">index.html</div><div class="line">style.css</div><div class="line">images/logo.png</div><div class="line">scripts/main.js</div><div class="line"> </div><div class="line"># 以下资源必须在线访问</div><div class="line">NETWORK:</div><div class="line">login.php</div><div class="line"> </div><div class="line"># 如果index.php无法访问则用404.html代替</div><div class="line">FALLBACK:</div><div class="line">/index.php /404.html</div></pre></td></tr></table></figure>
<p>这个过程中有几个问题需要注意：</p>
<ul>
<li>如果服务器对离线的资源进行了更新，那么必须更新manifest文件之后这些资源才能被浏览器重新下载，如果只是更新了资源而没有更新manifest文件的话，浏览器并不会重新下载资源，也就是说还是使用原来离线存储的资源。</li>
<li>对于manifest文件进行缓存的时候需要十分小心，因为可能出现一种情况就是你对manifest文件进行了更新，但是http的缓存规则告诉浏览器本地缓存的manifest文件还没过期，这个情况下浏览器还是使用原来的manifest文件，所以对于manifest文件最好不要设置缓存。</li>
<li>浏览器在下载manifest文件中的资源的时候，它会一次性下载所有资源，如果某个资源由于某种原因下载失败，那么这次的所有更新就算是失败的，浏览器还是会使用原来的资源。</li>
<li>在更新了资源之后，新的资源需要到下次再打开app才会生效，如果需要资源马上就能生效，那么可以使用<code>window.applicationCache.swapCache()</code>方法来使之生效，出现这种现象的原因是浏览器会先使用离线资源加载页面，然后再去检查manifest是否有更新，所以需要到下次打开页面才能生效。</li>
</ul>
<p>manifest的<strong>缓存更新机制</strong>阅读</p>
<p>小卡君：<a href="http://www.cnblogs.com/chyingp/archive/2012/12/01/explore_html5_cache.html" target="_blank" rel="external">HTML5离线存储 初探</a></p>
<h2 id="localStorage"><a href="#localStorage" class="headerlink" title="localStorage"></a>localStorage</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">localStorage.fresh = “vfresh.org”;   <span class="comment">//设置一个键值 </span></div><div class="line"><span class="keyword">var</span> a = localStorage.fresh;   <span class="comment">//获取键值</span></div><div class="line"></div><div class="line"><span class="comment">//API</span></div><div class="line"></div><div class="line"><span class="comment">//清空storage </span></div><div class="line">localStorage.clear();</div><div class="line"></div><div class="line"><span class="comment">//设置一个键值 </span></div><div class="line">localStorage.setItem(“fresh”,“vfresh.org”);</div><div class="line"></div><div class="line"><span class="comment">//获取一个键值 </span></div><div class="line">localStorage.getItem(“fresh”); </div><div class="line"></div><div class="line"><span class="comment">//return “vfresh.org” //获取指定下标的键的名称（如同Array） </span></div><div class="line">localStorage.key(<span class="number">0</span>); </div><div class="line"></div><div class="line"><span class="comment">//return “fresh” //删除一个键值 </span></div><div class="line">localStorage.removeItem(“fresh”);</div></pre></td></tr></table></figure>
<p>与sessionStroage主要的区别是存储时间和作用域。</p>
<p>另外，严格说来localStorage更像是cookie一类的本地数据存储。但在标准缓存之外，开发人员可以用浏览器的一些功能来实现<strong>自定义的客户端“缓存”</strong>。</p>
<p>关于localStorage踩坑指南：</p>
<p>jero <a href="http://imweb.io/topic/5590a443fbb23aae3d5e450a" target="_blank" rel="external">使用localStorage必须了解的点</a></p>
<h2 id="构建可缓存站点的建议"><a href="#构建可缓存站点的建议" class="headerlink" title="构建可缓存站点的建议"></a>构建可缓存站点的建议</h2><p>来自alloyteam：<a href="http://www.alloyteam.com/2012/03/web-cache-3-how-to-build-cacheable-website/" target="_blank" rel="external">如何构建可缓存站点</a></p>
<ul>
<li>同一个资源保证URL的稳定性</li>
<li>给Css、js、图片等资源增加HTTP缓存头，并强制入口Html不被缓存</li>
<li>减少对Cookie的依赖</li>
<li>减少对HTTPS加密协议的使用</li>
<li>多用Get方式请求动态Cgi</li>
<li>动态CGI也是可以被缓存</li>
</ul>
<p>扩展阅读：</p>
<p><a href="http://imweb.io/topic/554c5879718ba1240cc1dd8a" target="_blank" rel="external">HTTP1.1与前端性能</a></p>
<p><a href="https://github.com/fouber/blog/issues/3" target="_blank" rel="external">前端工程与性能优化</a></p>
<p>参考：</p>
<p><a href="http://www.cnblogs.com/zhengyun_ustc/p/rule2.html" target="_blank" rel="external">Web开发基本准则-55实录-缓存策略</a></p>
<p><a href="http://www.alloyteam.com/2012/03/web-cache-2-browser-cache/" target="_blank" rel="external">【Web缓存机制系列】2 – Web浏览器的缓存机制</a></p>
<p><a href="http://www.cnblogs.com/li0803/archive/2008/11/03/1324746.html" target="_blank" rel="external">HTTP协议详解</a></p>
<p><a href="http://bbs.qcloud.com/thread-3775-1-1.html" target="_blank" rel="external">CDN缓存那些事</a></p>
<p><a href="http://www.cnblogs.com/binyue/p/4036802.html" target="_blank" rel="external">浅谈HTTP缓存机制</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;学习整理了web缓存的一些策略，如有不正确的地方，欢迎指正。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://thumbsnap.com/i/bTOegvzm.png?0809&quot; alt=&quot;缓存策略&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>angular与MVVM框架</title>
    <link href="http://sheilacat.github.io/angular-and-mvvm/"/>
    <id>http://sheilacat.github.io/angular-and-mvvm/</id>
    <published>2015-09-16T09:22:23.000Z</published>
    <updated>2016-09-18T07:04:53.469Z</updated>
    
    <content type="html"><![CDATA[<p>本文从新人角度讲一讲对angular中MVVM模式的理解，以及angular特性的源码实现。<br><img src="https://angularjs.org/img/AngularJS-large.png" alt="img"></p>
<a id="more"></a>
<h1 id="MVVM核心原理"><a href="#MVVM核心原理" class="headerlink" title="MVVM核心原理"></a>MVVM核心原理</h1><p>MVVM模式是<code>Model-View-ViewMode</code>（模型-视图-视图模型）模式的简称，其最早出现在微软的WPF和Silverlight框架中。MVVM模式利用框架内置的双向绑定技术对MVP（Model-View-Presenter）模式的变型，引入了专门的ViewModel（视图模型）来实现View和Model的粘合，让View和Model的进一步分离和解耦。</p>
<p>主要思想其实也很简单：在ViewModel中构建一组状态数据（state data），作为View状态的抽象。然后通过双向数据绑定（data binding）使ViewModel中的状态数据（state data）与View中的显示状态（screen state）保持一致。这样，ViewModel中的展示逻辑只需要修改对应的状态数据，就可以控制View的状态，从而避免在View上开发大量的接口。</p>
<p><img src="http://thumbsnap.com/i/aUxBOggL.png?0804" alt="img"></p>
<p>MVVM模式的优势有如下四点：</p>
<ul>
<li>低耦合：View可以独立于Model变化和修改，同一个ViewModel可以被多个View复用；并且可以做到View和Model的变化互不影响；</li>
<li>可重用性：可以把一些视图的逻辑放在ViewModel，让多个View复用；</li>
<li>独立开发：开发人员可以专注与业务逻辑和数据的开发（ViewModel），界面设计人员可以专注于UI(View)的设计；</li>
<li>可测试性：清晰的View分层，使得针对表现层业务逻辑的测试更容易，更简单。</li>
</ul>
<h1 id="angular中的MVVM模式"><a href="#angular中的MVVM模式" class="headerlink" title="angular中的MVVM模式"></a>angular中的MVVM模式</h1><p>Igor Minar<a href="https://plus.google.com/+IgorMinar/posts/DRUAkZmXjNV" target="_blank" rel="external">发布在Google+的文章中</a>提到：</p>
<blockquote>
<p>I’d rather see developers build kick-ass apps that are well-designed and follow separation of concerns, than see them waste time arguing about MV* nonsense. And for this reason, I hereby declare AngularJS to be MVW framework – Model-View-Whatever. Where Whatever stands for “whatever works for you”.</p>
</blockquote>
<p>在文中特别指出angular在多次的API重构和改善，它越来越接近于MVVM模式，$scope可以被认为是ViewModel，而Controller则是装饰、加工处理这个ViewModel的JavaScript函数。作者更希望大家关注于实现一个成功的，具有好的设计以及遵循“分离关注点”原则的应用程序，而不是去争论MV*，所以他将angular称为MVW框架，是什么并不重要，只要适合你的应用就行。</p>
<p>下图是angular中关于MVVM模式的运用：<br><img src="http://thumbsnap.com/i/VeSX9sNM.png?0804" alt="img"></p>
<p>在angular中MVVM模式主要分为四部分：</p>
<ul>
<li>View：它专注于界面的显示和渲染，在angular中则是包含一堆<strong>声明式Directive</strong>的视图模板。</li>
<li>ViewModel：它是View和Model的粘合体，负责View和Model的交互和协作，它负责给View提供显示的数据，以及提供了View中Command事件操作Model的途径；<strong>在angular中$scope对象充当了这个ViewModel的角色</strong>；</li>
<li>Model：它是与应用程序的业务逻辑相关的数据的封装载体，它是业务领域的对象，Model并不关心会被如何显示或操作，所以模型也不会包含任何界面显示相关的逻辑。在web页面中，大部分Model都是来自Ajax的服务端返回数据或者是全局的配置对象；而angular中的service则是封装和处理这些与Model相关的业务逻辑的场所，这类的业务服务是可以被多个Controller或者其他service复用的领域服务。</li>
<li>Controller：这并不是MVVM模式的核心元素，但它负责ViewModel对象的初始化，它将组合一个或者多个service来获取业务领域Model放在ViewModel对象上，使得应用界面在启动加载的时候达到一种可用的状态。</li>
</ul>
<h1 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h1><p>AngularJS通过使用自己的事件处理循环，改变了传统的Javascript工作流。这使得Javascript的执行被分成原始部分和拥有AngularJS执行上下文的部分。只有在AngularJS执行上下文中运行的操作，才能享受到AngularJS提供的数据绑定，异常处理，资源管理等功能和服务。</p>
<p>angular中关于源码的理解可按下图来进行学习，这里只总结几个比较重要的特性实现。</p>
<p><img src="http://thumbsnap.com/i/rfbxp8AT.png?0804" alt="img"></p>
<h2 id="compile"><a href="#compile" class="headerlink" title="$compile"></a>$compile</h2><p>在angular中，指令的<strong>编译链接、双向数据绑定、各种监听</strong>等都是通过<code>$compile</code>来完成的。</p>
<p><code>$compile</code>是通过编译HTML字符串或者DOM到模版里，产生一个<code>template function</code>，之后可以被用于<code>scope</code>和<code>template</code>的链接。</p>
<p>这个方法会遍历DOM并找到匹配的指令。一旦找到一个，它就会被加入一个指令列表中，这个列表是用来记录所有和当前DOM相关的指令的。 一旦所有的指令都被确定了，会按照优先级被排序，并且他们的compile方法会被调用。 指令的$compile()函数能修改DOM结构，并且要负责生成一个link函数。$compile方法最后返回一个合并起来的链接函数，这是链接函数是每一个指令的compile函数返回的链接函数的集合。</p>
<p>通过调用上一步所说的链接函数来将模板与作用域链接起来。这会轮流调用每一个指令的链接函数，让每一个指令都能对DOM注册监听事件，和建立对作用域的的监听。这样最后就形成了作用域的DOM的动态绑定。任何一个作用域的改变都会在DOM上体现出来。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> $compile = ...; <span class="comment">// injected into your code</span></div><div class="line"><span class="keyword">var</span> scope = ...;</div><div class="line"></div><div class="line"><span class="keyword">var</span> html = <span class="string">'&lt;div ng-bind='</span>exp<span class="string">'&gt;&lt;/div&gt;'</span>;</div><div class="line"></div><div class="line"><span class="comment">// Step 1: parse HTML into DOM element</span></div><div class="line"><span class="keyword">var</span> template = angular.element(html);</div><div class="line"></div><div class="line"><span class="comment">// Step 2: compile the template</span></div><div class="line"><span class="keyword">var</span> linkFn = $compile(template);</div><div class="line"></div><div class="line"><span class="comment">// Step 3: link the compiled template with the scope.</span></div><div class="line">linkFn(scope);</div></pre></td></tr></table></figure>
<p>启动的方法在这里,只摘取关键代码.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">injector.invoke([<span class="string">'$rootScope'</span>, <span class="string">'$rootElement'</span>, <span class="string">'$compile'</span>, <span class="string">'$injector'</span>, <span class="string">'$animate'</span>,</div><div class="line">       <span class="function"><span class="keyword">function</span>(<span class="params">scope, element, compile, injector, animate</span>) </span>&#123;</div><div class="line">        scope.$apply(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">          element.data(<span class="string">'$injector'</span>, injector);</div><div class="line">          compile(element)(scope);</div><div class="line">        &#125;);</div><div class="line">      &#125;]</div><div class="line">    );</div></pre></td></tr></table></figure>
<p>上面的代码主要作用就是，初始化相关的依赖,然后执行全局编译,最后更新所有的$watch.</p>
<p>核心的代码就这一句</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">compile(element)(scope);</div></pre></td></tr></table></figure>
<p>其实这里有两步</p>
<ul>
<li><code>compile(element)</code> 收集完整个页面内的指令，然后返回publicLinkFn函数</li>
<li>执行<code>publicLinkFn(scope)</code> 此处的scope即为$rootScope</li>
</ul>
<p><strong>使用<code>compile</code>函数可以改变原始的dom(template element),在ng创建原始dom实例以及创建scope实例之前。</strong><br>可以应用于当需要生成多个element实例,只有一个template element的情况,ng-repeat就是一个最好的例子,它就在是compile函数阶段改变原始的dom生成多个原始dom节点,然后每个又生成element实例.因为compile只会运行一次,所以当你需要生成多个element实例的时候是可以提高性能的.</p>
<p>更多可以参考<a href="http://www.ifeenan.com/angularjs/2014-09-04-[%E8%AF%91]NG%E6%8C%87%E4%BB%A4%E4%B8%AD%E7%9A%84compile%E4%B8%8Elink%E5%87%BD%E6%95%B0%E8%A7%A3%E6%9E%90/" target="_blank" rel="external">[译]ng指令中的compile与link函数解析</a></p>
<h2 id="digest"><a href="#digest" class="headerlink" title="$digest"></a>$digest</h2><p><code>$watch</code>存储了监听函数，当作用域里的变量发生变化时，调用<code>$digest</code>方法便会执行该作用域以及它的所有子作用域上的相关的监听函数，从而做一些操作（如：改变view）。</p>
<p>不过一般情况下，我们不需要手动调用<code>$digest</code>或者<code>$apply</code>（如果一定需要手动调用的话，我们通常使用<code>$apply</code>，因为它里面除了调用<code>$digest</code>还做了异常处理），因为内置的<code>directive</code>和<code>controller</code>内部（即Angular Context之内）都已经做了<code>$apply</code>操作，只有在Angular Context之外的情况需要手动触发<code>$digest</code>，如: 使用setTimout修改scope（这种情况我们除了手动调用<code>$digest</code>，更推荐使用<code>$timeout</code>服务，因为它内部会帮我们调用<code>$apply</code>）。</p>
<p><code>digest</code>方法是<code>dirty check</code>的核心，也是双向绑定的主要实现，主要思路是先执行<code>$$asyncQueue</code>队列中的表达式，然后开启一个<code>loop</code>来的执行所有的<code>watch</code>里的监听函数，前提是前后两次的值是否不相等，假如<code>ttl</code>超过系统默认值，则<code>dirty check</code>结束，最后执行<code>$$postDigestQueue</code>队列里的表达式。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">   $digest: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">     <span class="keyword">var</span> watch, value, last,</div><div class="line">         watchers,</div><div class="line">         length,</div><div class="line">         dirty, ttl = TTL,</div><div class="line">         next, current, target = <span class="keyword">this</span>,</div><div class="line">         watchLog = [],</div><div class="line">         logIdx, logMsg, asyncTask;</div><div class="line"></div><div class="line">     beginPhase(<span class="string">'$digest'</span>);</div><div class="line">     <span class="comment">// Check for changes to browser url that happened in sync before the call to $digest</span></div><div class="line">     $browser.$$checkUrlChange();</div><div class="line"></div><div class="line">     <span class="keyword">if</span> (<span class="keyword">this</span> === $rootScope &amp;&amp; applyAsyncId !== <span class="literal">null</span>) &#123;</div><div class="line">       <span class="comment">// If this is the root scope, and $applyAsync has scheduled a deferred $apply(), then</span></div><div class="line">       <span class="comment">// cancel the scheduled $apply and flush the queue of expressions to be evaluated.</span></div><div class="line">       $browser.defer.cancel(applyAsyncId);</div><div class="line">       flushApplyAsync();</div><div class="line">     &#125;</div><div class="line"></div><div class="line">     lastDirtyWatch = <span class="literal">null</span>;</div><div class="line"></div><div class="line">     <span class="comment">// 外层循环至少执行一次</span></div><div class="line">     <span class="comment">// 如果scope中被监听的变量一直有改变（dirty为true），那么外层循环会一直下去（TTL减1），这是为了防止监听函数有可能改变scope的情况，</span></div><div class="line">     <span class="comment">// 另外考虑到性能问题，如果TTL从默认值10减为0时，则会抛出异常</span></div><div class="line">     <span class="keyword">do</span> &#123; <span class="comment">// "while dirty" loop</span></div><div class="line">       dirty = <span class="literal">false</span>;</div><div class="line">       current = target;</div><div class="line">      </div><div class="line">       <span class="keyword">while</span> (asyncQueue.length) &#123;</div><div class="line">         <span class="keyword">try</span> &#123;</div><div class="line">           asyncTask = asyncQueue.shift();</div><div class="line">           asyncTask.scope.$<span class="built_in">eval</span>(asyncTask.expression, asyncTask.locals);</div><div class="line">         &#125; <span class="keyword">catch</span> (e) &#123;</div><div class="line">           $exceptionHandler(e);</div><div class="line">         &#125;</div><div class="line">         lastDirtyWatch = <span class="literal">null</span>;</div><div class="line">       &#125;</div><div class="line">      </div><div class="line">       traverseScopesLoop:</div><div class="line">       <span class="keyword">do</span> &#123; <span class="comment">// "traverse the scopes" loop</span></div><div class="line">         <span class="keyword">if</span> ((watchers = current.$$watchers)) &#123;</div><div class="line">           <span class="comment">// process our watches</span></div><div class="line">           length = watchers.length;</div><div class="line">           <span class="keyword">while</span> (length--) &#123;</div><div class="line">             <span class="keyword">try</span> &#123;</div><div class="line">               watch = watchers[length];</div><div class="line">               <span class="comment">// Most common watches are on primitives, in which case we can short</span></div><div class="line">               <span class="comment">// circuit it with === operator, only when === fails do we use .equals</span></div><div class="line">               <span class="keyword">if</span> (watch) &#123;</div><div class="line">                 <span class="keyword">if</span> ((value = watch.get(current)) !== (last = watch.last) &amp;&amp;</div><div class="line">                     !(watch.eq</div><div class="line">                         ? equals(value, last)</div><div class="line">                         : (<span class="keyword">typeof</span> value === <span class="string">'number'</span> &amp;&amp; <span class="keyword">typeof</span> last === <span class="string">'number'</span></div><div class="line">                            &amp;&amp; <span class="built_in">isNaN</span>(value) &amp;&amp; <span class="built_in">isNaN</span>(last)))) &#123;</div><div class="line">                   dirty = <span class="literal">true</span>;</div><div class="line">                   lastDirtyWatch = watch;</div><div class="line">                   watch.last = watch.eq ? copy(value, <span class="literal">null</span>) : value;</div><div class="line">                   watch.fn(value, ((last === initWatchVal) ? value : last), current);</div><div class="line">                   <span class="keyword">if</span> (ttl &lt; <span class="number">5</span>) &#123;</div><div class="line">                     logIdx = <span class="number">4</span> - ttl;</div><div class="line">                     <span class="keyword">if</span> (!watchLog[logIdx]) watchLog[logIdx] = [];</div><div class="line">                     watchLog[logIdx].push(&#123;</div><div class="line">                       msg: isFunction(watch.exp) ? <span class="string">'fn: '</span> + (watch.exp.name || watch.exp.toString()) : watch.exp,</div><div class="line">                       newVal: value,</div><div class="line">                       oldVal: last</div><div class="line">                     &#125;);</div><div class="line">                   &#125;</div><div class="line">                 &#125; <span class="keyword">else</span> <span class="keyword">if</span> (watch === lastDirtyWatch) &#123;</div><div class="line">                   <span class="comment">// If the most recently dirty watcher is now clean, short circuit since the remaining watchers</span></div><div class="line">                   <span class="comment">// have already been tested.</span></div><div class="line">                   dirty = <span class="literal">false</span>;</div><div class="line">                   <span class="keyword">break</span> traverseScopesLoop;</div><div class="line">                 &#125;</div><div class="line">               &#125;</div><div class="line">             &#125; <span class="keyword">catch</span> (e) &#123;</div><div class="line">               $exceptionHandler(e);</div><div class="line">             &#125;</div><div class="line">           &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>通过上面的代码，可以看出,核心就是两个loop，外loop保证所有的model都能检测到,内loop则是真实的检测每个watch,watch.get就是计算监控表达式的值,这个用来跟旧值进行对比,假如不相等，则执行监听函数</p>
<p>注意这里的watch.eq这是是否深度检查的标识,equals方法是angular.js里的公共方法，用来深度对比两个对象,这里的不相等有一个例外，那就是NaN ===NaN,因为这个永远都是false,所以这里加了检查。</p>
<p>另外：<code>$RootScopeProvider</code>中提供了<code>digestTtl</code>方法，用于修改TTL的值（默认是10）,可以这样修改：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">angular.module(<span class="string">'ng'</span>).config([<span class="string">'$rootScopeProvider'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">$RootScopeProvider</span>) </span>&#123;</div><div class="line">  $RootScopeProvider.digestTtl(<span class="number">20</span>);</div><div class="line">&#125;]);</div></pre></td></tr></table></figure></p>
<h2 id="isolate-scope"><a href="#isolate-scope" class="headerlink" title="isolate scope"></a>isolate scope</h2><p>Isolate标识来创建独立作用域，这个在创建指令并且scope属性定义的情况下，会触发这种情况，还有几种别的特殊情况，如果是独立作用域的话，会多一个$root属性，这个默认是指向rootscope的</p>
<p>如果不是独立的作用域，则会生成一个内部的构造函数，把此构造函数的prototype指向当前scope实例</p>
<h2 id="injector"><a href="#injector" class="headerlink" title="$injector"></a>$injector</h2><h4 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a>依赖注入</h4><p>每一个AngularJS应用都有一个注入器(injector)用来处理依赖的创建。注入器是一个负责查找和创建依赖的服务定位器。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> FN_ARGS = <span class="regexp">/^function\s*[^\(]*\(\s*([^\)]*)\)/m</span>;</div><div class="line"><span class="keyword">var</span> FN_ARG_SPLIT = <span class="regexp">/,/</span>;</div><div class="line">    <span class="comment">// 获取服务名</span></div><div class="line"><span class="keyword">var</span> FN_ARG = <span class="regexp">/^\s*(_?)(\S+?)\1\s*$/</span>;</div><div class="line"><span class="keyword">var</span> STRIP_COMMENTS = <span class="regexp">/((\/\/.*$)|(\/\*[\s\S]*?\*\/))/mg</span>;</div><div class="line"><span class="keyword">var</span> $injectorMinErr = minErr(<span class="string">'$injector'</span>);</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">anonFn</span>(<span class="params">fn</span>) </span>&#123;</div><div class="line">  <span class="comment">// For anonymous functions, showing at the very least the function signature can help in</span></div><div class="line">  <span class="comment">// debugging.</span></div><div class="line">  <span class="keyword">var</span> fnText = fn.toString().replace(STRIP_COMMENTS, <span class="string">''</span>),</div><div class="line">      args = fnText.match(FN_ARGS);</div><div class="line">  <span class="keyword">if</span> (args) &#123;</div><div class="line">    <span class="keyword">return</span> <span class="string">'function('</span> + (args[<span class="number">1</span>] || <span class="string">''</span>).replace(<span class="regexp">/[\s\r\n]+/</span>, <span class="string">' '</span>) + <span class="string">')'</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> <span class="string">'fn'</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">annotate</span>(<span class="params">fn, strictDi, name</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> $inject,</div><div class="line">      fnText,</div><div class="line">      argDecl,</div><div class="line">      last;</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> fn === <span class="string">'function'</span>) &#123;</div><div class="line">    <span class="keyword">if</span> (!($inject = fn.$inject)) &#123;</div><div class="line">      $inject = [];</div><div class="line">      <span class="keyword">if</span> (fn.length) &#123;</div><div class="line">        <span class="keyword">if</span> (strictDi) &#123;</div><div class="line">          <span class="keyword">if</span> (!isString(name) || !name) &#123;</div><div class="line">            name = fn.name || anonFn(fn);</div><div class="line">          &#125;</div><div class="line">          <span class="keyword">throw</span> $injectorMinErr(<span class="string">'strictdi'</span>,</div><div class="line">            <span class="string">'&#123;0&#125; is not using explicit annotation and cannot be invoked in strict mode'</span>, name);</div><div class="line">        &#125;</div><div class="line">        fnText = fn.toString().replace(STRIP_COMMENTS, <span class="string">''</span>);</div><div class="line">        argDecl = fnText.match(FN_ARGS);</div><div class="line">        forEach(argDecl[<span class="number">1</span>].split(FN_ARG_SPLIT), <span class="function"><span class="keyword">function</span>(<span class="params">arg</span>) </span>&#123;</div><div class="line">          arg.replace(FN_ARG, <span class="function"><span class="keyword">function</span>(<span class="params">all, underscore, name</span>) </span>&#123;</div><div class="line">            $inject.push(name);</div><div class="line">          &#125;);</div><div class="line">        &#125;);</div><div class="line">      &#125;</div><div class="line">      fn.$inject = $inject;</div><div class="line">    &#125;</div><div class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isArray(fn)) &#123;</div><div class="line">    last = fn.length - <span class="number">1</span>;</div><div class="line">    assertArgFn(fn[last], <span class="string">'fn'</span>);</div><div class="line">    $inject = fn.slice(<span class="number">0</span>, last);</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    assertArgFn(fn, <span class="string">'fn'</span>, <span class="literal">true</span>);</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> $inject;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>annotate函数通过对入参进行针对性分析，若传递的是一个函数，则依赖模块作为入参传递，此时可通过序列化函数进行正则匹配，获取依赖模块的名称并存入$inject数组中返回，另外，通过函数入参传递依赖的方式在严格模式下执行会抛出异常；第二种依赖传递则是通过数组的方式，数组的最后一个元素是需要使用依赖的函数。annotate函数最终返回解析的依赖名称。</p>
<h1 id="Angular优缺点及应用场景"><a href="#Angular优缺点及应用场景" class="headerlink" title="Angular优缺点及应用场景"></a>Angular优缺点及应用场景</h1><p>angular功能全，利用它开发效率可以得到提高，有庞大的社区支持，没有内存泄露隐患，但是在性能上<code>dirty check</code>算是拖了后腿。</p>
<p>angular适合构建CRUD应用，因为它具有构建一个CRUD应用时可能用到的所有技术：数据绑定、基本模板指令、表单验证、路由、深度链接、组件重用、依赖注入。对于像游戏和有图形界面的编辑器之类的应用，会进行频繁且复杂的DOM操作，和CRUD应用不同。因此，可能不适合用Angular来构建。在这种场景下，使用更低抽象层次的类库可能会更好。</p>
<p>参考：</p>
<p><a href="http://wzhscript.com/2015/02/03/mvc-mvp-and-mvvm/" target="_blank" rel="external">浅析 MVC, MVP 与 MVVM之间的异同</a></p>
<p><a href="http://www.cnblogs.com/whitewolf/p/4581254.htm" target="_blank" rel="external">angular中的MVVM模式</a></p>
<p><a href="http://hellohtml5.com/2014/10/16/how-angularjs-apply-works/" target="_blank" rel="external">angularjs原理分析，及正确$apply的方法</a></p>
<p><a href="http://www.cnblogs.com/lovesueee/p/4062247.html" target="_blank" rel="external">angularjs1.3.0源码解析之scope</a></p>
<p>中文API：</p>
<p><a href="http://docs.ngnice.com/#!/guide" target="_blank" rel="external">http://docs.ngnice.com/#!/guide</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文从新人角度讲一讲对angular中MVVM模式的理解，以及angular特性的源码实现。&lt;br&gt;&lt;img src=&quot;https://angularjs.org/img/AngularJS-large.png&quot; alt=&quot;img&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>mongodb</title>
    <link href="http://sheilacat.github.io/mongodb-intro/"/>
    <id>http://sheilacat.github.io/mongodb-intro/</id>
    <published>2015-06-03T01:23:33.000Z</published>
    <updated>2016-09-18T07:27:53.811Z</updated>
    
    <content type="html"><![CDATA[<p>#MongoDB</p>
<p>MongoDB是一个基于分布式文件存储的数据库。由C++语言编写。旨在为WEB应用提供可扩展的高性能数据库存储解决方案。</p>
<a id="more"></a>
<p>MongoDB是一个介于关系数据库和非关系数据库之间的产品，是非关系数据库当中功能最丰富，最像关系数据库的。</p>
<p>#NoSQL 简介</p>
<p>NoSQL(NoSQL = Not Only SQL )，意即”不仅仅是SQL”。</p>
<p>NoSQL用于超大规模数据的存储。（例如谷歌或Facebook每天为他们的用户收集万亿比特的数据）。这些类型的数据存储不需要固定的模式，无需多余操作就可以横向扩展。</p>
<p>NoSQL实际上应该说是起源于linux上的dbm，是基于文件的存储操作，很适合对于大数据的操作管理。</p>
<hr>
<p>##关系型数据库遵循ACID规则</p>
<p>事务在英文中是transaction，和现实世界中的交易很类似，它有如下四个特性：</p>
<ul>
<li>1、A (Atomicity) 原子性<br>原子性很容易理解，也就是说事务里的所有操作要么全部做完，要么都不做，事务成功的条件是事务里的所有操作都成功，只要有一个操作失败，整个事务就失败，需要回滚。</li>
</ul>
<p>比如银行转账，从A账户转100元至B账户，分为两个步骤：1）从A账户取100元；2）存入100元至B账户。这两步要么一起完成，要么一起不完成，如果只完成第一步，第二步失败，钱会莫名其妙少了100元。</p>
<ul>
<li>2、C (Consistency) 一致性<br>一致性也比较容易理解，也就是说数据库要一直处于一致的状态，事务的运行不会改变数据库原本的一致性约束。</li>
</ul>
<p>例如现有完整性约束a+b=10，如果一个事务改变了a，那么必须得改变b，使得事务结束后依然满足a+b=10，否则事务失败。</p>
<ul>
<li><p>3、I (Isolation) 独立性<br>所谓的独立性是指并发的事务之间不会互相影响，如果一个事务要访问的数据正在被另外一个事务修改，只要另外一个事务未提交，它所访问的数据就不受未提交事务的影响。<br>比如现有有个交易是从A账户转100元至B账户，在这个交易还未完成的情况下，如果此时B查询自己的账户，是看不到新增加的100元的。</p>
</li>
<li><p>4、D (Durability) 持久性<br>持久性是指一旦事务提交后，它所做的修改将会永久的保存在数据库上，即使出现宕机也不会丢失。</p>
</li>
</ul>
<hr>
<p>#RDBMS vs NoSQL</p>
<p>###RDBMS</p>
<ul>
<li>高度组织化结构化数据</li>
<li>结构化查询语言（SQL） (SQL)</li>
<li>数据和关系都存储在单独的表中。</li>
<li>数据操纵语言，数据定义语言</li>
<li>严格的一致性</li>
<li>基础事务</li>
</ul>
<p>###NoSQL</p>
<ul>
<li>代表着不仅仅是SQL</li>
<li>没有声明性查询语言</li>
<li>没有预定义的模式<br>-键 - 值对存储，列存储，文档存储，图形数据库</li>
<li>最终一致性，而非ACID属性</li>
<li>非结构化和不可预知的数据</li>
<li>CAP定理</li>
<li>高性能，高可用性和可伸缩性</li>
</ul>
<hr>
<p>#NoSQL 简史</p>
<p>NoSQL一词最早出现于1998年，是Carlo Strozzi开发的一个轻量、开源、不提供SQL功能的关系数据库。</p>
<p>2009年，Last.fm的Johan Oskarsson发起了一次关于分布式开源数据库的讨论[2]，来自Rackspace的Eric Evans再次提出了NoSQL的概念，这时的NoSQL主要指非关系型、分布式、不提供ACID的数据库设计模式。</p>
<p>2009年在亚特兰大举行的”no:sql(east)”讨论会是一个里程碑，其口号是”select fun, profit from real_world where relational=false;”。因此，对NoSQL最普遍的解释是”非关联型的”，强调Key-Value Stores和文档数据库的优点，而不是单纯的反对RDBMS。</p>
<hr>
<p>#NoSQL的优点/缺点</p>
<p>优点:</p>
<pre><code>- 高可扩展性
- 分布式计算
- 低成本
- 架构的灵活性，半结构化数据
- 没有复杂的关系 
</code></pre><p>缺点:</p>
<pre><code>- 没有标准化
- 有限的查询功能（到目前为止）
- 最终一致是不直观的程序
</code></pre><hr>
<p>#BASE</p>
<p>BASE：Basically Available, Soft-state, Eventually Consistent。 由 Eric Brewer 定义。</p>
<p>CAP理论的核心是：一个分布式系统不可能同时很好的满足一致性，可用性和分区容错性这三个需求，最多只能同时较好的满足两个。</p>
<p>BASE是NoSQL数据库通常对可用性及一致性的弱要求原则:</p>
<ul>
<li>Basically Availble –基本可用</li>
<li>Soft-state –软状态/柔性事务。 “Soft state” 可以理解为”无连接”的, 而 “Hard state” 是”面向连接”的</li>
<li>Eventual Consistency –最终一致性 最终一致性， 也是是 ACID 的最终目的。</li>
</ul>
<hr>
<p>参考文章：</p>
<p>[mongodb教程][<a href="http://www.w3cschool.cc/mongodb/mongodb-tutorial.html" target="_blank" rel="external">http://www.w3cschool.cc/mongodb/mongodb-tutorial.html</a>]<br>[mongodb基本使用][<a href="http://www.cnblogs.com/TankMa/archive/2011/06/08/2074947.html" target="_blank" rel="external">http://www.cnblogs.com/TankMa/archive/2011/06/08/2074947.html</a>]</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;#MongoDB&lt;/p&gt;
&lt;p&gt;MongoDB是一个基于分布式文件存储的数据库。由C++语言编写。旨在为WEB应用提供可扩展的高性能数据库存储解决方案。&lt;/p&gt;
    
    </summary>
    
      <category term="mongodb" scheme="http://sheilacat.github.io/categories/mongodb/"/>
    
    
  </entry>
  
  <entry>
    <title>Linux入门</title>
    <link href="http://sheilacat.github.io/learn-linux/"/>
    <id>http://sheilacat.github.io/learn-linux/</id>
    <published>2015-05-15T12:30:22.000Z</published>
    <updated>2016-09-18T07:05:04.857Z</updated>
    
    <content type="html"><![CDATA[<h2 id="UNIX哲学"><a href="#UNIX哲学" class="headerlink" title="UNIX哲学"></a>UNIX哲学</h2><p>UNIX操作系统（包括Linux）鼓励一种特定的编程风格。下面列出了一些典型的UNIX程序和系统所具有的特点。</p>
<ul>
<li>简单性 KISS keep it small and simple</li>
<li>集中性</li>
<li>可重用组件</li>
<li>过滤器</li>
<li>开放的文件格式</li>
<li>灵活性</li>
</ul>
<a id="more"></a>
<h2 id="为什么使用shell编程"><a href="#为什么使用shell编程" class="headerlink" title="为什么使用shell编程"></a>为什么使用shell编程</h2><ul>
<li>使用shell进行程序设计的原因之一是，你可以快速、简单地完成编程。</li>
<li>shell非常适合于编写一些执行相对简单的任务的小工具，因为它们更强调的是易于配置、易于维护和可移植性，而不是很看重执行的效率。</li>
<li>可以使用shell对进程控制进行组织，使命令按照预定顺序在前一阶段命令成功完成的前提下顺序执行。</li>
<li>shell执行shell程序，这些程序通常被称为脚本，它们是在运行时解释执行的。这使得调试工作比较容易进行，因为你可以逐行地执行指令，而且节省了重新编译的时间。然而，这也使得shell不适合用来完成时间紧迫型和处理器忙碌型的任务。</li>
</ul>
<h2 id="什么是shell"><a href="#什么是shell" class="headerlink" title="什么是shell"></a>什么是shell</h2><p>shell是一个作为用户与Linux系统间接口的程序，它允许用户向操作系统输入需要执行的命令。</p>
<p>shell（实际上是两种shell:bash和csh）和其他程序环绕在Linux内核的四周。</p>
<h2 id="常用的shell"><a href="#常用的shell" class="headerlink" title="常用的shell"></a>常用的shell</h2><ul>
<li>sh(Bourne)        源于UNIX早期版本的最初的shell</li>
<li>csh、tcsh、zsh     C shell及其变体，最初是由Bill Joy在Berkeley UNIX上创建的。它可能是继bash和Korn shell之后第三个最流行的shell</li>
<li>ksh、pdksh        korn shell和它的公共域pdksh(public domain korn shell)由David Korn编写，它是许多商业版本UNIX的默认shell</li>
<li>bash            来自GNU项目的bash或Bourne Again Shell是Linux的主要shell。它的优点是可以免费获取其源代码，即使你的UNIX系统目前没有运行它，它也可能已经被移植到该系统中。bash与Korn shell有许多相似之处</li>
</ul>
<p>除了C shell和少数变体以外，所有这些shell都很相似，并且都与X/Open 4.2和POSIX 1003.2规范中对于shell的规定非常一致。X/Open通常是一个提出更多要求的规范，但遵循它的系统也更加友好。</p>
<p>//顺手记录出现的一些命令</p>
<h2 id="重定向输出"><a href="#重定向输出" class="headerlink" title="重定向输出"></a>重定向输出</h2><pre><code>$ ls -l &gt; lsoutput.txt
</code></pre><p>这条命令把ls命令的输出保存到文件中</p>
<p>重定向：</p>
<ul>
<li>文件描述符0代表一个程序的标准输入</li>
<li>文件描述符1代表标准输出</li>
<li><p>文件描述符2代表标准错误输出</p>
<p>  set -o noclobber</p>
</li>
</ul>
<p>(或set -C)命令设置noclobber选项，阻止重定向操作对一个已有文件的覆盖。</p>
<pre><code>set +o noclobber
</code></pre><p>取消该选项</p>
<pre><code>$ ps &gt;&gt; lsoutput.txt
</code></pre><p>这条命令会将ps命令的输出附加到指定文件的尾部。</p>
<p>如果你想把两组输出都重定向到一个文件中，你可以用&gt;&amp;操作符来结合两个输出。</p>
<pre><code>$ kill -1 1234 &gt;killouterr.txt 2&gt;&amp;1
</code></pre><h2 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h2><p>在Linux下通过管道连接的进程可以同时运行，并且随着数据流在它们之间的传递可以自动地进行协调。</p>
<p><strong><em>注意</em></strong></p>
<p>如果你有一系列的命令需要执行，相应的输出文件是在这一组命令被创建的同时立刻被创建或写入的，所以决不要在命令流中重复使用相同的文件名。如果你尝试执行如下命令：</p>
<pre><code>cat mydata.txt | sort | uniq &gt; mydata.txt
</code></pre><p>你最终将得到一个空文件，因为你在读取文件mydata.txt之前就已经覆盖了这个文件的内容。</p>
<h2 id="shell脚本"><a href="#shell脚本" class="headerlink" title="shell脚本"></a>shell脚本</h2><h3 id="exit命令"><a href="#exit命令" class="headerlink" title="exit命令"></a>exit命令</h3><p>exit命令的作用是确保脚本程序能够返回一个有意义的退出码。当程序以交互方式运行时，我们很少需要检查它的退出码，但如果你打算从另一个脚本程序里调用这个脚本程序并查看它是否执行成功，那么返回一个适当的退出码就很重要了。请相信自己的脚本程序是有用的，它总有一天会作为其他脚本程序的一部分而被重用。</p>
<h3 id="shell的语法"><a href="#shell的语法" class="headerlink" title="shell的语法"></a>shell的语法</h3><ul>
<li><p>变量：字符串、数字、环境和参数</p>
<ul>
<li>Linux是一个区分大小写的系统。</li>
<li>在shell中，你可以通过在变量名前加一个$符号来访问他的内容。无论何时你想要获取变量内容，你都必须在它前面加一个$符号。当你为变量赋值时，你只需要使用变量名，该变量会根据需要被自动创建。</li>
<li>如果字符串里包含空格，就必须用引号把它们括起来。此外，等号两边不不能有空格。e.g. salutation=7+5</li>
<li>可以使用<code>read</code>命令将用户的输入赋值给一个变量。</li>
<li>使用引号：双引号会把变量替换为它的值，单引号不会。</li>
<li>test或[命令 <strong><em>注意，你必须在[符号和被检查的条件之间留出空格。</em></strong></li>
</ul>
</li>
</ul>
<h4 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h4><ul>
<li>$HOME    当前用户的家目录</li>
<li>$PATH    以冒号分隔的用来搜索命令的目录列表</li>
<li>$PS1    一级命令提示符，通常是$字符</li>
<li>$PS2    二级命令提示符，用来提示后续的输入，通常是&gt;字符</li>
<li>$IFS    输入域分隔符</li>
<li>$0    shell脚本的名字</li>
<li>$#    传递给脚本的参数个数</li>
<li>$$    shell脚本的进程号，脚本通常会用它来生成一个唯一的临时文件</li>
</ul>
<ul>
<li><p>条件：shell中的布尔值</p>
</li>
<li><p>程序控制：if、elif、for、while、until、case</p>
<ul>
<li><p>一般来说，如果需要循环至少执行一次，那么就使用while循环；如果可能根本都不需要执行循环，就使用until循环。</p>
</li>
<li><p>case结构</p>
<p>case “$timeofday” in<br>  yes)    echo “Good Morning”;;<br>  no )    echo “Good Afternoon”;;<br>  y  )    echo “Good Morning”;;<br>  n  )    echo “Good Afternoon”;;</p>
<ul>
<li>)    echo “Sorry,answer not recognized”;;<br>esac</li>
</ul>
</li>
<li><p>and列表和or列表<br>AND列表：只有在前面所有命令都执行成功的情况下才执行后一条命令。<br>OR列表：允许我们持续执行一系列命令直到有一条命令成功为止，其后的命令将不再被执行。</p>
</li>
</ul>
</li>
<li><p>命令列表</p>
</li>
</ul>
<p><strong>命令</strong>  你可以在shell脚本程序内部执行两类命令。一类是可以在命令提示符中执行的“普通”命令，也称为外部命令（external command），一类是我们前面提到的“内置”命令，也称为内部命令(internal command)。内置命令是在shell内部实现的，它们不能作为外部程序被调用。然而，大多数的内部命令也提供了独立运行的程序版本——这一需求是POSIX规范的一部分。通常情况下，命令是内部的还是外部的并不重要，只是内部命令的执行效率更高。</p>
<ul>
<li>:命令<br>冒号(:)命令是一个空命令。它偶尔会被用于简化条件逻辑，相对于true的一个别名。由于它是内置命令，所以它运行得比true快，但它的输出可读性较差。<br>:结构也会被用在变量的条件设置中</li>
<li>exit n（退出码）<pre><code>* 126        文件不可执行
* 127        命令未找到
* 128 及以上    出现一个信号
</code></pre></li>
<li>export命令</li>
</ul>
<p>export没命令将作为它参数的变量导出到子shell中，并使之在子shell中有效。在默认情况下，在一个shell中被创建的变量在这个shell调用的下级（子）shell中是不可用的。export命令把自己的参数创建为一个环境变量，而这个环境变量可以被当前程序调用的其他脚本和程序看见。从更技术的角度来说，被导出的变量构成从该shell衍生的任何子进程的环境变量。</p>
<ul>
<li><p>expr命令</p>
<p>  expr命令将它的参数当作一个表达式来求值。在较新的脚本程序中，expr命令通常被替换为更有效的$((…))语法。</p>
</li>
<li><p>printf命令</p>
<p>  printf “format string” parameter1 parameter2 …</p>
</li>
</ul>
<p>格式字符串与C/C++中使用的非常相似，但有一些自己的限制。主要是不支持浮点数，因为shell中的有的算术运算都是按照整数来进行计算的。格式字符串由各种可打印字符、转义序列和字符转换限定符组成。格式字符串中除了%和\之外的所有字符都将按原样输出。</p>
<ul>
<li>set命令</li>
</ul>
<p>set命令的作用是为shell甚至参数变量。许多命令的输出结果是以空格分隔的值，如果需要使用输出结果中的某个域，这个命令就非常有用。</p>
<ul>
<li>shift命令</li>
</ul>
<p>shift命令把所有参数变量左移一个位置，使$2变成$1，$2变成$2，以此类推。原来$1的值将被丢弃，而$0仍将保持不变。$*、$@和$#等其他变量也将根据参数变量的新安排做相应的变动。</p>
<ul>
<li>trap命令</li>
</ul>
<p>trap命令有两个参数，第一个参数是接收到指定信号时将要采取的行动，第二个参数是要处理的信号名。</p>
<pre><code>trap command signal
</code></pre><p>如果要重置某个信号的处理方式到其默认值，只需将<code>command</code>设置为<code>-</code>。如果要忽略某个信号，就要把<code>command</code>设置为空字符串<code>`。一个不带参数的</code>trap`命令将列出当前设置的信号及其行动的清单。</p>
<p>下面列出一些X/Open规范里面规定的能够被捕获的比较重要的一些信号（括号里面的数字是对应的信号编号）。更多参考man 7 signal</p>
<pre><code>* HUP(1)    挂起，通常因终端掉线或用户退出而引发
* INT(2)    中断，通常因按下Ctrl+C组合键而引发
* QUIT(3)    退出，通常因按下Ctrl+\组合键而引发
* ABRT(6)    中止，通常因某些严重的执行错误而引发
* ALRM(14)    报警，通常用来处理超时
* TERM(15)    终止，通常在系统关机时发送
</code></pre><ul>
<li>unset命令 unset命令的作用是从环境中删除变量或函数。这个命令不能删除shell本身定义的只读变量（如IFS）。这个命令并不常用。</li>
</ul>
<p>这里列举一些命令</p>
<ul>
<li>break命令</li>
<li>:命令</li>
<li>continue命令</li>
<li>.命令</li>
</ul>
<p>#</p>
<ul>
<li>echo命令</li>
<li>eval命令</li>
<li>exec命令</li>
<li>exit n命令</li>
<li>export命令</li>
<li>expr命令</li>
<li>printf命令</li>
<li>return命令</li>
<li>set命令</li>
<li>shift命令</li>
<li>trap命令</li>
<li>unset命令</li>
<li><p>另外两个有用的命令和正则表达式</p>
<ul>
<li><p>find</p>
<p>find <code>[path]</code> <code>[options]</code> <code>[tests]</code> <code>[actions]</code></p>
</li>
</ul>
</li>
</ul>
<ul>
<li>grep命令</li>
</ul>
<p>通用正则表达式解析器（General Regular Expression Parser，简写为grep）</p>
<ul>
<li><p>函数</p>
<ul>
<li><p>if elif的另一种写法：用命令列表OR或AND来实现</p>
<p>[ -f file_one ] &amp;&amp; command for true || command for false</p>
</li>
</ul>
</li>
<li><p>shell内置命令</p>
</li>
<li><p>获取命令的执行结果</p>
</li>
<li><p>here文档</p>
</li>
</ul>
<p>在shell脚本程序中向一条命令传递输入的一种特殊方法是使用here文档。它允许一条命令在获得输入数据时就好像在读取一个文件或键盘一样，而实际上是从脚本程序中得到输入数据。</p>
<ul>
<li>调试脚本程序</li>
</ul>
<p>因为脚本程序是解释执行的，所以在脚本程序的修改和重试过程中没有编译方面的额外开支。跟踪脚本程序中复杂错误的主要方法是设置各种shell选项。</p>
<ul>
<li>dialog和gdialog命令</li>
</ul>
<h1 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h1><ul>
<li>文件和设备</li>
<li>系统调用</li>
<li>库函数</li>
<li>底层文件访问</li>
<li>管理文件</li>
<li>标准I/O库</li>
<li>格式化输入和输出</li>
<li>文件和目录的维护</li>
<li>扫描目录</li>
<li>错误及其处理</li>
<li>/proc文件系统</li>
<li>高级主题：fcntl和mmap</li>
</ul>
<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><p>系统使用的是文件的inode编号，目录结构为文件命名仅仅是为了便于人们使用。</p>
<p>UNIX和Linux中比较重要的设备文件有3个：<code>/dev/console</code>、<code>/dev/tty</code>和<code>/dev/null</code>。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;UNIX哲学&quot;&gt;&lt;a href=&quot;#UNIX哲学&quot; class=&quot;headerlink&quot; title=&quot;UNIX哲学&quot;&gt;&lt;/a&gt;UNIX哲学&lt;/h2&gt;&lt;p&gt;UNIX操作系统（包括Linux）鼓励一种特定的编程风格。下面列出了一些典型的UNIX程序和系统所具有的特点。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;简单性 KISS keep it small and simple&lt;/li&gt;
&lt;li&gt;集中性&lt;/li&gt;
&lt;li&gt;可重用组件&lt;/li&gt;
&lt;li&gt;过滤器&lt;/li&gt;
&lt;li&gt;开放的文件格式&lt;/li&gt;
&lt;li&gt;灵活性&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="linux" scheme="http://sheilacat.github.io/categories/linux/"/>
    
    
  </entry>
  
</feed>
