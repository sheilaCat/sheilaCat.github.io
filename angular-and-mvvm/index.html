<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>angular与MVVM框架 | Something here</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="本文从新人角度讲一讲对angular中MVVM模式的理解，以及angular特性的源码实现。">
<meta property="og:type" content="article">
<meta property="og:title" content="angular与MVVM框架">
<meta property="og:url" content="http://sheilacat.github.io/angular-and-mvvm/index.html">
<meta property="og:site_name" content="Something here">
<meta property="og:description" content="本文从新人角度讲一讲对angular中MVVM模式的理解，以及angular特性的源码实现。">
<meta property="og:image" content="https://angularjs.org/img/AngularJS-large.png">
<meta property="og:image" content="http://thumbsnap.com/i/aUxBOggL.png?0804">
<meta property="og:image" content="http://thumbsnap.com/i/VeSX9sNM.png?0804">
<meta property="og:image" content="http://thumbsnap.com/i/rfbxp8AT.png?0804">
<meta property="og:updated_time" content="2016-09-18T07:04:53.469Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="angular与MVVM框架">
<meta name="twitter:description" content="本文从新人角度讲一讲对angular中MVVM模式的理解，以及angular特性的源码实现。">
<meta name="twitter:image" content="https://angularjs.org/img/AngularJS-large.png">
  
    <link rel="alternate" href="/atom.xml" title="Something here" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">

  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Something here</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">This world was never meant for one as beautiful as you.</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://sheilacat.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-angular-and-mvvm" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/angular-and-mvvm/" class="article-date">
  <time datetime="2015-09-16T09:22:23.000Z" itemprop="datePublished">2015-09-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      angular与MVVM框架
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>本文从新人角度讲一讲对angular中MVVM模式的理解，以及angular特性的源码实现。<br><img src="https://angularjs.org/img/AngularJS-large.png" alt="img"></p>
<a id="more"></a>
<h1 id="MVVM核心原理"><a href="#MVVM核心原理" class="headerlink" title="MVVM核心原理"></a>MVVM核心原理</h1><p>MVVM模式是<code>Model-View-ViewMode</code>（模型-视图-视图模型）模式的简称，其最早出现在微软的WPF和Silverlight框架中。MVVM模式利用框架内置的双向绑定技术对MVP（Model-View-Presenter）模式的变型，引入了专门的ViewModel（视图模型）来实现View和Model的粘合，让View和Model的进一步分离和解耦。</p>
<p>主要思想其实也很简单：在ViewModel中构建一组状态数据（state data），作为View状态的抽象。然后通过双向数据绑定（data binding）使ViewModel中的状态数据（state data）与View中的显示状态（screen state）保持一致。这样，ViewModel中的展示逻辑只需要修改对应的状态数据，就可以控制View的状态，从而避免在View上开发大量的接口。</p>
<p><img src="http://thumbsnap.com/i/aUxBOggL.png?0804" alt="img"></p>
<p>MVVM模式的优势有如下四点：</p>
<ul>
<li>低耦合：View可以独立于Model变化和修改，同一个ViewModel可以被多个View复用；并且可以做到View和Model的变化互不影响；</li>
<li>可重用性：可以把一些视图的逻辑放在ViewModel，让多个View复用；</li>
<li>独立开发：开发人员可以专注与业务逻辑和数据的开发（ViewModel），界面设计人员可以专注于UI(View)的设计；</li>
<li>可测试性：清晰的View分层，使得针对表现层业务逻辑的测试更容易，更简单。</li>
</ul>
<h1 id="angular中的MVVM模式"><a href="#angular中的MVVM模式" class="headerlink" title="angular中的MVVM模式"></a>angular中的MVVM模式</h1><p>Igor Minar<a href="https://plus.google.com/+IgorMinar/posts/DRUAkZmXjNV" target="_blank" rel="external">发布在Google+的文章中</a>提到：</p>
<blockquote>
<p>I’d rather see developers build kick-ass apps that are well-designed and follow separation of concerns, than see them waste time arguing about MV* nonsense. And for this reason, I hereby declare AngularJS to be MVW framework – Model-View-Whatever. Where Whatever stands for “whatever works for you”.</p>
</blockquote>
<p>在文中特别指出angular在多次的API重构和改善，它越来越接近于MVVM模式，$scope可以被认为是ViewModel，而Controller则是装饰、加工处理这个ViewModel的JavaScript函数。作者更希望大家关注于实现一个成功的，具有好的设计以及遵循“分离关注点”原则的应用程序，而不是去争论MV*，所以他将angular称为MVW框架，是什么并不重要，只要适合你的应用就行。</p>
<p>下图是angular中关于MVVM模式的运用：<br><img src="http://thumbsnap.com/i/VeSX9sNM.png?0804" alt="img"></p>
<p>在angular中MVVM模式主要分为四部分：</p>
<ul>
<li>View：它专注于界面的显示和渲染，在angular中则是包含一堆<strong>声明式Directive</strong>的视图模板。</li>
<li>ViewModel：它是View和Model的粘合体，负责View和Model的交互和协作，它负责给View提供显示的数据，以及提供了View中Command事件操作Model的途径；<strong>在angular中$scope对象充当了这个ViewModel的角色</strong>；</li>
<li>Model：它是与应用程序的业务逻辑相关的数据的封装载体，它是业务领域的对象，Model并不关心会被如何显示或操作，所以模型也不会包含任何界面显示相关的逻辑。在web页面中，大部分Model都是来自Ajax的服务端返回数据或者是全局的配置对象；而angular中的service则是封装和处理这些与Model相关的业务逻辑的场所，这类的业务服务是可以被多个Controller或者其他service复用的领域服务。</li>
<li>Controller：这并不是MVVM模式的核心元素，但它负责ViewModel对象的初始化，它将组合一个或者多个service来获取业务领域Model放在ViewModel对象上，使得应用界面在启动加载的时候达到一种可用的状态。</li>
</ul>
<h1 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h1><p>AngularJS通过使用自己的事件处理循环，改变了传统的Javascript工作流。这使得Javascript的执行被分成原始部分和拥有AngularJS执行上下文的部分。只有在AngularJS执行上下文中运行的操作，才能享受到AngularJS提供的数据绑定，异常处理，资源管理等功能和服务。</p>
<p>angular中关于源码的理解可按下图来进行学习，这里只总结几个比较重要的特性实现。</p>
<p><img src="http://thumbsnap.com/i/rfbxp8AT.png?0804" alt="img"></p>
<h2 id="compile"><a href="#compile" class="headerlink" title="$compile"></a>$compile</h2><p>在angular中，指令的<strong>编译链接、双向数据绑定、各种监听</strong>等都是通过<code>$compile</code>来完成的。</p>
<p><code>$compile</code>是通过编译HTML字符串或者DOM到模版里，产生一个<code>template function</code>，之后可以被用于<code>scope</code>和<code>template</code>的链接。</p>
<p>这个方法会遍历DOM并找到匹配的指令。一旦找到一个，它就会被加入一个指令列表中，这个列表是用来记录所有和当前DOM相关的指令的。 一旦所有的指令都被确定了，会按照优先级被排序，并且他们的compile方法会被调用。 指令的$compile()函数能修改DOM结构，并且要负责生成一个link函数。$compile方法最后返回一个合并起来的链接函数，这是链接函数是每一个指令的compile函数返回的链接函数的集合。</p>
<p>通过调用上一步所说的链接函数来将模板与作用域链接起来。这会轮流调用每一个指令的链接函数，让每一个指令都能对DOM注册监听事件，和建立对作用域的的监听。这样最后就形成了作用域的DOM的动态绑定。任何一个作用域的改变都会在DOM上体现出来。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> $compile = ...; <span class="comment">// injected into your code</span></div><div class="line"><span class="keyword">var</span> scope = ...;</div><div class="line"></div><div class="line"><span class="keyword">var</span> html = <span class="string">'&lt;div ng-bind='</span>exp<span class="string">'&gt;&lt;/div&gt;'</span>;</div><div class="line"></div><div class="line"><span class="comment">// Step 1: parse HTML into DOM element</span></div><div class="line"><span class="keyword">var</span> template = angular.element(html);</div><div class="line"></div><div class="line"><span class="comment">// Step 2: compile the template</span></div><div class="line"><span class="keyword">var</span> linkFn = $compile(template);</div><div class="line"></div><div class="line"><span class="comment">// Step 3: link the compiled template with the scope.</span></div><div class="line">linkFn(scope);</div></pre></td></tr></table></figure>
<p>启动的方法在这里,只摘取关键代码.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">injector.invoke([<span class="string">'$rootScope'</span>, <span class="string">'$rootElement'</span>, <span class="string">'$compile'</span>, <span class="string">'$injector'</span>, <span class="string">'$animate'</span>,</div><div class="line">       <span class="function"><span class="keyword">function</span>(<span class="params">scope, element, compile, injector, animate</span>) </span>&#123;</div><div class="line">        scope.$apply(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">          element.data(<span class="string">'$injector'</span>, injector);</div><div class="line">          compile(element)(scope);</div><div class="line">        &#125;);</div><div class="line">      &#125;]</div><div class="line">    );</div></pre></td></tr></table></figure>
<p>上面的代码主要作用就是，初始化相关的依赖,然后执行全局编译,最后更新所有的$watch.</p>
<p>核心的代码就这一句</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">compile(element)(scope);</div></pre></td></tr></table></figure>
<p>其实这里有两步</p>
<ul>
<li><code>compile(element)</code> 收集完整个页面内的指令，然后返回publicLinkFn函数</li>
<li>执行<code>publicLinkFn(scope)</code> 此处的scope即为$rootScope</li>
</ul>
<p><strong>使用<code>compile</code>函数可以改变原始的dom(template element),在ng创建原始dom实例以及创建scope实例之前。</strong><br>可以应用于当需要生成多个element实例,只有一个template element的情况,ng-repeat就是一个最好的例子,它就在是compile函数阶段改变原始的dom生成多个原始dom节点,然后每个又生成element实例.因为compile只会运行一次,所以当你需要生成多个element实例的时候是可以提高性能的.</p>
<p>更多可以参考<a href="http://www.ifeenan.com/angularjs/2014-09-04-[%E8%AF%91]NG%E6%8C%87%E4%BB%A4%E4%B8%AD%E7%9A%84compile%E4%B8%8Elink%E5%87%BD%E6%95%B0%E8%A7%A3%E6%9E%90/" target="_blank" rel="external">[译]ng指令中的compile与link函数解析</a></p>
<h2 id="digest"><a href="#digest" class="headerlink" title="$digest"></a>$digest</h2><p><code>$watch</code>存储了监听函数，当作用域里的变量发生变化时，调用<code>$digest</code>方法便会执行该作用域以及它的所有子作用域上的相关的监听函数，从而做一些操作（如：改变view）。</p>
<p>不过一般情况下，我们不需要手动调用<code>$digest</code>或者<code>$apply</code>（如果一定需要手动调用的话，我们通常使用<code>$apply</code>，因为它里面除了调用<code>$digest</code>还做了异常处理），因为内置的<code>directive</code>和<code>controller</code>内部（即Angular Context之内）都已经做了<code>$apply</code>操作，只有在Angular Context之外的情况需要手动触发<code>$digest</code>，如: 使用setTimout修改scope（这种情况我们除了手动调用<code>$digest</code>，更推荐使用<code>$timeout</code>服务，因为它内部会帮我们调用<code>$apply</code>）。</p>
<p><code>digest</code>方法是<code>dirty check</code>的核心，也是双向绑定的主要实现，主要思路是先执行<code>$$asyncQueue</code>队列中的表达式，然后开启一个<code>loop</code>来的执行所有的<code>watch</code>里的监听函数，前提是前后两次的值是否不相等，假如<code>ttl</code>超过系统默认值，则<code>dirty check</code>结束，最后执行<code>$$postDigestQueue</code>队列里的表达式。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">   $digest: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">     <span class="keyword">var</span> watch, value, last,</div><div class="line">         watchers,</div><div class="line">         length,</div><div class="line">         dirty, ttl = TTL,</div><div class="line">         next, current, target = <span class="keyword">this</span>,</div><div class="line">         watchLog = [],</div><div class="line">         logIdx, logMsg, asyncTask;</div><div class="line"></div><div class="line">     beginPhase(<span class="string">'$digest'</span>);</div><div class="line">     <span class="comment">// Check for changes to browser url that happened in sync before the call to $digest</span></div><div class="line">     $browser.$$checkUrlChange();</div><div class="line"></div><div class="line">     <span class="keyword">if</span> (<span class="keyword">this</span> === $rootScope &amp;&amp; applyAsyncId !== <span class="literal">null</span>) &#123;</div><div class="line">       <span class="comment">// If this is the root scope, and $applyAsync has scheduled a deferred $apply(), then</span></div><div class="line">       <span class="comment">// cancel the scheduled $apply and flush the queue of expressions to be evaluated.</span></div><div class="line">       $browser.defer.cancel(applyAsyncId);</div><div class="line">       flushApplyAsync();</div><div class="line">     &#125;</div><div class="line"></div><div class="line">     lastDirtyWatch = <span class="literal">null</span>;</div><div class="line"></div><div class="line">     <span class="comment">// 外层循环至少执行一次</span></div><div class="line">     <span class="comment">// 如果scope中被监听的变量一直有改变（dirty为true），那么外层循环会一直下去（TTL减1），这是为了防止监听函数有可能改变scope的情况，</span></div><div class="line">     <span class="comment">// 另外考虑到性能问题，如果TTL从默认值10减为0时，则会抛出异常</span></div><div class="line">     <span class="keyword">do</span> &#123; <span class="comment">// "while dirty" loop</span></div><div class="line">       dirty = <span class="literal">false</span>;</div><div class="line">       current = target;</div><div class="line">      </div><div class="line">       <span class="keyword">while</span> (asyncQueue.length) &#123;</div><div class="line">         <span class="keyword">try</span> &#123;</div><div class="line">           asyncTask = asyncQueue.shift();</div><div class="line">           asyncTask.scope.$<span class="built_in">eval</span>(asyncTask.expression, asyncTask.locals);</div><div class="line">         &#125; <span class="keyword">catch</span> (e) &#123;</div><div class="line">           $exceptionHandler(e);</div><div class="line">         &#125;</div><div class="line">         lastDirtyWatch = <span class="literal">null</span>;</div><div class="line">       &#125;</div><div class="line">      </div><div class="line">       traverseScopesLoop:</div><div class="line">       <span class="keyword">do</span> &#123; <span class="comment">// "traverse the scopes" loop</span></div><div class="line">         <span class="keyword">if</span> ((watchers = current.$$watchers)) &#123;</div><div class="line">           <span class="comment">// process our watches</span></div><div class="line">           length = watchers.length;</div><div class="line">           <span class="keyword">while</span> (length--) &#123;</div><div class="line">             <span class="keyword">try</span> &#123;</div><div class="line">               watch = watchers[length];</div><div class="line">               <span class="comment">// Most common watches are on primitives, in which case we can short</span></div><div class="line">               <span class="comment">// circuit it with === operator, only when === fails do we use .equals</span></div><div class="line">               <span class="keyword">if</span> (watch) &#123;</div><div class="line">                 <span class="keyword">if</span> ((value = watch.get(current)) !== (last = watch.last) &amp;&amp;</div><div class="line">                     !(watch.eq</div><div class="line">                         ? equals(value, last)</div><div class="line">                         : (<span class="keyword">typeof</span> value === <span class="string">'number'</span> &amp;&amp; <span class="keyword">typeof</span> last === <span class="string">'number'</span></div><div class="line">                            &amp;&amp; <span class="built_in">isNaN</span>(value) &amp;&amp; <span class="built_in">isNaN</span>(last)))) &#123;</div><div class="line">                   dirty = <span class="literal">true</span>;</div><div class="line">                   lastDirtyWatch = watch;</div><div class="line">                   watch.last = watch.eq ? copy(value, <span class="literal">null</span>) : value;</div><div class="line">                   watch.fn(value, ((last === initWatchVal) ? value : last), current);</div><div class="line">                   <span class="keyword">if</span> (ttl &lt; <span class="number">5</span>) &#123;</div><div class="line">                     logIdx = <span class="number">4</span> - ttl;</div><div class="line">                     <span class="keyword">if</span> (!watchLog[logIdx]) watchLog[logIdx] = [];</div><div class="line">                     watchLog[logIdx].push(&#123;</div><div class="line">                       msg: isFunction(watch.exp) ? <span class="string">'fn: '</span> + (watch.exp.name || watch.exp.toString()) : watch.exp,</div><div class="line">                       newVal: value,</div><div class="line">                       oldVal: last</div><div class="line">                     &#125;);</div><div class="line">                   &#125;</div><div class="line">                 &#125; <span class="keyword">else</span> <span class="keyword">if</span> (watch === lastDirtyWatch) &#123;</div><div class="line">                   <span class="comment">// If the most recently dirty watcher is now clean, short circuit since the remaining watchers</span></div><div class="line">                   <span class="comment">// have already been tested.</span></div><div class="line">                   dirty = <span class="literal">false</span>;</div><div class="line">                   <span class="keyword">break</span> traverseScopesLoop;</div><div class="line">                 &#125;</div><div class="line">               &#125;</div><div class="line">             &#125; <span class="keyword">catch</span> (e) &#123;</div><div class="line">               $exceptionHandler(e);</div><div class="line">             &#125;</div><div class="line">           &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>通过上面的代码，可以看出,核心就是两个loop，外loop保证所有的model都能检测到,内loop则是真实的检测每个watch,watch.get就是计算监控表达式的值,这个用来跟旧值进行对比,假如不相等，则执行监听函数</p>
<p>注意这里的watch.eq这是是否深度检查的标识,equals方法是angular.js里的公共方法，用来深度对比两个对象,这里的不相等有一个例外，那就是NaN ===NaN,因为这个永远都是false,所以这里加了检查。</p>
<p>另外：<code>$RootScopeProvider</code>中提供了<code>digestTtl</code>方法，用于修改TTL的值（默认是10）,可以这样修改：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">angular.module(<span class="string">'ng'</span>).config([<span class="string">'$rootScopeProvider'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">$RootScopeProvider</span>) </span>&#123;</div><div class="line">  $RootScopeProvider.digestTtl(<span class="number">20</span>);</div><div class="line">&#125;]);</div></pre></td></tr></table></figure></p>
<h2 id="isolate-scope"><a href="#isolate-scope" class="headerlink" title="isolate scope"></a>isolate scope</h2><p>Isolate标识来创建独立作用域，这个在创建指令并且scope属性定义的情况下，会触发这种情况，还有几种别的特殊情况，如果是独立作用域的话，会多一个$root属性，这个默认是指向rootscope的</p>
<p>如果不是独立的作用域，则会生成一个内部的构造函数，把此构造函数的prototype指向当前scope实例</p>
<h2 id="injector"><a href="#injector" class="headerlink" title="$injector"></a>$injector</h2><h4 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a>依赖注入</h4><p>每一个AngularJS应用都有一个注入器(injector)用来处理依赖的创建。注入器是一个负责查找和创建依赖的服务定位器。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> FN_ARGS = <span class="regexp">/^function\s*[^\(]*\(\s*([^\)]*)\)/m</span>;</div><div class="line"><span class="keyword">var</span> FN_ARG_SPLIT = <span class="regexp">/,/</span>;</div><div class="line">    <span class="comment">// 获取服务名</span></div><div class="line"><span class="keyword">var</span> FN_ARG = <span class="regexp">/^\s*(_?)(\S+?)\1\s*$/</span>;</div><div class="line"><span class="keyword">var</span> STRIP_COMMENTS = <span class="regexp">/((\/\/.*$)|(\/\*[\s\S]*?\*\/))/mg</span>;</div><div class="line"><span class="keyword">var</span> $injectorMinErr = minErr(<span class="string">'$injector'</span>);</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">anonFn</span>(<span class="params">fn</span>) </span>&#123;</div><div class="line">  <span class="comment">// For anonymous functions, showing at the very least the function signature can help in</span></div><div class="line">  <span class="comment">// debugging.</span></div><div class="line">  <span class="keyword">var</span> fnText = fn.toString().replace(STRIP_COMMENTS, <span class="string">''</span>),</div><div class="line">      args = fnText.match(FN_ARGS);</div><div class="line">  <span class="keyword">if</span> (args) &#123;</div><div class="line">    <span class="keyword">return</span> <span class="string">'function('</span> + (args[<span class="number">1</span>] || <span class="string">''</span>).replace(<span class="regexp">/[\s\r\n]+/</span>, <span class="string">' '</span>) + <span class="string">')'</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> <span class="string">'fn'</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">annotate</span>(<span class="params">fn, strictDi, name</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> $inject,</div><div class="line">      fnText,</div><div class="line">      argDecl,</div><div class="line">      last;</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> fn === <span class="string">'function'</span>) &#123;</div><div class="line">    <span class="keyword">if</span> (!($inject = fn.$inject)) &#123;</div><div class="line">      $inject = [];</div><div class="line">      <span class="keyword">if</span> (fn.length) &#123;</div><div class="line">        <span class="keyword">if</span> (strictDi) &#123;</div><div class="line">          <span class="keyword">if</span> (!isString(name) || !name) &#123;</div><div class="line">            name = fn.name || anonFn(fn);</div><div class="line">          &#125;</div><div class="line">          <span class="keyword">throw</span> $injectorMinErr(<span class="string">'strictdi'</span>,</div><div class="line">            <span class="string">'&#123;0&#125; is not using explicit annotation and cannot be invoked in strict mode'</span>, name);</div><div class="line">        &#125;</div><div class="line">        fnText = fn.toString().replace(STRIP_COMMENTS, <span class="string">''</span>);</div><div class="line">        argDecl = fnText.match(FN_ARGS);</div><div class="line">        forEach(argDecl[<span class="number">1</span>].split(FN_ARG_SPLIT), <span class="function"><span class="keyword">function</span>(<span class="params">arg</span>) </span>&#123;</div><div class="line">          arg.replace(FN_ARG, <span class="function"><span class="keyword">function</span>(<span class="params">all, underscore, name</span>) </span>&#123;</div><div class="line">            $inject.push(name);</div><div class="line">          &#125;);</div><div class="line">        &#125;);</div><div class="line">      &#125;</div><div class="line">      fn.$inject = $inject;</div><div class="line">    &#125;</div><div class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isArray(fn)) &#123;</div><div class="line">    last = fn.length - <span class="number">1</span>;</div><div class="line">    assertArgFn(fn[last], <span class="string">'fn'</span>);</div><div class="line">    $inject = fn.slice(<span class="number">0</span>, last);</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    assertArgFn(fn, <span class="string">'fn'</span>, <span class="literal">true</span>);</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> $inject;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>annotate函数通过对入参进行针对性分析，若传递的是一个函数，则依赖模块作为入参传递，此时可通过序列化函数进行正则匹配，获取依赖模块的名称并存入$inject数组中返回，另外，通过函数入参传递依赖的方式在严格模式下执行会抛出异常；第二种依赖传递则是通过数组的方式，数组的最后一个元素是需要使用依赖的函数。annotate函数最终返回解析的依赖名称。</p>
<h1 id="Angular优缺点及应用场景"><a href="#Angular优缺点及应用场景" class="headerlink" title="Angular优缺点及应用场景"></a>Angular优缺点及应用场景</h1><p>angular功能全，利用它开发效率可以得到提高，有庞大的社区支持，没有内存泄露隐患，但是在性能上<code>dirty check</code>算是拖了后腿。</p>
<p>angular适合构建CRUD应用，因为它具有构建一个CRUD应用时可能用到的所有技术：数据绑定、基本模板指令、表单验证、路由、深度链接、组件重用、依赖注入。对于像游戏和有图形界面的编辑器之类的应用，会进行频繁且复杂的DOM操作，和CRUD应用不同。因此，可能不适合用Angular来构建。在这种场景下，使用更低抽象层次的类库可能会更好。</p>
<p>参考：</p>
<p><a href="http://wzhscript.com/2015/02/03/mvc-mvp-and-mvvm/" target="_blank" rel="external">浅析 MVC, MVP 与 MVVM之间的异同</a></p>
<p><a href="http://www.cnblogs.com/whitewolf/p/4581254.htm" target="_blank" rel="external">angular中的MVVM模式</a></p>
<p><a href="http://hellohtml5.com/2014/10/16/how-angularjs-apply-works/" target="_blank" rel="external">angularjs原理分析，及正确$apply的方法</a></p>
<p><a href="http://www.cnblogs.com/lovesueee/p/4062247.html" target="_blank" rel="external">angularjs1.3.0源码解析之scope</a></p>
<p>中文API：</p>
<p><a href="http://docs.ngnice.com/#!/guide" target="_blank" rel="external">http://docs.ngnice.com/#!/guide</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://sheilacat.github.io/angular-and-mvvm/" data-id="ciww2ofyv0001useq7qc7c91r" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/cache-strategy/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          缓存策略
        
      </div>
    </a>
  
  
    <a href="/mongodb-intro/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">mongodb</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    <div class="widget-wrap">
	<h3 class="widget-title">PROFILE</h3>
	<div class="widget">
		<div class="profile">
			<img class="profile" />
		  	<p>SHEILACAT</p>
		  	<span>You said you grow old with me.</span>
		  	<p class="link">
		  		<a class="me-github" target="_blank" href="https://github.com/sheilaCat"></a>
			  	<a class="me-weibo" href="#"></a>
			  	<a class="me-zhihu" target="_blank" href="https://www.zhihu.com/people/sheilaCat"></a>
	  	        
	  	        	<a class="me-rss" href="/atom.xml"></a>
		        
		  	</p>
	  		<div class="tags">
	  			<span>这个杀手不太冷</span>
	  			<span>叔本华迷妹</span>
	  			<span>前端攻城狮</span>
	  			<span>可能是个萌妹子</span>
	  		</div>
		</div>
	</div>
</div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/weixin-tiny-program/">微信小程序概念及实践</a>
          </li>
        
          <li>
            <a href="/node-straight-out/">node直出与同构javascript</a>
          </li>
        
          <li>
            <a href="/learn-es6/">ECMAScript6学习</a>
          </li>
        
          <li>
            <a href="/javascript-error-handle/">JavaScript错误处理</a>
          </li>
        
          <li>
            <a href="/create-an-object/">面向对象的程序设计——创建对象</a>
          </li>
        
      </ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">分类</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Coffeescript/">Coffeescript</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/JavaScript/">JavaScript</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/linux/">linux</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/mongodb/">mongodb</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/node/">node</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/前端技术/">前端技术</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/前端规范化/">前端规范化</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/浏览器相关/">浏览器相关</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/网络知识/">网络知识</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/读书笔记/">读书笔记</a><span class="category-list-count">2</span></li></ul>
    </div>
  </div>


  
    <div class="widget-wrap">
	<h3 class="widget-title">FRIENDS</h3>
	<div class="widget">
		<a href="http://blog.chenzuhuang.com/">祖神的博客</a>
	</div>
</div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2016 SheilaCat<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>